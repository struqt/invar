<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="typescript"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <export resPath="typescript/invar.codec.ts" destDir="." destName="invar.codec.ts"/>
  <export resPath="typescript/invar.types.ts" destDir="." destName="invar.types.ts"/>

  <!-- Redefine 14 Invar buildin types to adapt TypeScript language -->
  <redefine>
    <int8 pack="  " type="Invar.Int08   " initValue="-1"/>
    <int16 pack=" " type="Invar.Int16   " initValue="-1"/>
    <int32 pack=" " type="Invar.Int32   " initValue="-1"/>
    <int64 pack=" " type="Invar.Int64   " initValue="00"/>
    <uint8 pack=" " type="Invar.Uint08  " initValue="0"/>
    <uint16 pack="" type="Invar.Uint16  " initValue="0"/>
    <uint32 pack="" type="Invar.Uint32  " initValue="0"/>
    <uint64 pack="" type="Invar.Uint64  " initValue="00"/>
    <float pack=" " type="Invar.Float32 " initValue="0.0"/>
    <double pack="" type="Invar.Float64 " initValue="0.00"/>
    <string pack="" type="string " initValue=""/>
    <bool pack="  " type="boolean" initValue="false"/>
    <vec pack="   " type="Array  " initValue="" generic="&lt;?&gt;"/>
    <map pack="   " type="Object " initValue="" generic="&lt;?,?&gt;"/>
  </redefine>

  <!-- Settings -->
  <template key="trace.all.types">     <![CDATA[ false ]]></template>
  <template key="unique.type.name">    <![CDATA[ true  ]]></template>
  <template key="capitalize.pack.head"><![CDATA[ true  ]]></template>
  <template key="one.pack.one.file">   <![CDATA[ true  ]]></template>
  <template key="pack.name.nested">    <![CDATA[ false ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ true  ]]></template>
  <template key="include.self">        <![CDATA[ false ]]></template>
  <template key="code.dir.flatten">    <![CDATA[ true  ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ false ]]></template>
  <template key="no.generic.type">     <![CDATA[ false ]]></template>
  <template key="method.indent.num">   <![CDATA[ 1     ]]></template>
  <template key="code.dir.prefix">     <![CDATA[  ]]></template>
  <template key="import.exclude.same.pack"><![CDATA[ false ]]></template>
  <template key="import.exclude.conflict"> <![CDATA[ false  ]]></template>

  <!-- Common snippet -->
  <template key="import">      <![CDATA[ (#body)(#brk) ]]></template>
  <template key="import.body"> <![CDATA[ from (#pack) import (#name) ]]></template>
  <template key="import.split"><![CDATA[ ]]></template>

  <template key="init.any">    <![CDATA[ (#deft)         ]]></template>
  <template key="init.string"> <![CDATA[ '(#deft)'       ]]></template>
  <template key="init.int64">  <![CDATA[ new Invar.Int64('(#deft)')  ]]></template>
  <template key="init.uint64"> <![CDATA[ new Invar.Uint64('(#deft)') ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name) ]]></template>
  <template key="init.struct"> <![CDATA[ (#type)()       ]]></template>
  <template key="init.vec">    <![CDATA[ new (#type)()   ]]></template>
  <template key="init.map">    <![CDATA[ {}    ]]></template>

  <template key="pointer.null">  <![CDATA[ None ]]></template>
  <template key="pointer.spec">  <![CDATA[ ?*  ]]></template>
  <template key="pointer.invoke"><![CDATA[ ?-> ]]></template>
  <template key="pointer.copy">  <![CDATA[ (#name) = (#arg) ]]></template>

  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg) ]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>

  <template key="byte.yes">      <![CDATA[ 0x01 ]]></template>
  <template key="byte.non">      <![CDATA[ 0x00 ]]></template>

  <template key="file.head"><![CDATA[
	/*===--------------------------*  TypeScript  *----------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===*/
  ]]></template>
  <template key="file"><![CDATA[
    (#head)
    import { Invar } from "./invar.codec"
    (#pack) ]]></template>
  <template key="file.pack"><![CDATA[
    (#includes)
    export module (#name) {
    (#body)} ]]></template>
  <template key="file.body"><![CDATA[
    (#enums)(#structs)]]></template>
  <template key="doc"><![CDATA[ /* (#doc) */ ]]></template>
  <template key="doc.line"><![CDATA[ // (#doc). ]]></template>

  <template key="enum"><![CDATA[
    #from enum import Enum, unique
    #@unique
    #class (#name)(Enum):
    class (#name)(object):
    (#blank)
    (#tab)(#doc)
    (#body)
    # end enum (#name)
	]]></template>
  <template key="enum.field"><![CDATA[
    (#tab)(#name) = (#value)(#doc)
  ]]></template>
  <template key="struct.protoc.ntf"> <![CDATA[ (#brk), Invar.ProtocNotify   ]]></template>
  <template key="struct.protoc.req"> <![CDATA[ (#brk), Invar.ProtocRequest  ]]></template>
  <template key="struct.protoc.resp"><![CDATA[ (#brk), Invar.ProtocResponse ]]></template>
  <template key="struct.const.name.crc"><![CDATA[ (#type).CRC32 ]]></template>
  <template key="struct"><![CDATA[
    (#doc)
    export class (#name) {
    (#blank)
    (#tab)static get CRC32(): string { return '[#codeCRC32(struct)]' }
    (#tab)static get SIZE() : number { return [#codeBasicSize(struct)] }
    (#blank)
    [#codeFields (struct; fields)]
    (#blank)
    [#codeNested (ctor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (size.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (read.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (write.; useFullName; struct; fields; imports)]
    (#blank)
    } /* class (#name) */
    (#blank)
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.prefix"><![CDATA[ this._ ]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private _[#clampLen(lenFieldNameR; 16; (#namer) )]:
    (#concat) [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#codeDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)@(#namer).setter [#codeDoc(fields; (#index))]
    (#tab)def (#namer)(self, value):
    (#tab)(#tab)(#name) = value
    (#tab)(#tab)return self
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)@property [#codeDoc(fields; (#index))]
    (#tab)def (#namer)(self):
    (#tab)(#tab)return (#name)
  ]]></template>

  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    (#tab)constructor() {(#body)
    (#tab)}
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#null) ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body) ]]></template>


  <!-- Read bytes from a Stream -->
  <template key="read.import">
    <![CDATA[ System.IO::BinaryReader,System.Text::Encoding,System::Enum ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public read(r :Invar.BinaryReader): void {(#body)
    (#tab)} /* (#type)::read(...) */ ]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).readInt08()   ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).readInt16()   ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).readInt32()   ]]></template>
  <template key="read.int64"> <![CDATA[ new Invar.Int64((#arg).readInt64()) ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).readUint08()  ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).readUint16()  ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).readUint32()  ]]></template>
  <template key="read.uint64"><![CDATA[ new Invar.Uint64((#arg).readUint64()) ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).readFloat32() ]]></template>
  <template key="read.double"><![CDATA[ (#arg).readFloat64() ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).readBoolean() ]]></template>
  <template key="read.string">
    <![CDATA[ Encoding.UTF8.GetString((#arg).ReadBytes((#arg).ReadInt32())) ]]></template>
  <template key="read.enum">
    <![CDATA[ ((#type))Enum.ToObject(typeof((#type)), (#arg).ReadInt32()) ]]></template>
  <template key="read.struct"><![CDATA[ (#name).Read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v">
    <![CDATA[ let (#name): (#type) = (#body) ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) (#name) = new (#type)();
    (#body);
  ]]></template>
  <template key="read.vec.head">
    <![CDATA[ let (#name): (#type) = new (#type)()(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    let (#len): number = (#arg).readInt32()
    for (let (#index): number = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)(#name).push((#value))
    }
  ]]></template>
  <template key="read.map.head">
    <![CDATA[(#type) (#name) = new (#type)(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    let (#len): number = (#arg).ReadUInt32();
    for (let (#index): number = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)if (!(#name).ContainsKey((#key))) {
    (#tab)(#tab)(#name).Add((#key), (#value));
    (#tab)} else {
    (#tab)(#tab)(#name)[(#key)] = (#value);
    (#tab)}
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 496); }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = new (#type)(); }
    (#tab)(#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 497); }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = new (#type)(); }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 498); }
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#brk)if (CRC32 != (#name)) { throw new IOException("Protoc read error: CRC32 is mismatched.", 499); }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) {
    (#tab)throw new IOException("Protoc read error: The code is " + (#name), (#name));
    }
  ]]></template>


</tns:root>
