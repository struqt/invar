<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="objc"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <export resPath="objc/Invar.m" destDir="" destName="Invar.m"/>
  <export resPath="objc/InvarClient.m" destDir="" destName="InvarClient.m"/>
  <export resPath="objc/DataReader.m" destDir="" destName="DataReader.m"/>
  <export resPath="objc/DataWriter.m" destDir="" destName="DataWriter.m"/>

  <!-- Redefine 14 Invar buildin types to adapt Objective-C language -->
  <redefine genericOverride="true"/>

  <!-- Settings -->
  <template key="trace.all.types">     <![CDATA[ false ]]></template>
  <template key="unique.type.name">    <![CDATA[ true  ]]></template>
  <template key="capitalize.pack.head"><![CDATA[ true  ]]></template>
  <template key="one.pack.one.file">   <![CDATA[ false ]]></template>
  <template key="include.self">        <![CDATA[ true  ]]></template>
  <template key="pack.name.nested">    <![CDATA[ true  ]]></template>
  <template key="code.dir.flatten">    <![CDATA[ true  ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ false ]]></template>
  <template key="no.generic.type">     <![CDATA[ true  ]]></template>
  <template key="method.indent.num">   <![CDATA[ 0     ]]></template>
  <template key="code.dir.prefix">     <![CDATA[  ]]></template>

  <!-- Common snippet -->
  <template key="init.any">   <![CDATA[ (#deft)    ]]></template>
  <template key="init.int64"> <![CDATA[ (#deft)L   ]]></template>
  <template key="init.uint64"><![CDATA[ (#deft)UL  ]]></template>
  <template key="init.float"> <![CDATA[ (#deft)F   ]]></template>
  <template key="init.enum">  <![CDATA[ (#type)(#name)    ]]></template>
  <template key="init.string"><![CDATA[ @"(#deft)" ]]></template>
  <template key="init.struct"><![CDATA[ [[(#type) alloc] init] ]]></template>
  <template key="init.vec">   <![CDATA[ [[NSMutableArray alloc] init] ]]></template>
  <template key="init.map">   <![CDATA[ [[NSMutableDictionary alloc] init] ]]></template>
  <template key="byte.yes">    <![CDATA[ 0x01 ]]></template>
  <template key="byte.non">    <![CDATA[ 0x00 ]]></template>
  <template key="doc">         <![CDATA[/* (#doc). */]]></template>
  <template key="doc.line">    <![CDATA[// (#doc).]]></template>
  <template key="import.split"><![CDATA[  ]]></template>
  <template key="pointer.null">  <![CDATA[ nil ]]></template>
  <template key="ptr.mark.string | ptr.mark.vec |
                 ptr.mark.struct | ptr.mark.map"><![CDATA[ * ]]></template>
  <template key="struct.field.prefix"><![CDATA[ _ ]]></template>
  <template key="struct.const.name.crc"><![CDATA[ CRC32__ ]]></template>

  <template key="file"><![CDATA[
    //*==---------------------------*  Obj-C  *--------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------==*//
    ///*
    #if ! __has_feature(objc_arc)
    #error This file must be compiled with ARC. Either turn on ARC for the project or use -fobjc-arc flag
    #endif //*/
    (#blank)
    (#includes)
    (#pack)
	]]></template>
  <template key="file.include"><![CDATA[ #import "(#name)"(#brk) ]]></template>
  <template key="file.pack"><![CDATA[ (#body) ]]></template>
  <template key="file.body"><![CDATA[
    (#blank)
    (#structs)]]></template>
  <template key="struct.meta"><![CDATA[ /* (#name) (#mark)-(#type) */ ]]></template>
  <template key="struct.field.self"><![CDATA[ & ]]></template>
  <template key="struct.field"><![CDATA[
	  (#tab)[#clampLen(lenFieldType; 64; (#type) )] (#mark)
	  (#concat) [#clampLen(lenFieldName; 32; (#name) )];
	  (#concat) [#codeMetaData(fields; (#index))]
	]]></template>
  <template key="struct.field.del"><![CDATA[
    (#brk)(#tab)if ((#name) != (#null)) {
    (#tab)(#tab)delete (#name);
    (#tab)(#tab)(#name) = (#null);
    (#tab)}]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; ::DataWriter)]
    [#addImport(struct; imports; ::DataReader)]
    #define (#const-crc) 0x[#codeCRC32(struct)]
    #define SIZE__  [#codeBasicSize(struct)]L
    (#blank)
    @interface (#name) ()
    {
    [#codeFields(struct; fields)]}
    @end
    (#blank)
    @implementation (#name)
    (#blank)
    [#codeNested (ctor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (dtor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (copy.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeGetters(struct; fields)]
    (#blank)
    [#codeSetters(struct; fields)]
    (#blank)
    [#codeNested (read.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (write.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (size.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (tojson.;  useFullName; struct; fields; imports)]
    (#blank)
    @end /* @implementation (#name) */
    /*(#brk)(#debug)*/
	]]></template>

  <template key="struct.getter"><![CDATA[
    - ([#clampLen(lenFieldType; 64; (#type) )] (#mark))
    (#concat) [#clampLen(lenFieldNameR; 32; (#namer) )] {
    (#concat) return [#clampLen(lenFieldName; 32; (#name) )]; }
  ]]></template>
  <template key="struct.setter"><![CDATA[
    - ((#typeupper) *) set[#clampLen(lenFieldName; 24; [#upperHeadChar( (#namer) )] )]:
    (#concat) ([#clampLen(lenFieldType; 64; (#type) )] (#mark))v
    (#concat) { [#clampLen(lenFieldName; 32; (#name) )] = v;
    (#concat) return self;
    (#concat) }
  ]]></template>


  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    - (instancetype) init
    {
    (#tab)self = [super init];
    (#tab)if (!self) { return self; }(#body)
    (#tab)return self;
    }
    /* (#type)::init */
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#null); ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body); ]]></template>


  <!-- Method Destruct -->
  <template key="dtor.method"><![CDATA[
    - (void) dealloc
    {(#body)
    }
    /* (#type)::dealloc */
  ]]></template>
  <template key="dtor.any"><![CDATA[ ]]></template>
  <template key="dtor.vec | dtor.map | dtor.string | dtor.struct"><![CDATA[
    if ([#clampLen(lenFieldName; 32; (#name) )]) {
    (#concat-all) [#clampLen(lenFieldName; 32; (#name) )] = nil; } ]]></template>
  <template key="dtor.ptr.any"><![CDATA[ (#body) ]]></template>
  <template key="dtor.ref.any"><![CDATA[ (#body) ]]></template>

  <!-- Method Copy -->
  <template key="copy.method"><![CDATA[
    - (id) copyWithZone:(nullable NSZone *)zone;
    {
    (#tab)id copy = [[[self class] allocWithZone:zone] init];
    (#tab)DataWriter *writer = [DataWriter CreateWithData:[[NSMutableData alloc] initWithCapacity:[self byteSize]]];
    (#tab)[self write:writer];
    (#tab)[copy read:[DataReader CreateWithData:writer.data]];
    (#tab)return copy;
    }
    /* (#type)::copyWithZone */
  ]]></template>

  <!-- Method Read -->
  <template key="read.import"><![CDATA[ ::DataReader ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    - (NSInteger)read:(const DataReader * const)r
    {
    (#tab)BOOL eof = false;(#body)
    (#tab)return INVAR_ERR_NONE;
    }
    /* (#type)::read(...) */ ]]></template>
  <template key="read.int8">  <![CDATA[ [(#arg) readInt8:&eof]   ]]></template>
  <template key="read.int16"> <![CDATA[ [(#arg) readInt16:&eof]  ]]></template>
  <template key="read.int32"> <![CDATA[ [(#arg) readInt32:&eof]  ]]></template>
  <template key="read.int64"> <![CDATA[ [(#arg) readInt64:&eof]  ]]></template>
  <template key="read.uint8"> <![CDATA[ [(#arg) readUInt8:&eof]  ]]></template>
  <template key="read.uint16"><![CDATA[ [(#arg) readUInt16:&eof] ]]></template>
  <template key="read.uint32"><![CDATA[ [(#arg) readUInt32:&eof] ]]></template>
  <template key="read.uint64"><![CDATA[ [(#arg) readUInt64:&eof] ]]></template>
  <template key="read.float"> <![CDATA[ [(#arg) readFloat:&eof]  ]]></template>
  <template key="read.double"><![CDATA[ [(#arg) readDouble:&eof] ]]></template>
  <template key="read.string"><![CDATA[ [(#arg) readString:&eof] ]]></template>
  <template key="read.bool">  <![CDATA[ [(#arg) readBool:&eof]   ]]></template>
  <template key="read.enum">  <![CDATA[ ((#type))[(#arg) readInt32:&eof]  ]]></template>
  <template key="read.struct"><![CDATA[ NSInteger (#namer)Err = [(#name) read:(#arg)]    ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.int8  |read.nest.k.int8  |read.nest.v.int8  |
                 read.nest.n.int16 |read.nest.k.int16 |read.nest.v.int16 |
                 read.nest.n.int32 |read.nest.k.int32 |read.nest.v.int32 |
                 read.nest.n.int64 |read.nest.k.int64 |read.nest.v.int64 |
                 read.nest.n.uint8 |read.nest.k.uint8 |read.nest.v.uint8 |
                 read.nest.n.uint16|read.nest.k.uint16|read.nest.v.uint16|
                 read.nest.n.uint32|read.nest.k.uint32|read.nest.v.uint32|
                 read.nest.n.uint64|read.nest.k.uint64|read.nest.v.uint64|
                 read.nest.n.float |read.nest.k.float |read.nest.v.float |
                 read.nest.n.double|read.nest.k.double|read.nest.v.double"><![CDATA[
    NSNumber *(#name) = @((#body)); if (eof) { return INVAR_ERR_DECODE_EOF; } ]]></template>
  <template key="read.nest.n.bool|read.nest.k.bool|read.nest.v.bool|
                 read.nest.n.enum|read.nest.k.enum|read.nest.v.enum"><![CDATA[
    id (#name) = @((#body)); if (eof) { return INVAR_ERR_DECODE_EOF; } ]]></template>
  <template key="read.nest.n.string|read.nest.k.string|read.nest.v.string"><![CDATA[
    (#type) *(#name) = (#body); if (eof) { return INVAR_ERR_DECODE_EOF; } ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) *(#name) = [[(#type) alloc] init];
    (#body); if ((#namer)Err != 0) { return (#namer)Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
  ]]></template>
  <template key="read.vec.head"><![CDATA[
    (#typel) *(#name) = [[(#typel) alloc] init]; //read.vec.head(#brk) ]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) addObject:(#value)];
    }
  ]]></template>
  <template key="read.map.head">
    <![CDATA[ (#typel) *(#name) = [[(#typel) alloc] init]; //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) setObject:(#value) forKey:(#key)];
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return INVAR_ERR_DECODE_STRING_P; }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#type) alloc] init]; }
    (#tab)(#body); if ((#namer)Err != 0) { return (#namer)Err; }
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return INVAR_ERR_DECODE_STRUCT_P; }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#typel) alloc] init]; }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return INVAR_ERR_DECODE_VEC_MAP_P; }
  ]]></template>
  <template key="read.field.tail.any"><![CDATA[
    (#concat-all)(#space)if (eof) { return INVAR_ERR_DECODE_EOF; }
  ]]></template>
  <template key="read.field.tail.struct"><![CDATA[
    (#space)if ((#namer)Err != 0) { return (#namer)Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
  ]]></template>
  <template key="read.field.tail.struct.ptr | read.field.tail.vec | read.field.tail.map"><![CDATA[
    (#concat-all)(#space)if (eof) { return INVAR_ERR_DECODE_EOF; }
  ]]></template>
  <template key="read.special.protocId"><![CDATA[ (#brk)
    if ((#protoc-id) != (#name)) { (#name) = (#protoc-id); return INVAR_ERR_PROTOC_INVALID_ID; }
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#space)if ((#const-crc) != (#name)) { return INVAR_ERR_PROTOC_CRC_MISMATCH; }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    if ((#name) != 0) { return (#name); }
  ]]></template>


  <!-- Method Write -->
  <template key="write.import"><![CDATA[ ::DataWriter ]]></template>
  <template key="write.method.arg"><![CDATA[ w ]]></template>
  <template key="write.method"><![CDATA[
    - (NSInteger)write:(DataWriter *)(#arg)
    {(#body)
    (#tab)return 0;
    }
    /* (#type)::write */ ]]></template>
  <template key="write.int8">  <![CDATA[ [(#arg) writeInt8:(#name)]   ]]></template>
  <template key="write.int16"> <![CDATA[ [(#arg) writeInt16:(#name)]  ]]></template>
  <template key="write.int32"> <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.int64"> <![CDATA[ [(#arg) writeInt64:(#name)]  ]]></template>
  <template key="write.uint8"> <![CDATA[ [(#arg) writeUInt8:(#name)]  ]]></template>
  <template key="write.uint16"><![CDATA[ [(#arg) writeUInt16:(#name)] ]]></template>
  <template key="write.uint32"><![CDATA[ [(#arg) writeUInt32:(#name)] ]]></template>
  <template key="write.uint64"><![CDATA[ [(#arg) writeUInt64:(#name)] ]]></template>
  <template key="write.float"> <![CDATA[ [(#arg) writeFloat:(#name)]  ]]></template>
  <template key="write.double"><![CDATA[ [(#arg) writeDouble:(#name)] ]]></template>
  <template key="write.bool">  <![CDATA[ [(#arg) writeBool:(#name)]   ]]></template>
  <template key="write.string"><![CDATA[ [(#arg) writeString:(#name)] ]]></template>
  <template key="write.enum">  <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.struct"><![CDATA[ [(#name) write:(#arg)]       ]]></template>
  <template key="write.vec.head">  <![CDATA[ ]]></template>
  <template key="write.vec.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#value) in (#name)) {(#body)
    }
  ]]></template>
  <template key="write.map.head.k"><![CDATA[ ]]></template>
  <template key="write.map.head.v"><![CDATA[
    (#typel) *(#name) = [(#nameupper2) objectForKey:(#key)];/*write.map.head.v*/(#brk) ]]></template>
  <template key="write.map.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#key) in (#name)) {(#body)
    }
  ]]></template>

  <template key="write.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.k"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.n.int8 | write.nest.k.int8"><![CDATA[
    [(#arg) writeInt8:[(#name) charValue]]; ]]></template>
  <template key="write.nest.n.uint8 | write.nest.k.uint8 | write.nest.n.bool | write.nest.k.bool"><![CDATA[
    [(#arg) writeUInt8:[(#name) unsignedCharValue]]; ]]></template>
  <template key="write.nest.n.int16 | write.nest.k.int16"><![CDATA[
    [(#arg) writeInt16:[(#name) shortValue]]; ]]></template>
  <template key="write.nest.n.uint16 | write.nest.k.uint16"><![CDATA[
    [(#arg) writeUInt16:[(#name) unsignedShortValue]]; ]]></template>
  <template key="write.nest.n.int32 | write.nest.k.int32 | write.nest.n.enum | write.nest.k.enum"><![CDATA[
    [(#arg) writeInt32:[(#name) intValue]]; ]]></template>
  <template key="write.nest.n.uint32 | write.nest.k.uint32"><![CDATA[
    [(#arg) writeUInt32:[(#name) unsignedIntValue]]; ]]></template>
  <template key="write.nest.n.int64 | write.nest.k.int64"><![CDATA[
    [(#arg) writeInt64:[(#name) longValue]]; ]]></template>
  <template key="write.nest.n.uint64 | write.nest.k.uint64"><![CDATA[
    [(#arg) writeUInt64:[(#name) unsignedLongValue]]; ]]></template>
  <template key="write.nest.n.float | write.nest.k.float"><![CDATA[
    [(#arg) writeFloat:[(#name) floatValue]]; ]]></template>
  <template key="write.nest.n.double | write.nest.k.double"><![CDATA[
    [(#arg) writeDouble:[(#name) doubleValue]]; ]]></template>

  <template key="write.nest.v"><![CDATA[
    (#type) (#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>
  <template key="write.nest.v.int8"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] charValue]; (#body); ]]></template>
  <template key="write.nest.v.uint8 | write.nest.v.bool"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedCharValue]; (#body); ]]></template>
  <template key="write.nest.v.int16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] shortValue]; (#body); ]]></template>
  <template key="write.nest.v.uint16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedShortValue]; (#body); ]]></template>
  <template key="write.nest.v.int32 | write.nest.v.enum"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] intValue]; (#body); ]]></template>
  <template key="write.nest.v.uint32"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedIntValue]; (#body); ]]></template>
  <template key="write.nest.v.int64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] longValue]; (#body); ]]></template>
  <template key="write.nest.v.uint64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedLongValue]; (#body); ]]></template>
  <template key="write.nest.v.float"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] floatValue]; (#body); ]]></template>
  <template key="write.nest.v.double"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] doubleValue]; (#body); ]]></template>
  <template key="write.nest.v.string | write.nest.v.struct | write.nest.v.vec | write.nest.v.map"><![CDATA[
    (#type) *(#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>

  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) { [(#arg) writeInt8:(#byteyes)]; (#body); }
    else { [(#arg) writeInt8:(#bytenon)]; }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)[(#arg) writeInt8:(#byteyes)];(#bodyindent)
    } else {
    (#tab)[(#arg) writeInt8:(#bytenon)];
    }
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) { return (#name); }
  ]]></template>

  <!-- Method Write -->
  <template key="write.import"><![CDATA[ ::DataWriter ]]></template>
  <template key="write.method.arg"><![CDATA[ w ]]></template>
  <template key="write.method"><![CDATA[
    - (NSInteger)write:(DataWriter *)(#arg)
    {(#body)
    (#tab)return 0;
    }
    /* (#type)::write */ ]]></template>
  <template key="write.int8">  <![CDATA[ [(#arg) writeInt8:(#name)]   ]]></template>
  <template key="write.int16"> <![CDATA[ [(#arg) writeInt16:(#name)]  ]]></template>
  <template key="write.int32"> <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.int64"> <![CDATA[ [(#arg) writeInt64:(#name)]  ]]></template>
  <template key="write.uint8"> <![CDATA[ [(#arg) writeUInt8:(#name)]  ]]></template>
  <template key="write.uint16"><![CDATA[ [(#arg) writeUInt16:(#name)] ]]></template>
  <template key="write.uint32"><![CDATA[ [(#arg) writeUInt32:(#name)] ]]></template>
  <template key="write.uint64"><![CDATA[ [(#arg) writeUInt64:(#name)] ]]></template>
  <template key="write.float"> <![CDATA[ [(#arg) writeFloat:(#name)]  ]]></template>
  <template key="write.double"><![CDATA[ [(#arg) writeDouble:(#name)] ]]></template>
  <template key="write.bool">  <![CDATA[ [(#arg) writeBool:(#name)]   ]]></template>
  <template key="write.string"><![CDATA[ [(#arg) writeString:(#name)] ]]></template>
  <template key="write.enum">  <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.struct"><![CDATA[ [(#name) write:(#arg)]       ]]></template>
  <template key="write.vec.head">  <![CDATA[ ]]></template>
  <template key="write.vec.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#value) in (#name)) {(#body)
    }
  ]]></template>
  <template key="write.map.head.k"><![CDATA[ ]]></template>
  <template key="write.map.head.v"><![CDATA[
    (#typel) *(#name) = [(#nameupper2) objectForKey:(#key)];/*write.map.head.v*/(#brk) ]]></template>
  <template key="write.map.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#key) in (#name)) {(#body)
    }
  ]]></template>

  <template key="write.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.k"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.n.int8 | write.nest.k.int8"><![CDATA[
    [(#arg) writeInt8:[(#name) charValue]]; ]]></template>
  <template key="write.nest.n.uint8 | write.nest.k.uint8 | write.nest.n.bool | write.nest.k.bool"><![CDATA[
    [(#arg) writeUInt8:[(#name) unsignedCharValue]]; ]]></template>
  <template key="write.nest.n.int16 | write.nest.k.int16"><![CDATA[
    [(#arg) writeInt16:[(#name) shortValue]]; ]]></template>
  <template key="write.nest.n.uint16 | write.nest.k.uint16"><![CDATA[
    [(#arg) writeUInt16:[(#name) unsignedShortValue]]; ]]></template>
  <template key="write.nest.n.int32 | write.nest.k.int32 | write.nest.n.enum | write.nest.k.enum"><![CDATA[
    [(#arg) writeInt32:[(#name) intValue]]; ]]></template>
  <template key="write.nest.n.uint32 | write.nest.k.uint32"><![CDATA[
    [(#arg) writeUInt32:[(#name) unsignedIntValue]]; ]]></template>
  <template key="write.nest.n.int64 | write.nest.k.int64"><![CDATA[
    [(#arg) writeInt64:[(#name) longValue]]; ]]></template>
  <template key="write.nest.n.uint64 | write.nest.k.uint64"><![CDATA[
    [(#arg) writeUInt64:[(#name) unsignedLongValue]]; ]]></template>
  <template key="write.nest.n.float | write.nest.k.float"><![CDATA[
    [(#arg) writeFloat:[(#name) floatValue]]; ]]></template>
  <template key="write.nest.n.double | write.nest.k.double"><![CDATA[
    [(#arg) writeDouble:[(#name) doubleValue]]; ]]></template>

  <template key="write.nest.v"><![CDATA[
    (#type) (#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>
  <template key="write.nest.v.int8"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] charValue]; (#body); ]]></template>
  <template key="write.nest.v.uint8 | write.nest.v.bool"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedCharValue]; (#body); ]]></template>
  <template key="write.nest.v.int16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] shortValue]; (#body); ]]></template>
  <template key="write.nest.v.uint16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedShortValue]; (#body); ]]></template>
  <template key="write.nest.v.int32 | write.nest.v.enum"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] intValue]; (#body); ]]></template>
  <template key="write.nest.v.uint32"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedIntValue]; (#body); ]]></template>
  <template key="write.nest.v.int64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] longValue]; (#body); ]]></template>
  <template key="write.nest.v.uint64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedLongValue]; (#body); ]]></template>
  <template key="write.nest.v.float"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] floatValue]; (#body); ]]></template>
  <template key="write.nest.v.double"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] doubleValue]; (#body); ]]></template>
  <template key="write.nest.v.string | write.nest.v.struct | write.nest.v.vec | write.nest.v.map"><![CDATA[
    (#type) *(#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>

  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) { [(#arg) writeInt8:(#byteyes)]; (#body); }
    else { [(#arg) writeInt8:(#bytenon)]; }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)[(#arg) writeInt8:(#byteyes)];(#bodyindent)
    } else {
    (#tab)[(#arg) writeInt8:(#bytenon)];
    }
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) { return (#name); }
  ]]></template>


  <!-- Method Write -->
  <template key="size.import"><![CDATA[ ::DataWriter ]]></template>
  <template key="size.method.arg"><![CDATA[ size ]]></template>
  <template key="size.method"><![CDATA[
    - (NSUInteger)byteSize
    {
    (#tab)NSUInteger size = SIZE__;(#body)
    (#tab)return size;
    }
    /* (#type)::byteSize */ ]]></template>
  <template key="size.int8">  <![CDATA[ sizeof(int8_t)   ]]></template>
  <template key="size.int16"> <![CDATA[ sizeof(int16_t)  ]]></template>
  <template key="size.int32"> <![CDATA[ sizeof(int32_t)  ]]></template>
  <template key="size.int64"> <![CDATA[ sizeof(int64_t)  ]]></template>
  <template key="size.uint8"> <![CDATA[ sizeof(uint8_t)  ]]></template>
  <template key="size.uint16"><![CDATA[ sizeof(uint16_t) ]]></template>
  <template key="size.uint32"><![CDATA[ sizeof(uint32_t) ]]></template>
  <template key="size.uint64"><![CDATA[ sizeof(uint64_t) ]]></template>
  <template key="size.float"> <![CDATA[ sizeof(float_t)  ]]></template>
  <template key="size.double"><![CDATA[ sizeof(double_t) ]]></template>
  <template key="size.bool">  <![CDATA[ sizeof(uint8_t)  ]]></template>
  <template key="size.enum">  <![CDATA[ sizeof(int32_t)  ]]></template>
  <template key="size.string"><![CDATA[ [(#name) length] ]]></template>
  <template key="size.struct"><![CDATA[ [(#name) byteSize] ]]></template>
  <template key="size.ref.any"><![CDATA[ (#concat-all) ]]></template>
  <template key="size.ref.vec | size.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="size.ref.string | size.ref.struct"><![CDATA[
    (#arg) += (#body);
  ]]></template>
  <template key="size.ptr.string | size.ptr.struct"><![CDATA[
    if ((#name) != (#null)) { (#arg) += (#body); }
  ]]></template>
  <template key="size.ptr.vec | size.ptr.map"><![CDATA[
    if ((#name) != (#null)) {(#bodyindent)
    }
  ]]></template>
  <template key="size.vec.head">  <![CDATA[ ]]></template>
  <template key="size.vec.for"><![CDATA[
    (#arg) += sizeof(uint32_t);
    for (id (#value) in (#name)) {(#body)
    }
  ]]></template>
  <template key="size.map.head.k"><![CDATA[ ]]></template>
  <template key="size.map.head.v"><![CDATA[
    (#typel) *(#name) = [(#nameupper2) objectForKey:(#key)];/*size.map.head.v*/(#brk) ]]></template>
  <template key="size.map.for"><![CDATA[
    (#arg) += sizeof(uint32_t);
    for (id (#key) in (#name)) {(#body)
    }
  ]]></template>
  <template key="size.nest.n"><![CDATA[ (#arg) += (#body); ]]></template>
  <template key="size.nest.k"><![CDATA[ (#arg) += (#body); ]]></template>
  <template key="size.nest.v"><![CDATA[ (#arg) += (#body); ]]></template>
  <template key="size.nest.v.string|size.nest.v.struct|size.nest.v.vec|size.nest.v.map"><![CDATA[
    (#type) *(#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#arg) += (#body); ]]></template>
  <template key="size.vec.for.simple | size.map.for.simple"><![CDATA[
    if ([(#name) count] > 0) { (#arg) += [(#name) count] * (#sizeof); }
  ]]></template>

  <!-- Write data to JSON data format -->
  <template key="tojson.import">      <![CDATA[ ]]></template>
  <template key="tojson.method.arg">  <![CDATA[ s ]]></template>
  <template key="tojson.method"><![CDATA[
    - (NSString *)toStringJSON;
    {
    (#tab)NSMutableString *(#arg) = [[NSMutableString alloc] init] ;
    (#tab)[self writeJSON:(#arg)];
    (#tab)return (#arg);
    }
    (#blank)
    - (void)writeJSON:(NSMutableString *)(#arg)
    {
    (#tab)[(#arg) appendString:LINE_FEED_S]; [(#arg) appendString:LEFT_CURLY_S];
    (#tab)NSString *comma = nil;(#body)
    (#tab)[(#arg) appendString:RIGHT_CURLY_S]; [(#arg) appendString:LINE_FEED_S];
    }
    /* (#type)::writeJSON */ ]]></template>
  <template key="tojson.any"> <![CDATA[ [(#arg) appendFormat:FORMAT_S, (#name)] ]]></template>
  <template key="tojson.bool"><![CDATA[ [(#arg) appendString:(#name) ? @"true" : @"false"] ]]></template>
  <template key="tojson.string">
    <![CDATA[ [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:(#name)]; [(#arg) appendString:QUOTATION_S] ]]></template>
  <template key="tojson.struct"><![CDATA[ [(#name) writeJSON:(#arg)] ]]></template>
  <template key="tojson.vec.for"><![CDATA[
    NSUInteger (#namer)Size = ((#null) == (#name) ? 0 : [(#name) count]);
    if ((#namer)Size > 0) {
    (#tab)[(#arg) appendString:LINE_FEED_S]; [(#arg) appendString:LEFT_SQUARE_S];
    (#tab)int (#namer)Idx = 0;
    (#tab)for (id (#value) in (#name)) {/* vec.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { [(#arg) appendString:COMMA_S]; }
    (#tab)}
    (#tab)[(#arg) appendString:RIGHT_SQUARE_S];
    }
  ]]></template>
  <template key="tojson.map.head.k"><![CDATA[ ]]></template>
  <template key="tojson.map.head.v"><![CDATA[
    (#typel) *(#name) = [(#nameupper2) objectForKey:(#key)];/*map.head.v*/(#brk) ]]></template>
  <template key="tojson.map.for"><![CDATA[
    NSUInteger (#namer)Size = ((#null) == (#name) ? 0 : [(#name) count]);
    if ((#namer)Size > 0) {
    (#tab)[(#arg) appendString:LINE_FEED_S]; [(#arg) appendString:LEFT_CURLY_S];
    (#tab)int (#namer)Idx = 0;
    (#tab)for (id (#key) in (#name)) { /* map.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { [(#arg) appendString:COMMA_S]; }
    (#tab)}
    (#tab)[(#arg) appendString:RIGHT_CURLY_S];
    }
  ]]></template>
  <template key="tojson.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tojson.nest.k"><![CDATA[
    [(#arg) appendString:QUOTATION_S]; (#body);
    [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:COLON_S]; /* nest.k */ ]]></template>
  <template key="tojson.nest.k.string"><![CDATA[
    (#body); [(#arg) appendString:COLON_S]; /* nest.k.string */ ]]></template>
  <template key="tojson.nest.v"><![CDATA[
    id (#name) = [(#nameupper2) objectForKey:(#key)];
    (#body); /* nest.v */ ]]></template>

  <template key="tojson.ref.any"><![CDATA[
    [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:@"(#namer)"]; [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:COLON_S];
    comma = COMMA_S; [(#arg) appendFormat:FORMAT_S, @((#name))]; ]]></template>
  <template key="tojson.ref.bool"><![CDATA[
    [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:@"(#namer)"]; [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:COLON_S];
    comma = COMMA_S; [(#arg) appendString:(#name) ? @"true" : @"false"]; ]]></template>
  <template key="tojson.ref.string | tojson.ref.struct |
                 tojson.ptr.string | tojson.ptr.struct"><![CDATA[
    if ((#namer)Exists) {
    (#tab)[(#arg) appendString:QUOTATION_S]; [(#arg) appendString:@"(#namer)"]; [(#arg) appendString:QUOTATION_S];
    (#tab)[(#arg) appendString:COLON_S]; (#body); comma = COMMA_S;
    }
  ]]></template>
  <template key="tojson.ref.vec | tojson.ref.map"><![CDATA[
    if ((#namer)Exists) {
    (#tab)[(#arg) appendString:QUOTATION_S]; [(#arg) appendString:@"(#namer)"];
    (#tab)[(#arg) appendString:QUOTATION_S]; [(#arg) appendString:COLON_S]; comma = COMMA_S; }
    (#body) ]]></template>
  <template key="tojson.ptr.vec | tojson.ptr.map |
                 tojson.ref.vec | tojson.ref.map"><![CDATA[
    if ((#namer)Exists) {
    (#tab)[(#arg) appendString:QUOTATION_S]; [(#arg) appendString:@"(#namer)"]; [(#arg) appendString:QUOTATION_S]; [(#arg) appendString:COLON_S];
    (#bodyindent) comma = COMMA_S;
    }
  ]]></template>
  <template key="tojson.field.head.string"><![CDATA[
    BOOL (#namer)Exists = ((#name) && [(#name) length] > 0);
  ]]></template>
  <template key="tojson.field.head.struct"><![CDATA[
    BOOL (#namer)Exists = ((#null) != (#name));
  ]]></template>
  <template key="tojson.field.head.vec | tojson.field.head.map"><![CDATA[
    BOOL (#namer)Exists = ((#null) != (#name) && [(#name) count] > 0);
  ]]></template>
  <template key="tojson.field.space.any"><![CDATA[
    if (comma) { [(#arg) appendString:comma]; comma = (#null); }
  ]]></template>
  <template key="tojson.field.space.string | tojson.field.space.vec |
                 tojson.field.space.struct | tojson.field.space.map"><![CDATA[
    if (comma && (#namer)Exists) { [(#arg) appendString:comma]; comma = (#null); }
  ]]></template>


  <!-- Write InvarRuntime file -->
  <template key="runtime.file"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.pack"><![CDATA[ ]]></template>
  <template key="runtime.name"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.body"><![CDATA[
    (#concat-all)
    #import "InvarRuntime.h"
    (#blank)
    @implementation InvarRuntime
    (#blank)
    + (instancetype) shared
    {
    (#tab)static id sharedInstance = nil;
    (#tab)static dispatch_once_t predicate;
    (#tab)dispatch_once(&predicate, ^{
    (#tab)(#tab)sharedInstance = [[self alloc] init];
    (#tab)});
    (#tab)return sharedInstance;
    }
    (#blank)
    - (instancetype) init
    {
    (#tab)self = [super init];
    (#tab)if (!self) { return self; }
    (#tab)_blockRecvRequest = ^(id req, id resp) {
    (#tab)(#tab)NSLog(@"Unhandled request: No function named 'Handle%@'.", [req class]);
    (#tab)(#tab)[resp setProtocError:INVAR_ERR_PROTOC_NO_HANDLER];
    (#tab)};
    (#tab)_blockRecvResponse = ^(id resp) {
    (#tab)(#tab)NSLog(@"Unhandled response: No function named 'Handle%@'.", [resp class]);
    (#tab)};
    (#tab)_blockRecvNotify = ^(id ntf) {
    (#tab)(#tab)NSLog(@"Unhandled notify: No function named 'Handle%@'.", [ntf class]);
    (#tab)};
    (#tab)_blockHandleError = ^(NSInteger code, NSInteger protoc) {
    (#tab)(#tab)NSLog(@"Error when handle protocol %@, the error code is %@", @(protoc), @(code));
    (#tab)};
    (#tab)return self;
    }
    (#body)
    @end
  ]]></template>
  <template key="runtime.protoc.handle.client"><![CDATA[ HandleProtocAsServer ]]></template>
  <template key="runtime.protoc.handle.server"><![CDATA[ HandleProtocAsClient ]]></template>
  <template key="runtime.protoc.handle.notify"><![CDATA[ (#blank)
    (#tab)(#space)case (#key): /* (#doc) */ {
    (#tab)(#tab)id (#name) = [[(#type) alloc] init];
    (#tab)(#tab)if (INVAR_ERR_NONE == (code = [(#name) read:r])) { Handle(#type)((#name)); }
    (#tab)(#tab)break; } ]]></template>
  <template key="runtime.protoc.handle.response"><![CDATA[ (#blank)
    (#tab)(#space)case (#key): /* (#doc) */ {
    (#tab)(#tab)id (#name) = resp = [[(#type) alloc] init];
    (#tab)(#tab)if (INVAR_ERR_NONE == (code = [(#name) read:r])) { Handle(#type)((#name)); }
    (#tab)(#tab)break; } ]]></template>
  <template key="runtime.protoc.handle.request"><![CDATA[ (#blank)
    (#tab)(#space)case (#key): /* (#doc) */ {
    (#tab)(#tab)id (#name) = [[(#type) alloc] init]; resp = [[(#resp) alloc] init];
    (#tab)(#tab)if (INVAR_ERR_NONE == (code = [(#name) read:r])) { Handle(#req)((#name), resp); }
    (#tab)(#tab)break; } ]]></template>
  <template key="runtime.protoc.handle.method"><![CDATA[
    (#blank)
    + (id<ProtocResponse>)(#name):(DataReader * const)r Protoc:(uint16_t *)p Error:(uint16_t *)e
    {
    (#tab)BOOL eof = NO; id<ProtocResponse> resp = nil;
    (#tab)NSInteger code = INVAR_ERR_PROTOC_UNHANDLED;
    (#tab)uint16_t request = [r peekUInt16:&eof];
    (#tab)if (eof) { code = INVAR_ERR_DECODE_EOF; goto error; }
    (#tab)[r rewind];
    (#tab)switch (request) {(#body)
    (#tab)(#space)default: { code = INVAR_ERR_PROTOC_NO_HANDLER; break; }
    (#tab)}
    error:
    (#tab)if (INVAR_ERR_NONE != code && [[[self class] shared] blockHandleError]) {
    (#tab)(#tab)[[[self class] shared] blockHandleError](code, request);
    (#tab)}
    (#tab)*p = request;
    (#tab)*e = code;
    (#tab)return resp;
    }
    /* (#name) */
  ]]></template>


</tns:root>