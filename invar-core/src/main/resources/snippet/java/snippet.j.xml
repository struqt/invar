<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="java"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <export resPath="java/lib/InvarRule.java" destDir="invar/lib" destName="InvarRule.java"/>
  <export resPath="java/lib/InvarEnum.java" destDir="invar/lib" destName="InvarEnum.java"/>
  <export resPath="java/lib/InvarCodec.java" destDir="invar/lib" destName="InvarCodec.java"/>
  <export resPath="java/lib/InvarSQL.java" destDir="invar/lib" destName="InvarSQL.java"/>
  <export resPath="java/lib/InvarMySQL.java" destDir="invar/lib" destName="InvarMySQL.java"/>
  <export resPath="java/lib/InvarReadData.java" destDir="invar/lib" destName="InvarReadData.java"/>
  <export resPath="java/lib/RecvRequest.java" destDir="invar/lib" destName="RecvRequest.java"/>
  <export resPath="java/lib/RecvResponse.java" destDir="invar/lib" destName="RecvResponse.java"/>
  <export resPath="java/lib/RecvNotify.java" destDir="invar/lib" destName="RecvNotify.java"/>
  <export resPath="java/lib/RecvContext.java" destDir="invar/lib" destName="RecvContext.java"/>
  <export resPath="java/lib/CodecError.java" destDir="invar/lib" destName="CodecError.java"/>

  <!-- Redefine 14 Invar buildin types to adapt Java language -->
  <!-- & &amp; < &lt; > &gt; " &quot; ' &apos; -->
  <redefine>
    <int8 pack="   java.lang" type="Byte         " initValue="-1"/>
    <int16 pack="  java.lang" type="Short        " initValue="-1"/>
    <int32 pack="  java.lang" type="Integer      " initValue="-1"/>
    <int64 pack="  java.lang" type="Long         " initValue="-1"/>
    <uint8 pack="  java.lang" type="Integer      " initValue="0"/>
    <uint16 pack=" java.lang" type="Integer      " initValue="0"/>
    <uint32 pack=" java.lang" type="Long         " initValue="0"/>
    <uint64 pack=" java.math" type="BigInteger   " initValue="0"/>
    <float pack="  java.lang" type="Float        " initValue="0.0"/>
    <double pack=" java.lang" type="Double       " initValue="0.00"/>
    <string pack=" java.lang" type="String       " initValue=""/>
    <bool pack="   java.lang" type="Boolean      " initValue="false"/>
    <vec pack="    java.util" type="LinkedList   " generic="&lt;?&gt;"/>
    <map pack="    java.util" type="LinkedHashMap" generic="&lt;?,?&gt;"/>

    <dialect pack="invar.lib" type="CodecError"/>
    <dialect pack="java.io" type="IOException"/>
    <dialect pack="java.io" type="InputStream"/>
    <dialect pack="java.io" type="DataInput"/>
    <dialect pack="java.io" type="DataInputStream"/>
    <dialect pack="java.io" type="OutputStream"/>
    <dialect pack="java.io" type="DataOutput"/>
    <dialect pack="java.io" type="DataOutputStream"/>

    <dialect pack="java.util" type="Map"/>
    <dialect pack="java.util" type="Set"/>
    <dialect pack="java.util" type="List"/>
    <dialect pack="java.util" type="ArrayList"/>
    <dialect pack="java.util" type="HashSet"/>
    <dialect pack="java.util" type="Iterator"/>
    <dialect pack="java.util" type="Collections"/>

    <dialect pack="java.sql" type="Timestamp"/>

  </redefine>

  <!-- Settings -->
  <template key="trace.all.types">         <![CDATA[ false ]]></template>
  <template key="include.self">            <![CDATA[ false ]]></template>
  <template key="pack.name.nested">        <![CDATA[ false ]]></template>
  <template key="file.name.lowercase">     <![CDATA[ false ]]></template>
  <template key="capitalize.pack.head">    <![CDATA[ false ]]></template>
  <template key="method.indent.num">       <![CDATA[ 1     ]]></template>
  <template key="one.pack.one.file">       <![CDATA[ false ]]></template>
  <template key="code.dir.flatten">        <![CDATA[ false ]]></template>
  <template key="code.dir.prefix">         <![CDATA[ ]]></template>

  <!-- Common snippet -->
  <template key="refer.spec">    <![CDATA[ & ]]></template>
  <template key="refer.invoke">  <![CDATA[ . ]]></template>
  <template key="refer.copy">    <![CDATA[ (#name) = (#arg); ]]></template>
  <template key="refer.const">   <![CDATA[ const ]]></template>
  <template key="pointer.spec">  <![CDATA[ *    ]]></template>
  <template key="pointer.invoke"><![CDATA[ ->   ]]></template>
  <template key="pointer.null">  <![CDATA[ null ]]></template>
  <template key="pointer.copy">  <![CDATA[ (#name) = (#arg); ]]></template>
  <template key="byte.yes">      <![CDATA[ (byte)0x01 ]]></template>
  <template key="byte.non">      <![CDATA[ (byte)0x00 ]]></template>
  <template key="struct.const.name.crc"><![CDATA[ CRC32 ]]></template>

  <template key="init.any">    <![CDATA[ (#deft)         ]]></template>
  <template key="init.int64">  <![CDATA[ (#deft)L        ]]></template>
  <template key="init.uint32"> <![CDATA[ (#deft)L        ]]></template>
  <template key="init.float">  <![CDATA[ (#deft)F        ]]></template>
  <template key="init.string"> <![CDATA[ "(#deft)"       ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name) ]]></template>
  <template key="init.struct"> <![CDATA[ (#type).Create()]]></template>
  <template key="init.vec">    <![CDATA[ new (#type)()   ]]></template>
  <template key="init.map">    <![CDATA[ new (#type)()   ]]></template>
  <template key="init.uint64"> <![CDATA[ BigInteger.valueOf(0L) ]]></template>
  <template key="init.protocCRC"><![CDATA[ (#deft)       ]]></template>

  <template key="import.exclude.conflict"> <![CDATA[ true ]]></template>
  <template key="import.exclude.same.pack"><![CDATA[ true ]]></template>
  <template key="import.exclude.packs">    <![CDATA[ java.lang ]]></template>
  <template key="import">      <![CDATA[ import (#body);(#brk) ]]></template>
  <template key="import.body"> <![CDATA[ (#pack)(#name) ]]></template>
  <template key="import.split"><![CDATA[ . ]]></template>

  <template key="doc">     <![CDATA[ /** (#doc) */ ]]></template>
  <template key="doc.line"><![CDATA[ /* (#doc) */ ]]></template>

  <template key="file.head"><![CDATA[
	/*===----------------------------*  Java 6  *------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===*/
  ]]></template>
  <template key="file"><![CDATA[
    (#head)(#pack)
  ]]></template>
  <template key="file.pack"><![CDATA[
	  package (#name);
	  (#body)
  ]]></template>
  <template key="file.body"><![CDATA[
    (#blank)
    (#import)
    (#blank)
    (#enums)(#structs)]]></template>
  <template key="enum.field"><![CDATA[
    (#brk)(#tab)(#doc)
    (#tab)(#name) ((#value)), ]]></template>
  <template key="enum"><![CDATA[
    import invar.lib.InvarEnum;
    (#blank)
    (#doc)
    public enum (#name) implements InvarEnum
    {(#body);
    (#blank)
    (#tab)public Integer value() { return value; }
    (#tab)public String  toString() { return name() + "(" + value + ")"; }
    (#blank)
    (#tab)private Integer value;
    (#blank)
    (#tab)(#name)(Integer v)
    (#tab){
    (#tab)(#tab)this.value = v;
    (#tab)}
    (#blank)
    (#tab)static public (#name) valueOf(Integer v)
    (#tab){
    (#tab)(#tab)(#name)[] es = (#name).values();
    (#tab)(#tab)for ((#name) e : es) {
    (#tab)(#tab)(#tab)if(e.value().equals(v)) {
    (#tab)(#tab)(#tab)(#tab)return e;
    (#tab)(#tab)(#tab)}
    (#tab)(#tab)}
    (#tab)(#tab)return es[0];
    (#tab)}
    }
  ]]></template>
  <template key="struct.protoc.ntf"><![CDATA[
    (#brk)invar.lib.InvarCodec.ProtocNotify, ]]></template>
  <template key="struct.protoc.req"><![CDATA[
    (#brk)invar.lib.InvarCodec.ProtocRequest, ]]></template>
  <template key="struct.protoc.resp"><![CDATA[
    (#brk)invar.lib.InvarCodec.ProtocResponse, ]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; java.io::IOException)]
    [#addImport(struct; imports; java.io::InputStream)]
    [#addImport(struct; imports; java.io::DataInput)]
    [#addImport(struct; imports; java.io::DataInputStream)]
    [#addImport(struct; imports; java.io::OutputStream)]
    [#addImport(struct; imports; java.io::DataOutput)]
    [#addImport(struct; imports; java.io::DataOutputStream)]
    [#addImport(struct; imports; invar.lib::CodecError)]
    (#doc)
    public final class (#name)
    implements(#protoc-type)
    invar.lib.InvarCodec.BinaryDecode,
    invar.lib.InvarCodec.BinaryEncode,
    invar.lib.InvarCodec.XMLEncode
    {
    (#tab)static public final long CRC32 = 0x[#codeCRC32(struct)]L;
    (#blank)
    (#tab)static public (#name) Create()
    (#tab){
    (#tab)(#tab)return new (#name)();
    (#tab)}
    (#blank)
    [#codeFields (struct; fields)]
    [#codeNested (ctor.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (reuse.; useFullName; struct; fields; imports)](#brk)

    [#codeNested (getter.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (setter.; useFullName; struct; fields; imports)](#brk)

    [#codeNested (copy.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (write.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (tostr.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (tojson.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.;  useFullName; struct; fields; imports)](#brk)

    [#codeNested (sql.params.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (sql.start.;    useFullName; struct; fields; imports)](#brk)
    [#codeNested (sql.writable.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (sql.alias.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (sql.end.;     useFullName; struct; fields; imports)](#brk)

    }
	]]></template>
  <template key="struct.meta">
    <![CDATA[@invar.lib.InvarRule(T="(#type)", S="f(#index)")]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#clampLen(lenFieldName; 16; (#namer) )];
    (#concat)[#codeLineDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#typeupper) set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; return this; }
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#type) get[#upperHeadChar( (#name) )]() { return (#name); }
  ]]></template>

  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    (#tab)public (#type)()
    (#tab){(#body)
    (#tab)}
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#null); ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body); ]]></template>

  <!-- Method Reuse -->
  <template key="reuse.method"><![CDATA[
    (#tab)public (#type) reuse()
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)}
  ]]></template>
  <template key="reuse.any">   <![CDATA[ (#name) = (#deft) ]]></template>
  <template key="reuse.struct"><![CDATA[ (#name).reuse() ]]></template>
  <template key="reuse.vec | reuse.map"><![CDATA[ (#name).clear() ]]></template>
  <template key="reuse.ref.any"><![CDATA[ (#body); ]]></template>
  <template key="reuse.ptr.any"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#name) = (#deft);
    }]]></template>
  <template key="reuse.ptr.struct | reuse.ptr.vec | reuse.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#body);
    }]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[from]]></template>
  <template key="copy.method"><![CDATA[
    (#tab)/** Shallow copy */
    (#tab)public (#type) copy((#type) from)
    (#tab){
      (#tab)(#tab)if (this == from || from == (#null)) {
      (#tab)(#tab)(#tab)return this;
      (#tab)(#tab)}(#body)
      (#tab)(#tab)return this;
    (#tab)} /* copyFrom(...) */ ]]></template>
  <template key="copy.any"><![CDATA[ (#arg)(#split)(#name) ]]></template>
  <template key="copy.vec">
    <![CDATA[ (#name).addAll((#arg)(#split)(#name)) ]]></template>
  <template key="copy.map">
    <![CDATA[ (#name).putAll((#arg)(#split)(#name)) ]]></template>
  <template key="copy.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="copy.ref.vec|copy.ref.map"><![CDATA[ (#name).clear();
    (#body); ]]></template>
  <template key="copy.ptr.any"><![CDATA[ (#name) = (#body);  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if ((#arg).(#name) != (#null)) {
    (#tab)(#name).copy((#body));
    } else {
    (#tab)(#name) = (#null);
    }
  ]]></template>
  <template key="copy.ptr.vec|copy.ptr.map"><![CDATA[
    if (null == (#arg).(#name)) {
    (#tab)(#name) = (#null);
    } else {
    (#tab)if ((#null) == (#name)) { (#name) = new (#type)(); }
    (#tab)else { (#name).clear(); }(#bodyindent);
    }
  ]]></template>

  <!-- Getters -->
  <template key="getter.indent.num"><![CDATA[ 0 ]]></template>
  <template key="getter.import"><![CDATA[ ]]></template>
  <template key="getter.method.arg"><![CDATA[ ]]></template>
  <template key="getter.method"><![CDATA[ (#body) ]]></template>
  <template key="getter.ptr.any | getter.ref.any"><![CDATA[
    (#blank)
    [#codeDoc(fields; (#index))]
    [#codeMetaData(fields; (#index))]
    (#body)
  ]]></template>
  <template key="getter.any | getter.vec | getter.map"><![CDATA[
    public (#type) get[#upperHeadChar( (#name) )]() { return (#name); } ]]></template>
  <template key="getter.enum"><![CDATA[
    public (#type) get[#upperHeadChar( (#name) )]() { return (#name); }
    public Integer get[#upperHeadChar( (#name) )]V() { return (#name).value(); }
  ]]></template>

  <!-- Setters -->
  <template key="setter.indent.num"><![CDATA[ 0 ]]></template>
  <template key="setter.import"><![CDATA[ ]]></template>
  <template key="setter.method.arg"><![CDATA[ ]]></template>
  <template key="setter.method"><![CDATA[ (#body) ]]></template>
  <template key="setter.ptr.any | setter.ref.any"><![CDATA[
    (#blank)
    [#codeDoc(fields; (#index))]
    [#codeMetaData(fields; (#index))]
    (#body)
  ]]></template>
  <template key="setter.any | setter.vec | setter.map"><![CDATA[
    public void set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; } ]]></template>
  <template key="setter.int8"><![CDATA[
    public void set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; }
    (#blank)
    public void set[#upperHeadChar( (#name) )](int value) throws NumberFormatException
    {
    (#tab)if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {
    (#tab)(#tab)throw new NumberFormatException("int8 value out of range: " + value);
    (#tab)}
    (#tab)this.(#name) = Integer.valueOf(value).byteValue();
    }
  ]]></template>
  <template key="setter.int16"><![CDATA[
    public void set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; }
    (#blank)
    public void set[#upperHeadChar( (#name) )](int value) throws NumberFormatException
    {
    (#tab)if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
    (#tab)(#tab)throw new NumberFormatException("int16 value out of range: " + value);
    (#tab)}
    (#tab)this.(#name) = Integer.valueOf(value).shortValue();
    }
  ]]></template>
  <template key="setter.uint8"><![CDATA[
    public void set[#upperHeadChar( (#name) )](int value) throws NumberFormatException
    {
    (#tab)if (value < 0 || value > 0xFF) {
    (#tab)(#tab)throw new NumberFormatException("uint8 value out of range: " + value);
    (#tab)}
    (#tab)this.(#name) = value;
    }
  ]]></template>
  <template key="setter.uint16"><![CDATA[
    public void set[#upperHeadChar( (#name) )](int value) throws NumberFormatException
    {
    (#tab)if (value < 0 || value > 0xFFFF) {
    (#tab)(#tab)throw new NumberFormatException("uint16 value out of range: " + value);
    (#tab)}
    (#tab)this.(#name) = value;
    }
  ]]></template>
  <template key="setter.uint32"><![CDATA[
    public void set[#upperHeadChar( (#name) )](long value) throws NumberFormatException
    {
    (#tab)if (value < 0 || value > 0xFFFFFFFFL) {
    (#tab)(#tab)throw new NumberFormatException("uint32 value out of range: " + value);
    (#tab)}
    (#tab)this.(#name) = value;
    }
  ]]></template>
  <template key="setter.enum"><![CDATA[
    public void set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; }
    public void set[#upperHeadChar( (#name) )]V(Integer value) { this.(#name) = (#type).valueOf(value); }
  ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[  ]]></template>
  <template key="read.method.arg"><![CDATA[from]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public void read(InputStream from) throws IOException, CodecError
    (#tab){
    (#tab)(#tab)this.read((DataInput)new DataInputStream(from));
    (#tab)}
    (#blank)
    (#tab)public void read(DataInput from) throws IOException, CodecError
    (#tab){(#body)
    (#tab)}]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).readByte()    ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).readShort()   ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).readInt()     ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).readLong()    ]]></template>
  <template key="read.uint8">
    <![CDATA[ (#arg).readUnsignedByte()  ]]></template>
  <template key="read.uint16">
    <![CDATA[ (#arg).readUnsignedShort() ]]></template>
  <template key="read.uint32">
    <![CDATA[ (#arg).readInt() & 0xFFFFFFFFL ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).readXXX()    ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).readFloat()   ]]></template>
  <template key="read.double"><![CDATA[ (#arg).readDouble()  ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).readBoolean() ]]></template>
  <template key="read.enum">  <![CDATA[ (#type).valueOf((#arg).readInt()) ]]></template>
  <template key="read.string"><![CDATA[ (#arg).readUTF()     ]]></template>
  <template key="read.struct"><![CDATA[ (#name).read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) (#name) = (#type).Create();(#brk)(#body); ]]></template>
  <template key="read.nest.n.uint64|read.nest.k.uint64|read.nest.v.uint64"><![CDATA[
    byte[] (#name)Bytes = new byte[8]; from.readFully((#name)Bytes, 0, 8);
    (#type) (#name) = new (#type)(1, (#namer)Bytes); ]]></template>

  <template key="read.vec.head"><![CDATA[(#type) (#name) = new (#type)(); //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    Long (#len) = (#arg).readInt() & 0xFFFFFFFFL;
    for ((#sizetype) (#index) = 0L; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name).add((#value));
    }
  ]]></template>
  <template key="read.map.head"><![CDATA[(#type) (#name) = new (#type)(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    Long (#len) = (#arg).readInt() & 0xFFFFFFFFL;
    for ((#sizetype) (#index) = 0L; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name).put((#key),(#value));
    }
  ]]></template>
  <template key="read.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec"><![CDATA[ (#name).clear();(#brk)(#body) ]]></template>
  <template key="read.ref.map"><![CDATA[ (#name).clear();(#brk)(#body) ]]></template>
  <template key="read.ref.uint64"><![CDATA[
    byte[] (#namer)Bytes = new byte[8]; from.readFully((#namer)Bytes, 0, 8);
    (#name) = new (#type)(1, (#namer)Bytes);
  ]]></template>

  <template key="read.ptr.string"><![CDATA[
    byte (#namer)Exists = (#arg).readByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new CodecError(CodecError.ERR_DECODE_STRING_P); }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    byte (#namer)Exists = (#arg).readByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = (#type).Create(); }
    (#tab)(#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new CodecError(CodecError.ERR_DECODE_STRUCT_P); }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    byte (#namer)Exists = (#arg).readByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = new (#type)(); }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new CodecError(CodecError.ERR_DECODE_VEC_MAP_P); }
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#brk)if (CRC32 != (#name)) { throw new CodecError(CodecError.ERR_PROTOC_CRC_MISMATCH); }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) {
    (#tab)throw new CodecError((#name));
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import">
    <![CDATA[ java.io::DataOutputStream, java.io::DataOutput, java.io::IOException ]]></template>
  <template key="write.method.arg"><![CDATA[ dest ]]></template>
  <template key="write.method"><![CDATA[
    (#tab)public void write(OutputStream from) throws IOException
    (#tab){
    (#tab)(#tab)this.write((DataOutput)new DataOutputStream(from));
    (#tab)}
    (#blank)
    (#tab)public void write(DataOutput dest) throws IOException
    (#tab){(#body)
    (#tab)}]]></template>
  <template key="write.int8"><![CDATA[  (#arg).writeByte((#name))  ]]></template>
  <template key="write.int16"><![CDATA[ (#arg).writeShort((#name)) ]]></template>
  <template key="write.int32"><![CDATA[ (#arg).writeInt((#name))   ]]></template>
  <template key="write.int64"><![CDATA[ (#arg).writeLong((#name))  ]]></template>
  <template key="write.uint8"><![CDATA[ (#arg).writeByte((#name))  ]]></template>
  <template key="write.uint16"><![CDATA[ (#arg).writeShort((#name)) ]]></template>
  <template key="write.uint32"><![CDATA[ (#arg).writeInt((#name).intValue()) ]]></template>
  <template key="write.uint64"><![CDATA[ (#arg).writeLong((#name).longValue())  ]]></template>
  <template key="write.float"><![CDATA[  (#arg).writeFloat((#name)) ]]></template>
  <template key="write.double"><![CDATA[ (#arg).writeDouble((#name))]]></template>
  <template key="write.string"><![CDATA[ (#arg).writeUTF((#name))   ]]></template>
  <template key="write.bool"><![CDATA[   (#arg).writeBoolean((#name)) ]]></template>
  <template key="write.enum"><![CDATA[   (#arg).writeInt((#name).value()) ]]></template>
  <template key="write.struct"><![CDATA[ (#name).write((#arg)) ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body);]]></template>
  <template key="write.nest.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)(#body);]]></template>
  <template key="write.nest.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)(#body);]]></template>
  <template key="write.vec.head"><![CDATA[]]></template>
  <template key="write.vec.for"><![CDATA[
    (#arg).writeInt((#name).size());
    for ((#typer) (#value) : (#name)) {(#body)
    } ]]></template>
  <template key="write.map.head.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)]]></template>
  <template key="write.map.head.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)]]></template>
  <template key="write.map.for"><![CDATA[
    (#arg).writeInt((#name).size());
    for (Map.Entry<(#typer)> (#name)Iter : (#name).entrySet()) {(#body)
    }[#addImport(struct; imports; java.util::Map)] ]]></template>
  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).writeByte((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).writeByte((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).writeByte((#byteyes));(#bodyindent)
    } else {
    (#tab)(#arg).writeByte((#bytenon));
    }
  ]]></template>


  <!-- To XML String -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method.arg"><![CDATA[ nodes ]]></template>
  <template key="toxml.method"><![CDATA[
    (#tab)public String toStringXML()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)this.writeXML(code, "(#type)");
    (#tab)(#tab)return code.toString();
    (#tab)}
    (#blank)
    (#tab)public void writeXML(StringBuilder result, String name)
    (#tab){
    (#tab)(#tab)StringBuilder attrs  = new StringBuilder();
    (#tab)(#tab)StringBuilder (#arg) = new StringBuilder();(#body)
    (#tab)(#tab)result.append('<').append(name).append(attrs);
    (#tab)(#tab)if ((#arg).length() == 0) {
    (#tab)(#tab)(#tab)result.append('/').append('>');
    (#tab)(#tab)} else {
    (#tab)(#tab)(#tab)result.append('>').append((#arg));
    (#tab)(#tab)(#tab)result.append('<').append('/').append(name).append('>');
    (#tab)(#tab)}
    (#tab)} /* (#type)::writeXML(...) */ ]]></template>
  <template key="toxml.any">   <![CDATA[ (#name).toString() ]]></template>
  <template key="toxml.string"><![CDATA[ (#name) ]]></template>
  <template key="toxml.struct"><![CDATA[
    (#name).writeXML((#arg), "(#name)")]]></template>
  <template key="toxml.nest.n.struct"><![CDATA[
    (#body); ]]></template>
  <template key="toxml.nest.k.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();
    (#body); ]]></template>
  <template key="toxml.nest.v.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();
    (#body); ]]></template>
  <template key="toxml.nest.n"><![CDATA[
    (#arg).append('<').append("(#name)").append(' ').append("value").append('=').append('"');
    (#arg).append((#body)).append('"').append('>'); ]]></template>
  <template key="toxml.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();
    (#arg).append('<').append("(#name)").append(' ').append("value").append('=').append('"');
    (#arg).append((#body)).append('"').append('>'); ]]></template>
  <template key="toxml.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();
    (#arg).append('<').append("(#name)").append(' ').append("value").append('=').append('"');
    (#arg).append((#body)).append('"').append('>'); ]]></template>
  <template key="toxml.vec.head"><![CDATA[]]></template>
  <template key="toxml.vec.for"><![CDATA[
    (#arg).append('<').append("(#name)").append('>');
    for ((#typer) (#value) : (#name)) {(#body)
    }
    (#arg).append('<').append('/').append("(#name)").append('>');
  ]]></template>
  <template key="toxml.map.head.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)]]></template>
  <template key="toxml.map.head.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)]]></template>
  <template key="toxml.map.for"><![CDATA[
    (#arg).append('<').append("(#name)").append('>');
    for (Map.Entry<(#typer)> (#name)Iter : (#name).entrySet()) {(#body)
    }[#addImport(struct; imports; java.util::Map)]
    (#arg).append('<').append('/').append("(#name)").append('>');
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[
    attrs.append(' ').append("(#name)").append('=').append('"');
    attrs.append((#body)).append('"'); ]]></template>
  <template key="toxml.ref.struct">
    <![CDATA[ (#body); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if ((#name).size() > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)attrs.append(' ').append("(#name)").append('=').append('"');
    (#tab)attrs.append((#body)).append('"');
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if ((#name) != (#null) && (#name).size() > 0) {(#bodyindent)
    }]]></template>


  <!-- To String -->
  <template key="tostr.import"><![CDATA[]]></template>
  <template key="tostr.method.arg"><![CDATA[ s ]]></template>
  <template key="tostr.method"><![CDATA[ (#tab)public String toString()
    (#tab){
    (#tab)(#tab)StringBuilder (#arg) = new StringBuilder();
    (#tab)(#tab)(#arg).append('{');
    (#tab)(#tab)(#arg).append(getClass().getName());(#body)
    (#tab)(#tab)(#arg).append('}');
    (#tab)(#tab)return (#arg).toString();
    (#tab)} //(#type)::toString () ]]></template>
  <template key="tostr.any"><![CDATA[ (#arg).append((#name).toString()) ]]></template>
  <template key="tostr.struct"><![CDATA[
    (#arg).append('<').append("(#type)").append('>') ]]></template>
  <template key="tostr.vec"><![CDATA[
    (#arg).append('(').append((#name).size()).append(')') ]]></template>
  <template key="tostr.map"><![CDATA[
    (#arg).append('[').append((#name).size()).append(']') ]]></template>
  <template key="tostr.string"><![CDATA[
    (#arg).append('"').append((#name)).append('"') ]]></template>
  <template key="tostr.ref.any"><![CDATA[
    (#arg).append(',').append("(#name)").append(':');
    (#body); ]]></template>
  <template key="tostr.ptr.any"><![CDATA[ (#arg).append(", (#name):");
    if ((#name) != (#null)) {
      (#tab)(#body);
    } else {
      (#tab)(#arg).append("null");
    } ]]></template>


  <!-- Write data to JSON data format -->
  <template key="tojson.import">
    <![CDATA[ System.Text::StringBuilder ]]></template>
  <template key="tojson.method.arg">  <![CDATA[ s ]]></template>
  <template key="tojson.method"><![CDATA[
    (#tab)public String toStringJSON()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)this.writeJSON(code);
    (#tab)(#tab)return code.toString();
    (#tab)}(#brk)
    (#tab)public void writeJSON(StringBuilder s)
    (#tab){
    (#tab)(#tab)s.append('{');
    (#tab)(#tab)char comma = '\\0';(#body)
    (#tab)(#tab)s.append('}');
    (#tab)} /* (#type)::writeJSON(...) */ ]]></template>
  <template key="tojson.any"><![CDATA[ (#arg).append((#name).toString()) ]]></template>
  <template key="tojson.enum"><![CDATA[ (#arg).append((#name).value()) ]]></template>
  <template key="tojson.bool"><![CDATA[
    (#arg).append((#name).toString().toLowerCase()) ]]></template>
  <template key="tojson.string"><![CDATA[
    (#arg).append('"').append((#name).toString()).append('"') ]]></template>
  <template key="tojson.struct"><![CDATA[ (#name).writeJSON((#arg)) ]]></template>
  <template key="tojson.vec.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).size());
    if ((#namer)Size > 0) {
    (#tab)(#arg).append('[');
    (#tab)int (#namer)Idx = 0;
    (#tab)for ((#typer) (#value) : (#name)) { /* vec.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).append(','); }
    (#tab)}
    (#tab)(#arg).append(']');
    }
  ]]></template>
  <template key="tojson.map.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).size());
    if ((#namer)Size > 0) {
    (#tab)(#arg).append('{');
    (#tab)int (#namer)Idx = 0;
    (#tab)for (Map.Entry<(#typer)> (#namer)Iter : (#name).entrySet()) { /* map.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).append(','); }
    (#tab)}
    (#tab)(#arg).append('}');
    }
  ]]></template>
  <template key="tojson.map.head.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.getKey();(#brk)]]></template>
  <template key="tojson.map.head.v"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.getValue();(#brk)]]></template>
  <template key="tojson.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tojson.nest.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.getKey(); /* nest.k */
    (#arg).append('"'); (#body); (#arg).append('"').append(':'); ]]></template>
  <template key="tojson.nest.k.string"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.getKey(); /* nest.k */
    (#body); (#arg).append(':'); ]]></template>
  <template key="tojson.nest.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue(); /* nest.v */(#brk)(#body); ]]></template>

  <template key="tojson.ref.any"><![CDATA[
    (#arg).append('"').append("(#namer)").append('"').append(':');
    (#body); comma = ','; ]]></template>
  <template key="tojson.ref.vec | tojson.ref.map"><![CDATA[
    if ((#namer)Exists) { (#arg).append('"').append("(#namer)").append('"').append(':'); comma = ','; }
    (#body) ]]></template>
  <template key="tojson.ref.string | tojson.ref.struct |
                 tojson.ptr.string | tojson.ptr.struct"><![CDATA[
    if ((#namer)Exists) {
    (#tab)(#arg).append('"').append("(#namer)").append('"').append(':'); comma = ','; (#body);
    }
  ]]></template>
  <template key="tojson.ptr.vec | tojson.ptr.map"><![CDATA[
    if ((#namer)Exists) {(#bodyindent) comma = ',';
    }
  ]]></template>
  <template key="tojson.field.head.string"><![CDATA[
    boolean (#namer)Exists = (#name) != null && (#name).length() > 0;
  ]]></template>
  <template key="tojson.field.head.struct"><![CDATA[
    boolean (#namer)Exists = (null != (#name));
  ]]></template>
  <template key="tojson.field.head.vec | tojson.field.head.map"><![CDATA[
    boolean (#namer)Exists = (null != (#name) && (#name).size() > 0);
  ]]></template>
  <template key="tojson.field.space.any"><![CDATA[
    if ('\\0' != comma) { (#arg).append(comma); comma = '\\0'; }
  ]]></template>
  <template key="tojson.field.space.string | tojson.field.space.vec |
                 tojson.field.space.struct | tojson.field.space.map"><![CDATA[
    if ('\\0' != comma && (#namer)Exists) { (#arg).append(comma); comma = '\\0'; }
  ]]></template>

  <!-- InvarRuntime Class -->
  <template key="runtime.pack"><![CDATA[ invar.lib ]]></template>
  <template key="runtime.name"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.type.split"><![CDATA[ . ]]></template>
  <template key="runtime.alias"><![CDATA[
    (#blank)
    (#tab)static private LinkedHashMap<String,Class<?>> (#name) ()
    (#tab){
    (#tab)(#tab)LinkedHashMap<String,Class<?>> map = new LinkedHashMap<String,Class<?>>();(#body)
    (#tab)(#tab)return map;
    (#tab)}
  ]]></template>
  <template key="runtime.alias.basic">
    <![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.list">
    <![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.map">
    <![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.body"><![CDATA[
    public final class InvarRuntime
    {
    (#blank)
    (#tab)static public <T> void parse(T root, java.io.InputStream input) throws Exception
    (#tab){
    (#tab)(#tab)InvarRuntime.MakeXmlReader().parse(root, input);
    (#tab)}
    (#blank)
    (#tab)static public InvarReadData MakeXmlReader()
    (#tab){
    (#tab)(#tab)if (InvarReadData.aliasBasics == null)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)InvarReadData.aliasBasics = aliasBasic();
    (#tab)(#tab)(#tab)InvarReadData.aliasEnums = aliasEnum();
    (#tab)(#tab)(#tab)InvarReadData.aliasStructs = aliasStruct();
    (#tab)(#tab)}
    (#tab)(#tab) return new InvarReadData();
    (#tab)}
    (#body)
    } ]]></template>
  <template key="runtime.protoc.handle.client"><![CDATA[ handleProtocAsServer ]]></template>
  <template key="runtime.protoc.handle.server"><![CDATA[ handleProtocAsClient ]]></template>
  <template key="runtime.protoc.handle.notify"><![CDATA[ (#blank)
    (#tab)(#tab)case (#key): /* (#doc) */
    (#tab)(#tab){(#type) (#name) = (#type).Create(); (#name).read(r); error = RecvNotify.recv(ctx, (#name));} break; ]]></template>
  <template key="runtime.protoc.handle.response"><![CDATA[ (#blank)
    (#tab)(#tab)case (#key): /* (#doc) */
    (#tab)(#tab){(#type) (#name) = (#type).Create(); (#name).read(r); error = RecvResponse.recv(ctx, (#name));} break; ]]></template>
  <template key="runtime.protoc.handle.request"><![CDATA[ (#blank)
    (#tab)(#tab)case (#key): /* (#doc) */ {
    (#tab)(#tab)(#type) (#name) = (#req).Create(); (#resp) resp = (#resp).Create();
    (#tab)(#tab)(#name).read(r); RecvRequest.recv(ctx, (#name), resp); sender.sendResponse(resp); error = 0;} break; ]]></template>
  <template key="runtime.protoc.handle.method"><![CDATA[
    (#blank)
    (#tab)static public <
    (#tab)(#tab)C extends RecvContext,
    (#tab)(#tab)S extends InvarCodec.ResponseSender>
    (#tab)void (#name)(int id, java.io.DataInput r, C ctx, S sender) throws CodecError
    (#tab){
    (#tab)(#tab)int error = CodecError.ERR_NONE;
    (#tab)(#tab)try {
    (#tab)(#tab)switch (id) {(#body)
    (#tab)(#tab)default: error = CodecError.ERR_PROTOC_INVALID_ID;
    (#tab)(#tab)}
    (#tab)(#tab)} catch (Throwable e) {
    (#tab)(#tab)(#tab)if (e instanceof CodecError) {
    (#tab)(#tab)(#tab)(#tab)throw (CodecError) e;
    (#tab)(#tab)(#tab)} else {
    (#tab)(#tab)(#tab)(#tab)throw new CodecError(CodecError.ERR_UNKNOWN, e);
    (#tab)(#tab)(#tab)}
    (#tab)(#tab)}
    (#tab)(#tab)if (error != CodecError.ERR_NONE) {
    (#tab)(#tab)(#tab)throw new CodecError(error);
    (#tab)(#tab)}
    (#tab)} /* (#name)(...) */
  ]]></template>

  <!-- SQL Params -->
  <template key="sql.params.method"><![CDATA[
    (#tab)public Object[] sqlParamsAll()
    (#tab){
    (#tab)(#tab)return new Object[] {(#body)
    (#tab)(#tab)};
    (#tab)} ]]></template>
  <template key="sql.params.except.auto"><![CDATA[ true ]]></template>
  <template key="sql.params.any"><![CDATA[ ]]></template>
  <template key="sql.params.ref.any | sql.params.ptr.any"><![CDATA[
    (#tab)(#namer), ]]></template>
  <template key="sql.params.ref.enum | sql.params.ptr.enum"><![CDATA[
    (#tab)(#namer).value(), ]]></template>

  <template key="sql.start.method"><![CDATA[
    [#addImport(struct; imports; java.util::Map)]
    [#addImport(struct; imports; java.util::LinkedHashMap)]
    (#tab)static public final class SQL {
    (#blank)
    (#tab)(#tab)static public final String TABLE = "(#table)";
    (#blank)
    (#tab)(#tab)static public invar.lib.InvarSQL getBuilder() {
    (#tab)(#tab)(#tab)if (builder == null) {
    (#tab)(#tab)(#tab)(#tab)builder = invar.lib.InvarSQL.Create(
    (#tab)(#tab)(#tab)(#tab)(#tab)TABLE, getWritableFields(), getAliasMap());
    (#tab)(#tab)(#tab)}
    (#tab)(#tab)(#tab)return builder;
    (#tab)(#tab)}
    (#blank)
    (#tab)(#tab)static private invar.lib.InvarSQL builder = null;
  ]]></template>
  <template key="sql.end.method"><![CDATA[ (#tab)} ]]></template>

  <!-- SQL: fields that can be updated -->
  <template key="sql.writable.method.arg">
    <![CDATA[ writableFields ]]></template>
  <template key="sql.writable.except.auto"><![CDATA[ true ]]></template>
  <template key="sql.writable.method"><![CDATA[
    [#addImport(struct; imports; java.util::List)]
    [#addImport(struct; imports; java.util::ArrayList)]
    (#tab)(#tab)static private List<String> (#arg) = null;
    (#blank)
    (#tab)(#tab)static private List<String> getWritableFields() {
    (#tab)(#tab)(#tab)if ((#arg) != null) {
    (#tab)(#tab)(#tab)(#tab)return (#arg);
    (#tab)(#tab)(#tab)}
    (#tab)(#tab)(#tab)List<String> list = new ArrayList<String>();(#body)
    (#tab)(#tab)(#tab)return (#arg) = list;
    (#tab)(#tab)}
  ]]></template>
  <template key="sql.writable.any"><![CDATA[ ]]></template>
  <template key="sql.writable.ref.any | sql.writable.ptr.any"><![CDATA[
    (#tab)list.add("(#alias)"); ]]></template>

  <!-- SQL Alias -->
  <template key="sql.alias.method"><![CDATA[
    (#tab)(#tab)static private Map<String, String> aliasMap = null;
    (#blank)
    (#tab)(#tab)static private Map<String, String> getAliasMap() {
    (#tab)(#tab)(#tab)if (aliasMap != null) {
    (#tab)(#tab)(#tab)(#tab)return aliasMap;
    (#tab)(#tab)(#tab)}
    (#tab)(#tab)(#tab)Map<String, String> map = new LinkedHashMap<String, String>();(#body)
    (#tab)(#tab)(#tab)return aliasMap = map;
    (#tab)(#tab)}
  ]]></template>
  <template key="sql.alias.any"><![CDATA[ ]]></template>
  <template key="sql.alias.ref.any | sql.alias.ptr.any"><![CDATA[
    (#tab)map.put("(#alias)", "(#namer)"); ]]></template>
  <template key="sql.alias.ref.enum | sql.alias.ptr.enum"><![CDATA[
    (#tab)map.put("(#alias)", "(#namer)V"); ]]></template>


</tns:root>