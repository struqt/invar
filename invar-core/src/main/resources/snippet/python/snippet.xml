<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="python"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <export resPath="python/__init__.py" destDir="." destName="__init__.py"/>
  <export resPath="python/InvarCodec.py" destDir="." destName="InvarCodec.py"/>

  <!-- Redefine 14 Invar buildin types to adapt Python language -->
  <redefine>
    <int8 pack="" type="int08" initValue="-1"/>
    <int16 pack="" type="int16" initValue="-1"/>
    <int32 pack="" type="int32" initValue="-1"/>
    <int64 pack="" type="int64" initValue="-1"/>
    <uint8 pack="" type="uint08" initValue="0"/>
    <uint16 pack="" type="uint16" initValue="0"/>
    <uint32 pack="" type="uint32" initValue="0"/>
    <uint64 pack="" type="uint32" initValue="0"/>
    <float pack="" type="float32" initValue="0.0"/>
    <double pack="" type="float64" initValue="0.00"/>
    <string pack="" type="string" initValue=""/>
    <bool pack="" type="boolean" initValue="False"/>
    <vec pack="" type="list" generic="&lt;?&gt;" initValue=""/>
    <map pack="" type="dict" generic="&lt;?,?&gt;" initValue=""/>
    <dialect pack="io" type="BufferedWriter"/>
    <dialect pack="io" type="BufferedReader"/>
  </redefine>

  <!-- Settings -->
  <template key="trace.all.types">     <![CDATA[ false ]]></template>
  <template key="unique.type.name">    <![CDATA[ true  ]]></template>
  <template key="capitalize.pack.head"><![CDATA[ true  ]]></template>
  <template key="one.pack.one.file">   <![CDATA[ false ]]></template>
  <template key="include.self">        <![CDATA[ false ]]></template>
  <template key="pack.name.nested">    <![CDATA[ true  ]]></template>
  <template key="code.dir.flatten">    <![CDATA[ true  ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ false ]]></template>
  <template key="no.generic.type">     <![CDATA[ true  ]]></template>
  <template key="method.indent.num">   <![CDATA[ 1     ]]></template>
  <template key="code.dir.prefix">     <![CDATA[  ]]></template>
  <template key="import.exclude.same.pack"><![CDATA[ false ]]></template>
  <template key="import.exclude.conflict"> <![CDATA[ false  ]]></template>

  <!-- Common snippet -->
  <template key="import">      <![CDATA[ (#body)(#brk) ]]></template>
  <template key="import.body"> <![CDATA[ from (#pack) import (#name) ]]></template>
  <template key="import.split"><![CDATA[ ]]></template>

  <template key="init.any">    <![CDATA[ (#deft)         ]]></template>
  <template key="init.string"> <![CDATA[ '(#deft)'       ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name) ]]></template>
  <template key="init.struct"> <![CDATA[ (#type)()       ]]></template>
  <template key="init.vec">    <![CDATA[ []    ]]></template>
  <template key="init.map">    <![CDATA[ {}    ]]></template>

  <template key="pointer.null">  <![CDATA[ None ]]></template>
  <template key="pointer.spec">  <![CDATA[ ?*  ]]></template>
  <template key="pointer.invoke"><![CDATA[ ?-> ]]></template>
  <template key="pointer.copy">  <![CDATA[ (#name) = (#arg) ]]></template>

  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg) ]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>

  <template key="byte.yes">      <![CDATA[ 0x01 ]]></template>
  <template key="byte.non">      <![CDATA[ 0x00 ]]></template>

  <template key="file"><![CDATA[
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-
    # ===------------------------------*  Python  *------------------------------===
    #             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    # ===------------------------------------------------------------------------===
    (#blank)
    (#pack)]]></template>
  <template key="file.pack"><![CDATA[
    (#includes)
    (#body) ]]></template>
  <template key="file.body"><![CDATA[
    (#import)
    (#enums)(#structs)]]></template>
  <template key="doc"><![CDATA[ """(#doc)""" ]]></template>
  <template key="doc.line"><![CDATA[ (#space)# (#doc). ]]></template>

  <template key="enum"><![CDATA[
    #from enum import Enum, unique
    #@unique
    #class (#name)(Enum):
    class (#name)(object):
    (#blank)
    (#tab)(#doc)
    (#body)
    # end enum (#name)
	]]></template>
  <template key="enum.field"><![CDATA[
    (#tab)(#name) = (#value)(#doc)
  ]]></template>
  <template key="struct.protoc.ntf"> <![CDATA[ (#brk), Invar.ProtocNotify   ]]></template>
  <template key="struct.protoc.req"> <![CDATA[ (#brk), Invar.ProtocRequest  ]]></template>
  <template key="struct.protoc.resp"><![CDATA[ (#brk), Invar.ProtocResponse ]]></template>
  <template key="struct.const.name.crc"><![CDATA[ (#type).CRC32_ ]]></template>
  <template key="struct"><![CDATA[
    (#concat-all)
    try:
    (#tab)from cStringIO import StringIO
    except:
    (#tab)from StringIO import StringIO
    from InvarCodec import DataWriter
    from InvarCodec import DataReader
    (#blank)
    class (#name)(object):
    (#blank)
    (#tab)(#doc)
    (#tab)CRC32_ = 0x[#codeCRC32(struct)]
    (#tab)SIZE_  = [#codeBasicSize(struct)]
    (#blank)
    [#codeNested (slots.; useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (ctor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (tostr.; useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (size.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (read.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (write.; useFullName; struct; fields; imports)]
    (#blank)
    #class (#name)
    (#blank)
    if '__main__' == __name__:
    (#tab)print('dir((#name)()) =>\n' + '\n'.join(dir((#name)())))
    (#tab)print('(#name).__doc__ => ' + (#name).__doc__)
    (#tab)print('(#name).__len__ => ' + str(len((#name)())))
    (#tab)print('(#name).__str__ => ' + str((#name)()))
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.prefix"><![CDATA[ self._ ]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#clampLen(lenFieldNameR; 16; (#namer) )] = (#value);
    (#concat)[#codeLineDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)@(#namer).setter [#codeDoc(fields; (#index))]
    (#tab)def (#namer)(self, value):
    (#tab)(#tab)(#name) = value
    (#tab)(#tab)return self
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)@property [#codeDoc(fields; (#index))]
    (#tab)def (#namer)(self):
    (#tab)(#tab)return (#name)
  ]]></template>

  <!-- Slots -->
  <template key="slots.method"><![CDATA[
    (#tab)__slots__ = ((#body))
    (#space)(#space)(#space)#__slots__
  ]]></template>
  <template key="slots.any | slots.vec | slots.map"><![CDATA[ _(#namer) ]]></template>
  <template key="slots.ref.any | slots.ptr.any"><![CDATA[ '(#body)' ]]></template>
  <template key="slots.field.space.any"><![CDATA[ (#concat-all),(#brk) ]]></template>

  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    (#tab)def __init__(self):(#body)
    (#space)(#space)(#space)#def __init__
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#null) ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body) ]]></template>

  <!-- Method Size -->
  <template key="size.import"><![CDATA[ ]]></template>
  <template key="size.method.arg"><![CDATA[ size ]]></template>
  <template key="size.method"><![CDATA[
    (#tab)def __len__(self):
    (#tab)(#tab)size = (#type).SIZE_(#body)
    (#tab)(#tab)return size
    (#space)(#space)(#space)#def __len__
  ]]></template>
  <template key="size.int8">  <![CDATA[ sizeof(int8_t)   ]]></template>
  <template key="size.int16"> <![CDATA[ sizeof(int16_t)  ]]></template>
  <template key="size.int32"> <![CDATA[ sizeof(int32_t)  ]]></template>
  <template key="size.int64"> <![CDATA[ sizeof(int64_t)  ]]></template>
  <template key="size.uint8"> <![CDATA[ sizeof(uint8_t)  ]]></template>
  <template key="size.uint16"><![CDATA[ sizeof(uint16_t) ]]></template>
  <template key="size.uint32"><![CDATA[ sizeof(uint32_t) ]]></template>
  <template key="size.uint64"><![CDATA[ sizeof(uint64_t) ]]></template>
  <template key="size.float"> <![CDATA[ sizeof(float_t)  ]]></template>
  <template key="size.double"><![CDATA[ sizeof(double_t) ]]></template>
  <template key="size.bool">  <![CDATA[ sizeof(uint8_t)  ]]></template>
  <template key="size.enum">  <![CDATA[ sizeof(int32_t)  ]]></template>
  <template key="size.string"><![CDATA[ len((#name))     ]]></template>
  <template key="size.struct"><![CDATA[ len((#name))     ]]></template>
  <template key="size.ref.any"><![CDATA[ (#concat-all) ]]></template>
  <template key="size.ref.vec | size.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="size.ref.string | size.ref.struct"><![CDATA[
    (#arg) += (#body)
  ]]></template>
  <template key="size.ptr.string | size.ptr.struct"><![CDATA[
    if (#name) is not (#null):
    (#tab)(#arg) += (#body)
  ]]></template>
  <template key="size.ptr.vec | size.ptr.map"><![CDATA[
    if (#name) is not (#null):(#bodyindent)
  ]]></template>
  <template key="size.vec.head">  <![CDATA[ ]]></template>
  <template key="size.vec.for"><![CDATA[
    (#arg) += 4
    for (#value) in (#name):(#body)
  ]]></template>
  <template key="size.map.head.k"><![CDATA[ ]]></template>
  <template key="size.map.head.v"><![CDATA[ ]]></template>
  <template key="size.map.for"><![CDATA[
    (#arg) += 4
    for ((#key),(#value)) in (#name).items():(#body)
  ]]></template>
  <template key="size.nest.n"><![CDATA[ (#arg) += (#body) ]]></template>
  <template key="size.nest.k"><![CDATA[ (#arg) += (#body) ]]></template>
  <template key="size.nest.v"><![CDATA[ (#arg) += (#body) ]]></template>
  <template key="size.nest.v.string|size.nest.v.struct|size.nest.v.vec|size.nest.v.map"><![CDATA[
    (#arg) += (#body) ]]></template>
  <template key="size.vec.for.simple | size.map.for.simple"><![CDATA[
    if len((#name)) > 0:
    (#tab)(#arg) += len((#name)) * (#sizeof)
  ]]></template>

  <!-- To String -->
  <template key="tostr.import"><![CDATA[ ]]></template>
  <template key="tostr.method.arg"><![CDATA[ s ]]></template>
  <template key="tostr.method"><![CDATA[
    (#tab)def __str__(self):
    (#tab)(#tab)(#arg) = StringIO()
    (#tab)(#tab)(#arg).write(u'{')
    (#tab)(#tab)(#arg).write(u' ')
    (#tab)(#tab)(#arg).write(u'(#type)')(#body)
    (#tab)(#tab)(#arg).write(u' ')
    (#tab)(#tab)(#arg).write(u'}')
    (#tab)(#tab)result = (#arg).getvalue()
    (#tab)(#tab)(#arg).close()
    (#tab)(#tab)return result
    (#space)(#space)(#space)#def __str__ ]]></template>
  <template key="tostr.any">   <![CDATA[ (#arg).write(unicode((#name))) ]]></template>
  <template key="tostr.struct"><![CDATA[
    (#arg).write(u'<')
    (#arg).write(u'(#type)')
    (#arg).write(u'>')
  ]]></template>
  <template key="tostr.vec">   <![CDATA[
    (#arg).write(u'(')
    (#arg).write(str(len((#name))))
    (#arg).write(u')')
  ]]></template>
  <template key="tostr.map">   <![CDATA[
    (#arg).write(u'[')
    (#arg).write(str(len((#name))))
    (#arg).write(u']')
  ]]></template>
  <template key="tostr.string"><![CDATA[
    (#arg).write(u'"')
    (#arg).write((#name))
    (#arg).write(u'"')
  ]]></template>
  <template key="tostr.ref.any"><![CDATA[
    (#arg).write(u',')
    (#arg).write(u' ')
    (#arg).write(u'(#namer)')
    (#arg).write(u':')
    (#body) ]]></template>
  <template key="tostr.ptr.any"><![CDATA[
    (#arg).write(u',')
    (#arg).write(u' ')
    (#arg).write(u'(#namer)')
    (#arg).write(u':')
    if (#name) is (#null):
    (#tab)(#arg).write(u'null')
    else:
    (#bodyindent)
  ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[ InvarCodec::DataReader ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    (#tab)def read((#arg)):(#body)
    (#space)(#space)(#space)#def read
  ]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).readInt8()   ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).readInt16()  ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).readInt32()  ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).readInt64()  ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).readUInt8()  ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).readUInt16() ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).readUInt32() ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).readUInt64() ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).readSingle() ]]></template>
  <template key="read.double"><![CDATA[ (#arg).readDouble() ]]></template>
  <template key="read.string"><![CDATA[ (#arg).readString() ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).readBoolean()]]></template>
  <template key="read.enum">  <![CDATA[ (#arg).readInt32()  ]]></template>
  <template key="read.struct"><![CDATA[ (#name).read((#arg))]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#name) = (#body) ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#name) = (#type)()
    (#body)
  ]]></template>
  <template key="read.vec.head">  <![CDATA[ (#name) = (#typel)() # read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    (#len) = (#arg).readUInt32()
    num = 0
    while num < (#len):
    (#tab)num += 1(#body)
    (#tab)(#name).append((#value))
  ]]></template>
  <template key="read.map.head"> <![CDATA[ (#name) = (#typel)() # read.map.head(#brk) ]]></template>
  <template key="read.map.for"><![CDATA[
    (#len) = (#arg).readUInt32()
    num = 0
    while num < (#len):
    (#tab)num += 1(#body)
    (#tab)(#name)[(#key)] = (#value)
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body) ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body) ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    (#namer)Exists = (#arg).readInt8()
    if (#byteyes) == (#namer)Exists:
    (#tab)(#name) = (#body)
    elif (#bytenon) == (#namer)Exists:
    (#tab)(#name) = (#null)
    else:
    (#tab)raise InvarError(496, 'Protoc read error: The value of \\'(#namer)Exists\\' is invalid.')
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    (#namer)Exists = (#arg).readInt8()
    if (#byteyes) == (#namer)Exists:
    (#tab)if (#name) == (#null):
    (#tab)(#tab)(#name) = (#type)()
    (#tab)(#body)
    elif (#bytenon) == (#namer)Exists:
    (#tab)(#name) = (#null)
    else:
    (#tab)raise InvarError(497, 'Protoc read error: The value of \\'(#namer)Exists\\' is invalid.')
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    (#namer)Exists = (#arg).readInt8()
    if (#byteyes) == (#namer)Exists:
    (#tab)if (#name) == (#null):
    (#tab)(#tab)(#name) = (#typel)()(#bodyindent)
    elif (#bytenon) == (#namer)Exists:
    (#tab)(#name) = (#null)
    else:
    (#tab)raise InvarError(498, 'Protoc read error: The value of \\'(#namer)Exists\\' is invalid.')
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#brk)if CRC32 != (#name):
    (#tab)raise InvarError(499, "Protoc read error: CRC32 is mismatched.", 499)
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    (#brk)if (#name) != 0:
    (#tab)raise InvarError((#name), "Protoc read error: The code is " + (#name))
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[ InvarCodec::DataWriter ]]></template>
  <template key="write.method.arg"><![CDATA[ w ]]></template>
  <template key="write.method"><![CDATA[
    (#tab)def write((#arg)):(#body)
    (#space)(#space)(#space)#def write
  ]]></template>
  <template key="write.int8">  <![CDATA[ (#arg).writeInt8((#name))   ]]></template>
  <template key="write.int16"> <![CDATA[ (#arg).writeInt16((#name))  ]]></template>
  <template key="write.int32"> <![CDATA[ (#arg).writeInt32((#name))  ]]></template>
  <template key="write.int64"> <![CDATA[ (#arg).writeInt64((#name))  ]]></template>
  <template key="write.uint8"> <![CDATA[ (#arg).writeUInt8((#name))  ]]></template>
  <template key="write.uint16"><![CDATA[ (#arg).writeUInt16((#name)) ]]></template>
  <template key="write.uint32"><![CDATA[ (#arg).writeUInt32((#name)) ]]></template>
  <template key="write.uint64"><![CDATA[ (#arg).writeUInt64((#name)) ]]></template>
  <template key="write.float"> <![CDATA[ (#arg).writeFloat((#name))  ]]></template>
  <template key="write.double"><![CDATA[ (#arg).writeDouble((#name)) ]]></template>
  <template key="write.bool">  <![CDATA[ (#arg).writeBool((#name))   ]]></template>
  <template key="write.string"><![CDATA[ (#arg).writeString((#name)) ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).writeInt32((#name))  ]]></template>
  <template key="write.struct"><![CDATA[ (#name).write((#arg))       ]]></template>
  <template key="write.vec.for"><![CDATA[
    (#arg).writeUInt32(len((#name)))
    for (#value) in (#name):(#body)
  ]]></template>
  <template key="write.map.for"><![CDATA[
    (#arg).writeUInt32(len((#name)))
    for ((#key),(#value)) in (#name).items():(#body)
  ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body) ]]></template>
  <template key="write.nest.k"><![CDATA[ (#body) ]]></template>
  <template key="write.nest.v"><![CDATA[ (#body) ]]></template>
  <template key="write.vec.head">  <![CDATA[ ]]></template>
  <template key="write.map.head.k"><![CDATA[ ]]></template>
  <template key="write.map.head.v"><![CDATA[ ]]></template>

  <template key="write.ref.any"><![CDATA[ (#body) ]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if (#name) != (#null):
    (#tab)(#arg).writeUInt8((#byteyes))
    (#tab)(#body)
    else:
    (#tab)(#arg).writeUInt8((#bytenon))
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if (#name) != (#null):
    (#tab)(#arg).writeUInt8((#byteyes))(#bodyindent)
    else:
    (#tab)(#arg).writeUInt8((#bytenon))
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if (#name) != 0:
    (#tab)return
  ]]></template>


  <!-- Write InvarRuntime file -->
  <template key="runtime.file"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.pack"><![CDATA[ ]]></template>
  <template key="runtime.name"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.body"><![CDATA[
    (#concat-all)
    import sys
    (#blank)
    class InvarRuntime:
    (#body)
    (#blank)
    #end class InvarRuntime
    (#blank)
    if '__main__' == __name__:
    (#tab)print(sys.version)
    (#tab)print(sys.getdefaultencoding())
  ]]></template>
  <template key="runtime.protoc.handle.client"><![CDATA[ HandleProtocAsServer ]]></template>
  <template key="runtime.protoc.handle.server"><![CDATA[ HandleProtocAsClient ]]></template>
  <template key="runtime.protoc.handle.notify"><![CDATA[ (#blank)
    (#tab)(#tab)elif (#key) == id: # (#doc)
    (#tab)(#tab)(#tab)(#name) = (#type)()
    (#tab)(#tab)(#tab)(#name).read(r)
    (#tab)(#tab)(#tab)Handle(#type)((#name)) ]]></template>
  <template key="runtime.protoc.handle.response"><![CDATA[ (#blank)
    (#tab)(#tab)elif (#key) == id: # (#doc)
    (#tab)(#tab)(#tab)(#name) = (#type)()
    (#tab)(#tab)(#tab)(#name).read(r)
    (#tab)(#tab)(#tab)Handle(#type)((#name)) ]]></template>
  <template key="runtime.protoc.handle.request"><![CDATA[ (#blank)
    (#tab)(#tab)elif (#key) == id: # (#doc)
    (#tab)(#tab)(#tab)(#name) = (#type)()
    (#tab)(#tab)(#tab)(#name).read(r)
    (#tab)(#tab)(#tab)resp = (#resp)()
    (#tab)(#tab)(#tab)Handle(#req)((#name), resp) ]]></template>
  <template key="runtime.protoc.handle.method"><![CDATA[
    (#blank)
    (#tab)@staticmethod
    (#tab)def (#name)(r):
    (#tab)(#tab)id = r.peekUInt16()
    (#tab)(#tab)if 0 == id:
    (#tab)(#tab)(#tab)pass(#body)
    (#tab)(#tab)else:
    (#tab)(#tab)(#tab)pass
    (#space)(#space)(#space)#def (#name)
  ]]></template>


</tns:root>
