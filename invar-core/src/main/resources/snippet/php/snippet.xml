<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="php"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <!-- & &amp; < &lt; > &gt; " &quot; ' &apos; -->
  <export resPath="php/invar.codec.php" destDir="" destName="invar/invar.codec.php"/>

  <!-- Redefine 14 Invar buildin types to adapt PHP language -->
  <redefine>
    <int8 pack="php" type="int08" initValue="-1"/>
    <int16 pack="php" type="int16" initValue="-1"/>
    <int32 pack="php" type="int32" initValue="-1"/>
    <int64 pack="php" type="int64" initValue="-1"/>
    <uint8 pack="php" type="uint08" initValue="0"/>
    <uint16 pack="php" type="uint16" initValue="0"/>
    <uint32 pack="php" type="uint32" initValue="0"/>
    <uint64 pack="php" type="uint32" initValue="0"/>
    <float pack="php" type="float32" initValue="0.0"/>
    <double pack="php" type="float64" initValue="0.00"/>
    <string pack="php" type="string" initValue=""/>
    <bool pack="php" type="boolean" initValue="FALSE"/>
    <vec pack="php" type="list" generic="&lt;?&gt;" initValue=""/>
    <map pack="php" type="dict" generic="&lt;?,?&gt;" initValue=""/>
    <dialect pack="invar" type="BinaryWriter" include="invar/invar.codec.php"/>
    <dialect pack="invar" type="BinaryReader" include="invar/invar.codec.php"/>
  </redefine>
  <template key="trace.all.types">     <![CDATA[false]]></template>
  <template key="include.self">        <![CDATA[false]]></template>
  <template key="pack.name.nested">    <![CDATA[false]]></template>
  <template key="file.name.lowercase"> <![CDATA[false]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num">   <![CDATA[1]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[false]]></template>
  <template key="code.dir.prefix">     <![CDATA[]]></template>
  <template key="pack.head.prefix">    <![CDATA[ true ]]></template>
  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg);]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[ ]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null">  <![CDATA[NULL]]></template>
  <template key="pointer.copy">  <![CDATA[(#name) = (#arg);]]></template>
  <template key="byte.yes">      <![CDATA[0x01]]></template>
  <template key="byte.non">      <![CDATA[0x00]]></template>

  <template key="init.any">    <![CDATA[ (#deft)     ]]></template>
  <template key="init.string"> <![CDATA[ '(#deft)'   ]]></template>
  <template key="init.struct"> <![CDATA[ new (#type) ]]></template>
  <template key="init.enum">   <![CDATA[ (#type)::(#name) ]]></template>
  <template key="init.vec">    <![CDATA[ array() ]]></template>
  <template key="init.map">    <![CDATA[ array() ]]></template>

  <template key="import"><![CDATA[ use \(#body);(#brk) ]]></template>
  <template key="import.body"><![CDATA[ (#pack)(#name) ]]></template>
  <template key="import.split"><![CDATA[ \ ]]></template>
  <template key="import.exclude.conflict"><![CDATA[true]]></template>
  <template key="import.exclude.same.pack"><![CDATA[true]]></template>
  <template key="import.exclude.packs"><![CDATA[php]]></template>
  <template key="doc">     <![CDATA[ /** (#doc) */    ]]></template>
  <template key="doc.line"><![CDATA[ (#space)// (#doc) ]]></template>
  <template key="struct.field.prefix"><![CDATA[ this-> ]]></template>
  <template key="struct.const.name.crc"><![CDATA[ self::CRC32 ]]></template>

  <template key="file"><![CDATA[
    <?php
	  /*===----------------------------*  PHP 5  *-------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===*/
    (#blank)
    (#pack) ]]></template>
  <template key="file.include">      <![CDATA[ require_once dirname(__FILE__) . (#name);(#brk) ]]></template>
  <template key="file.include.wrap"> <![CDATA[ '/(#nameupper)(#value)' ]]></template>
  <template key="file.include.split"><![CDATA[ / ]]></template>
  <template key="file.pack.split">   <![CDATA[ \ ]]></template>
  <template key="file.pack"><![CDATA[
	namespace (#name);
    (#blank)
    (#includes)
    (#body) ]]></template>
  <template key="file.body"><![CDATA[
    (#import)
    (#enums)(#structs) ]]></template>

  <template key="enum.field"><![CDATA[
    (#tab)const (#name) = (#value);(#doc)
  ]]></template>
  <template key="enum"><![CDATA[
    abstract class (#name)
    {
    (#body)}
  ]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; invar::BinaryReader)]
    [#addImport(struct; imports; invar::BinaryWriter)]
    (#concat)
    (#blank)
    final class (#name)
    {
    (#tab)const CRC32 = 0x[#codeCRC32(struct)];
    (#blank)
    (#tab)static public function &CreateFromBytes (& $str)
    (#tab){
    (#tab)(#tab)$o = new (#name);
    (#tab)(#tab)$o->read(new BinaryReader($str));
    (#tab)(#tab)return $o;
    (#tab)}
    (#blank)
    [#codeFields (struct; fields)]
    [#codeNested (ctor.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (copy.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (write.; useFullName; struct; fields; imports)](#brk)
    [#codeGetters(struct; fields)]
    [#codeSetters(struct; fields)]
    [#codeNested (tostr.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (tojson.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.; useFullName; struct; fields; imports)](#brk)
    }
	]]></template>
  <template key="struct.meta"><![CDATA[ (#name) (#type) ]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private \$[#clampLen(lenFieldNameR; 24; (#namer) )] ;
    (#concat)/* [#codeMetaData(fields; (#index))]
    (#concat)[#codeLineDoc(fields; (#index))] */
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)public function set[#upperHeadChar( (#namer) )](\$value) { \$(#name) = \$value; return \$this; }
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)public function(#spec)get[#upperHeadChar( (#namer) )]() { return \$(#name); }
  ]]></template>

  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    (#tab)function __construct()
    (#tab){(#body)
    (#tab)}
    (#tab)/* End of constructor() */ ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    \$[#clampLen(lenFieldName; 24; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    \$[#clampLen(lenFieldName; 24; (#name))] = (#null); ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body); ]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[ \$from ]]></template>
  <template key="copy.method"><![CDATA[ (#tab)public function &copy (& \$from)
    (#tab){
      (#tab)(#tab)if (\$this == \$from || \$from == (#null)) {
      (#tab)(#tab)(#tab)return this;
      (#tab)(#tab)}(#body)
      (#tab)(#tab)return \$this;
    (#tab)}
    (#tab)/* End of copy(...) */ ]]></template>
  <template key="copy.any"><![CDATA[ (#arg)->(#namer) ]]></template>
  <template key="copy.ref.any"><![CDATA[ \$(#name) = (#body); ]]></template>
  <template key="copy.ptr.any"><![CDATA[ \$(#name) = (#body);  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if ((#arg)->(#namer) != (#null)) {
    (#tab)\$(#name).copy((#body));
    } else {
    (#tab)\$(#name) = (#null);
    }
  ]]></template>
  <template key="copy.vec | copy.map"><![CDATA[ \$(#name) = array_merge((#arg)->(#namer)) ]]></template>
  <template key="copy.ref.vec | copy.ref.map"><![CDATA[
    if ((#arg)->(#namer) != (#null)) {
    (#tab)(#body);
    } else {
    (#tab)\$(#name) = array();
    } ]]></template>
  <template key="copy.ptr.vec | copy.ptr.map"><![CDATA[
    if ((#arg)->(#namer) != (#null)) {
    (#tab)\$(#name) = array();
    (#tab)(#body);
    } else {
    (#tab)\$(#name) = (#null);
    }
  ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.method.arg"><![CDATA[ \$r ]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public function &read (& \$r)
    (#tab){(#body)
    (#tab)(#tab)return \$this;
    (#tab)}
    (#tab)/* End of read(...) */
  ]]></template>
  <template key="read.int8">  <![CDATA[ (#arg)->readInt08()  ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg)->readInt16()  ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg)->readInt32()  ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg)->readInt64()  ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg)->readUInt08() ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg)->readUInt16() ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg)->readUInt32() ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg)->readUInt64() ]]></template>
  <template key="read.float"> <![CDATA[ (#arg)->readFloat32()]]></template>
  <template key="read.double"><![CDATA[ (#arg)->readFloat64()]]></template>
  <template key="read.string"><![CDATA[ (#arg)->readUTF()    ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg)->readBoolean()]]></template>
  <template key="read.enum">  <![CDATA[ (#arg)->readInt32()  ]]></template>
  <template key="read.struct"><![CDATA[ \$(#name)->read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ \$(#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    \$(#name) = new (#type)();(#brk)(#body); ]]></template>
  <template key="read.vec.head">  <![CDATA[\$(#name) = array(); //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    \$(#len) = (#arg)->readUInt32();
    for (\$(#index) = 0; \$(#index) < \$(#len); ++\$(#index)) {(#body)
    (#tab)\$(#name)[] = \$(#value);
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[\$(#name) = array(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    \$(#len) = (#arg)->readUInt32();
    for (\$(#index) = 0; \$(#index) < \$(#len); ++\$(#index)) {(#body)
    (#tab)\$(#name)[\$(#key)] = \$(#value);
    }
  ]]></template>
  <template key="read.ref.any"><![CDATA[ \$(#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec"><![CDATA[ \$(#name) = array();(#brk)(#body) ]]></template>
  <template key="read.ref.map"><![CDATA[ \$(#name) = array();(#brk)(#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    \$(#namer)Exists = (#arg)->readInt08();
    if ((#byteyes) == \$(#namer)Exists) { \$(#name) = (#body); }
    else if ((#bytenon) == \$(#namer)Exists) { \$(#name) = (#null); }
    else { throw new \\Exception('Protoc read error: The value of \' . \$(#namer)Exists\ . ' is invalid.', 496); }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    \$(#namer)Exists = (#arg)->readInt08();
    if ((#byteyes) == \$(#namer)Exists) {
    (#tab)if (\$(#name) == (#null)) { \$(#name) = new (#type); }
    (#tab)(#body);
    }
    else if ((#bytenon) == \$(#namer)Exists) { \$(#name) = (#null); }
    else { throw new \\Exception('Protoc read error: The value of \' . \$(#namer)Exists . \' is invalid.', 497); }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    \$(#namer)Exists = (#arg)->readInt08();
    if ((#byteyes) == \$(#namer)Exists) {
    (#tab)if (\$(#name) == (#null)) { \$(#name) = array(); }(#bodyindent)
    }
    else if ((#bytenon) == \$(#namer)Exists) { \$(#name) = (#null); }
    else { throw new \\Exception('Protoc read error: The value of \' . \$(#namer)Exists . \' is invalid.', 498); }
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#brk)if (self::CRC32 != \$(#name)) { throw new \\Exception('Protoc read error: CRC32 is mismatched', 499); }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    (#brk)if (\$(#name) != 0) {
    (#tab)throw new \\Exception('Protoc read error: The code is ' . \$(#name), \$(#name));
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.method.arg"><![CDATA[ \$str ]]></template>
  <template key="write.method"><![CDATA[ (#tab)public function write (& \$str)
    (#tab){(#body)
    (#tab)}
    (#tab)/* End of write(...) */
  ]]></template>
  <template key="write.int8">  <![CDATA[ BinaryWriter::writeInt08(\$(#name), (#arg))  ]]></template>
  <template key="write.int16"> <![CDATA[ BinaryWriter::writeInt16(\$(#name), (#arg))  ]]></template>
  <template key="write.int32"> <![CDATA[ BinaryWriter::writeInt32(\$(#name), (#arg))  ]]></template>
  <template key="write.int64"> <![CDATA[ BinaryWriter::writeInt64(\$(#name), (#arg))  ]]></template>
  <template key="write.uint8"> <![CDATA[ BinaryWriter::writeUInt08(\$(#name), (#arg)) ]]></template>
  <template key="write.uint16"><![CDATA[ BinaryWriter::writeUInt16(\$(#name), (#arg)) ]]></template>
  <template key="write.uint32"><![CDATA[ BinaryWriter::writeUInt32(\$(#name), (#arg)) ]]></template>
  <template key="write.uint64"><![CDATA[ BinaryWriter::writeUInt64(\$(#name), (#arg)) ]]></template>
  <template key="write.float"> <![CDATA[ BinaryWriter::writeFloat32(\$(#name), (#arg))]]></template>
  <template key="write.double"><![CDATA[ BinaryWriter::writeFloat64(\$(#name), (#arg))]]></template>
  <template key="write.bool">  <![CDATA[ BinaryWriter::writeBoolean(\$(#name), (#arg))]]></template>
  <template key="write.string"><![CDATA[ BinaryWriter::writeUTF(\$(#name), (#arg))    ]]></template>
  <template key="write.enum">  <![CDATA[ BinaryWriter::writeInt32(\$(#name), (#arg))  ]]></template>
  <template key="write.struct"><![CDATA[ \$(#name)->write((#arg)) ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.k"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.v"><![CDATA[ (#body); ]]></template>
  <template key="write.vec.head"><![CDATA[]]></template>
  <template key="write.vec.for"><![CDATA[ BinaryWriter::writeInt32(count(\$(#name)), (#arg));
    foreach (\$(#name) as &\$(#value)) {(#body)
    } ]]></template>
  <template key="write.map.head.k"><![CDATA[]]></template>
  <template key="write.map.head.v"><![CDATA[]]></template>
  <template key="write.map.for"><![CDATA[ BinaryWriter::writeInt32(count(\$(#name)), (#arg));
    foreach (\$(#name) as \$(#key) => &\$(#value)) {(#body)
    } ]]></template>
  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if (\$(#name) != (#null)) {
    (#tab)BinaryWriter::writeInt08((#byteyes), (#arg));
    (#tab)(#body);
    } else {
    (#tab)BinaryWriter::writeInt08((#bytenon), (#arg));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if (\$(#name) != (#null)) {
    (#tab)BinaryWriter::writeInt08((#byteyes), (#arg));(#bodyindent)
    } else {
    (#tab)BinaryWriter::writeInt08((#bytenon), (#arg));
    }
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if (\$(#name) != 0) { return; }
  ]]></template>

  <!-- To String -->
  <template key="tostr.method.arg"><![CDATA[ \$s ]]></template>
  <template key="tostr.method"><![CDATA[ (#tab)public function &toString()
    (#tab){
    (#tab)(#tab)(#arg)  = '{'; (#arg) .= get_class(\$this);(#body)
    (#tab)(#tab)(#arg) .= '}';
    (#tab)(#tab)return (#arg);
    (#tab)}
    (#tab)/* End of toString() */
  ]]></template>
  <template key="tostr.any">   <![CDATA[ (#arg) .= \$(#name) ]]></template>
  <template key="tostr.bool">  <![CDATA[ (#arg) .= \$(#name) == TRUE ? 'True' : 'False' ]]></template>
  <template key="tostr.struct"><![CDATA[ (#arg) .= '<'; (#arg) .= '(#type)'; (#arg) .= '>' ]]></template>
  <template key="tostr.vec">   <![CDATA[ (#arg) .= '('; (#arg) .= count(\$(#name)); (#arg) .= ')' ]]></template>
  <template key="tostr.map">   <![CDATA[ (#arg) .= '['; (#arg) .= count(\$(#name)); (#arg) .= ']' ]]></template>
  <template key="tostr.string"><![CDATA[ (#arg) .= '"'; (#arg) .= \$(#name); (#arg) .= '"' ]]></template>
  <template key="tostr.ref.any"><![CDATA[
    (#arg) .= ','; (#arg) .= '(#namer)'; (#arg) .= ':';
    (#body); ]]></template>
  <template key="tostr.ptr.any"><![CDATA[
    (#arg) .= ','; (#arg) .= '(#namer)'; (#arg) .= ':';
    if (isset(\$(#name))) { (#body); }
    else { (#arg) .= 'null'; }
  ]]></template>

  <!-- Write data to JSON data format -->
  <template key="tojson.method.arg">  <![CDATA[ \$s ]]></template>
  <template key="tojson.method"><![CDATA[
    (#tab)public function &toStringJSON()
    (#tab){
    (#tab)(#tab)\$code = '';
    (#tab)(#tab)\$this->writeJSON(\$code);
    (#tab)(#tab)return \$code;
    (#tab)}(#brk)
    (#tab)public function writeJSON(& (#arg))
    (#tab){
    (#tab)(#tab)(#arg) .= "\\n"; (#arg) .= '{';(#body)
    (#tab)(#tab)(#arg) .= '}'; (#arg) .= "\\n";
    (#tab)}
    (#tab)/* End of writeJSON(...) */
  ]]></template>
  <template key="tojson.any">   <![CDATA[ (#arg) .= \$(#name) ]]></template>
  <template key="tojson.float"> <![CDATA[ (#arg) .= number_format(\$(#name), 6, '.', '') ]]></template>
  <template key="tojson.bool">  <![CDATA[ (#arg) .= \$(#name) ? "true" : "false" ]]></template>
  <template key="tojson.string"><![CDATA[ (#arg) .= '"'; (#arg) .= \$(#name); (#arg) .= '"' ]]></template>
  <template key="tojson.struct"><![CDATA[ \$(#name)->writeJSON((#arg)) ]]></template>
  <template key="tojson.nest.n | tojson.nest.k | tojson.nest.v"><![CDATA[ (#body); ]]></template>
  <template key="tojson.vec.for"><![CDATA[
    \$(#namer)Size = (!isset(\$(#name)) ? 0 : count(\$(#name)));
    (#arg) .= "\\n"; (#arg) .= '[';
    \$(#namer)Idx = 0;
    foreach (\$(#name) as &\$(#value)) {(#body)
    (#tab)++\$(#namer)Idx;
    (#tab)if (\$(#namer)Idx != \$(#namer)Size) { (#arg) .= ','; }
    }
    (#arg) .= ']';
  ]]></template>
  <template key="tojson.map.for"><![CDATA[
    \$(#namer)Size = (!isset(\$(#name)) ? 0 : count(\$(#name)));
    (#arg) .= "\\n"; (#arg) .= '{';
    \$(#namer)Idx = 0;
    foreach (\$(#name) as \$(#key) => &\$(#value)) {(#body)
    (#tab)++\$(#namer)Idx;
    (#tab)if ((#namer)Idx != \$(#namer)Size) { (#arg) .= ','; }
    }
    (#arg) .= '}';
  ]]></template>

  <template key="tojson.ref.any"><![CDATA[
    (#arg) .= '"'; (#arg) .= '(#namer)'; (#arg) .= '"'; (#arg) .= ':'; \$comma = ',';
    (#body); ]]></template>
  <template key="tojson.ref.string | tojson.ref.struct | tojson.ptr.string | tojson.ptr.struct"><![CDATA[
    if (\$(#namer)Exists) {
    (#tab)(#arg) .= '"'; (#arg) .= '(#namer)'; (#arg) .= '"'; (#arg) .= ':'; \$comma = ',';
    (#tab)(#body);
    }
  ]]></template>
  <template key="tojson.ptr.vec | tojson.ptr.map | tojson.ref.vec | tojson.ref.map"><![CDATA[
    if (\$(#namer)Exists) {
    (#tab)(#arg) .= '"'; (#arg) .= '(#namer)'; (#arg) .= '"'; (#arg) .= ':'; \$comma = ',';(#bodyindent)
    }
  ]]></template>

  <template key="tojson.field.head.string"><![CDATA[
    \$(#namer)Exists = !empty(\$(#name));
  ]]></template>
  <template key="tojson.field.head.struct"><![CDATA[
    \$(#namer)Exists = isset(\$(#name));
  ]]></template>
  <template key="tojson.field.head.vec | tojson.field.head.map"><![CDATA[
    \$(#namer)Exists = (isset(\$(#name)) && count(\$(#name)) > 0);
  ]]></template>

  <template key="tojson.field.space.any"><![CDATA[
    if (!empty(\$comma)) { (#arg) .= \$comma; \$comma = ''; }
  ]]></template>
  <template key="tojson.field.space.struct | tojson.field.space.map |
                 tojson.field.space.string | tojson.field.space.vec"><![CDATA[
    if (!empty(\$comma) && \$(#namer)Exists) { (#arg) .= \$comma; \$comma = ''; }
  ]]></template>


  <!-- To XML String -->
  <template key="toxml.method.arg"><![CDATA[ \$s ]]></template>
  <template key="toxml.method"><![CDATA[
    (#tab)public function &toStringXML()
    (#tab){
    (#tab)(#tab)\$code  = '<?xml version="1.0" encoding="UTF-8"?>';
    (#tab)(#tab)\$code .= "\\n"; \$code .= '<!-- '; \$code .= '(#type)'; \$code .= '.CRC32: 0x';
    (#tab)(#tab)\$code .= strtoupper(dechex(self::CRC32)); \$code .= ' -->';
    (#tab)(#tab)\$code .= "\\n"; \$this->writeXML(\$code, '(#type)');
    (#tab)(#tab)return \$code;
    (#tab)}(#brk)
    (#tab)public function writeXML (& (#arg), \$name)
    (#tab){
    (#tab)(#tab)\$attrs = ''; \$nodes = '';(#body)
    (#tab)(#tab)(#arg) .= '<';
    (#tab)(#tab)(#arg) .= \$name;
    (#tab)(#tab)(#arg) .= \$attrs;
    (#tab)(#tab)if (strlen(\$nodes) == 0) {
    (#tab)(#tab)(#tab)(#arg) .= '/>';
    (#tab)(#tab)} else {
    (#tab)(#tab)(#tab)(#arg) .= '>'; (#arg) .= \$nodes;
    (#tab)(#tab)(#tab)(#arg) .= '</'; (#arg) .= \$name; (#arg) .= '>';
    (#tab)(#tab)}
    (#tab)}
    (#tab)/* End of writeXML(...) */
  ]]></template>
  <template key="toxml.any">   <![CDATA[ \$(#name) ]]></template>
  <template key="toxml.float"> <![CDATA[ number_format(\$(#name), 6, '.', '') ]]></template>
  <template key="toxml.bool">  <![CDATA[ \$(#name) ? "true" : "false" ]]></template>
  <template key="toxml.struct"><![CDATA[ \$(#name)->writeXML(\$nodes, '(#namer)') ]]></template>
  <template key="toxml.nest.n.struct | toxml.nest.k.struct | toxml.nest.v.struct"><![CDATA[ (#body); ]]></template>
  <template key="toxml.nest.n | toxml.nest.k | toxml.nest.v"><![CDATA[
    \$nodes .= '<'; \$nodes .= '(#namer)'; \$nodes .= ' ';
    \$nodes .= 'value'; \$nodes .= '='; \$nodes .= '"';
    \$nodes .= \$(#body); \$nodes .= '"';  \$nodes .= '/>';
  ]]></template>
  <template key="toxml.vec.head"><![CDATA[]]></template>
  <template key="toxml.vec.for"><![CDATA[
    \$nodes .= '<'; \$nodes .= '(#namer)'; \$nodes .= '>';
    foreach (\$(#name) as &\$(#value)) {(#body)
    }
    \$nodes .= '</'; \$nodes .= '(#namer)'; \$nodes .= '>';
  ]]></template>
  <template key="toxml.map.head.k"><![CDATA[]]></template>
  <template key="toxml.map.head.v"><![CDATA[]]></template>
  <template key="toxml.map.for"><![CDATA[
    \$nodes .= '<'; \$nodes .= '(#namer)'; \$nodes .= '>';
    foreach (\$(#name) as \$(#key) => &\$(#value)) {(#body)
    }
    \$nodes .= '</'; \$nodes .= '(#namer)'; \$nodes .= '>';
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[
    \$attrs .= ' '; \$attrs .= '(#namer)'; \$attrs .= '=';
    \$attrs .= '"'; \$attrs .= (#body); \$attrs .= '"';
  ]]></template>
  <template key="toxml.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if (count(\$(#name)) > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if (isset(\$(#name))) {
    (#tab)\$attrs .= ' (#namer)="';
    (#tab)\$attrs .= \$(#body);
    (#tab)\$attrs .= '"';
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if (isset(\$(#name))) {
    (#tab)(#body);
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if (isset(\$(#name)) && count(\$(#name)) > 0) {(#bodyindent)
    }]]></template>


  <template key="runtime.file"><![CDATA[ invar.runtime ]]></template>
  <template key="runtime.pack"><![CDATA[ invar ]]></template>
  <template key="runtime.name"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.type.split"><![CDATA[ \ ]]></template>
  <template key="runtime.body"><![CDATA[
    final class InvarRuntime {
    (#body)
    } //class InvarRuntime
  ]]></template>
  <template key="runtime.protoc.handle.client"><![CDATA[ HandleProtocAsServer ]]></template>
  <template key="runtime.protoc.handle.server"><![CDATA[ HandleProtocAsClient ]]></template>
  <template key="runtime.protoc.handle.notify"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ $(#name) = new (#type); $(#name)->read($r); $h = '\Handle(#type)'; break; } ]]></template>
  <template key="runtime.protoc.handle.response"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ $(#name) = new (#type); $(#name)->read($r); $h = '\Handle(#type)'; break; } ]]></template>
  <template key="runtime.protoc.handle.request"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ $(#name) = new (#req); $(#name)->read($r); $h = '\Handle(#req)'; $rep = new (#resp); break; } ]]></template>
  <template key="runtime.protoc.handle.method"><![CDATA[
    (#blank)
    static public function (#name) (&$bytes)
    {
    (#tab)$h = null; $req = null; $rep = null; $ntf = null;
    (#tab)$r = new BinaryReader($bytes);
    (#tab)$id = $r->peekUInt16();
    (#tab)switch ($id) {(#body)
    (#tab)default: throw new \Exception('Unsupported protocol id: ' . $id, 503/* Service Unavailable */);
    (#tab)}
    (#tab)if (!function_exists($h)) { throw new \Exception('No function: ' . $h, 501/* Not Implemented */); }
    (#tab)if ($req != null && $rep != null) {
    (#tab)(#tab)$h($req, $rep); return;
    (#tab)}
    (#tab)if ($ntf != null) {
    (#tab)(#tab)$h($ntf); return;
    (#tab)}
    (#tab)if ($rep != null) {
    (#tab)(#tab)$h($rep); return;
    (#tab)}
    (#tab)throw new \Exception('Unhandled protocol: ' . $id, 500/* Internal Server Error */);
    } // (#name)(...)
  ]]></template>

  <!-- -->
</tns:root>