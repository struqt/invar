<?xml version="1.0" encoding="UTF-8"?>
<tns:root
  language="cpp"
  xmlns:tns="http://invar.struqt.com/snippet/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://invar.struqt.com/snippet/1.0 http://struqt.com/xsd/invar-snippet-1.0.xsd">

  <export resPath="cpp/invar.codec.cpp" destDir="" destName="invar.codec.cpp" />
  <redefine genericOverride="true" />
  <template key="include.self">        <![CDATA[true]]></template>
  <template key="pack.name.nested">    <![CDATA[true]]></template>
  <template key="file.name.lowercase"> <![CDATA[true]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num">   <![CDATA[0]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[true]]></template>
  <template key="code.dir.prefix">     <![CDATA[impl/]]></template>
  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg);]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null">  <![CDATA[nullptr]]></template>
  <template key="pointer.copy">  <![CDATA[CheckSet< (#type) > ((#name), (#arg));]]></template>
  <template key="byte.yes">    <![CDATA[static_cast<int8_t>(0x01)]]></template>
  <template key="byte.non">    <![CDATA[static_cast<int8_t>(0x00)]]></template>

  <template key="init.any">    <![CDATA[ (#deft)   ]]></template>
  <template key="init.float">  <![CDATA[ (#deft)F  ]]></template>
  <template key="init.string"> <![CDATA[ "(#deft)" ]]></template>
  <template key="init.enum">   <![CDATA[ (#name)   ]]></template>

  <template key="file"><![CDATA[
	(#blank)
	//===----------------------------*  CPP  *---------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------===//
	(#blank)
	#ifndef IMPL_(#define)_
	#define IMPL_(#define)_
	(#blank)
	(#includes)
	(#pack)
	(#blank)
	#endif //IMPL_(#define)_]]></template>
  <template key="file.include"><![CDATA[#include "(#name)"(#brk)]]></template>
  <template key="file.pack"><![CDATA[
	namespace (#name) { (#body)
	} //namespace: (#name)]]></template>
  <template key="file.body"><![CDATA[
	(#blank)
	(#blank)
	(#import)(#enums)(#structs)]]></template>

  <!-- Common snippet -->
  <template key="doc">         <![CDATA[/* (#doc). */]]></template>
  <template key="doc.line">    <![CDATA[// (#doc).]]></template>
  <template key="import">      <![CDATA[using namespace (#body);(#brk)]]></template>
  <template key="import.body"> <![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[::]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[(#type)(#name);(#brk)]]></template>
  <template key="ctor"><![CDATA[]]></template>
  <template key="ctor.field"><![CDATA[(#tab)(#name)((#value))]]></template>
  <template key="ctor.field.split"><![CDATA[,(#brk)]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; invar::BinaryReader)]
    [#addImport(struct; imports; std::string)]
    (#concat)
	(#name)::(#name) ():
	[#codeInits(struct; fields)]{
	}
	(#blank)
	(#name)::(#name) (const (#name) &from)
	{
	(#tab)if (this != &from) {
	(#tab)(#tab)CopyFrom(from);
	(#tab)}
	}
	(#blank)
    (#name)::~(#name) ()
    {[#codeDeletes(fields)]
    }
    (#blank)
	(#name)& (#name)::operator = (const (#name) &from)
	{
      (#tab)if (this != &from) {
      (#tab)(#tab)CopyFrom(from);
      (#tab)}
      (#tab)return *this;
	}
	(#blank)
	[#operatorLess(struct)]
	(#blank)
    [#codeNested (reuse.; useFullName; struct; fields; imports)](#brk)
	[#codeNested (copy.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;  useFullName; struct; fields; imports)](#brk)
	[#codeNested (write.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.; useFullName; struct; fields; imports)](#brk)
	[#codeGetters(struct; fields)]
	[#codeSetters(struct; fields)] ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.self"><![CDATA[&]]></template>
  <template key="struct.field"><![CDATA[
	(#tab) (#type) (#name) = (#value);(#doc)(#brk)]]></template>
  <template key="struct.field.del"><![CDATA[
    (#brk)(#tab)if ((#name) != (#null)) {
    (#tab)(#tab)delete (#name);
    (#tab)(#tab)(#name) = (#null);
    (#tab)}]]></template>
  <template key="struct.setter"><![CDATA[
	(#typeupper)& (#typeupper)::Set[#upperHeadChar( (#name) )] ((#const)(#type) (#spec)value_)
	{
	(#tab)[#codeSetterBody(fields; (#index); value_)]
	(#tab)return *this;
	}
  ]]></template>
  <template key="struct.getter"><![CDATA[
	(#const)(#type)(#spec) (#typeupper)::Get[#upperHeadChar( (#name) )] (void)(#constblock)
	{
	(#tab)return (#name);
	}
  ]]></template>
  <template key="less.method"><![CDATA[
    bool (#type)::operator < (const (#type) &other) const
    {
    (#body)
    }]]></template>
  <template key="less.body.key"> <![CDATA[(#tab)return key < other.key;]]></template>
  <template key="less.body.deft"><![CDATA[(#tab)return false;]]></template>

  <!-- Method Reuse -->
  <template key="reuse.method.arg"><![CDATA[]]></template>
  <template key="reuse.method"><![CDATA[ (#type)& (#type)::Reuse (void)
    {(#body)
    (#tab)return *this;
    } //(#type)::Reuse() ]]></template>
  <template key="reuse.any">   <![CDATA[ [#clampLen(lenFieldName; 16; (#name))] = (#deft) ]]></template>
  <template key="reuse.struct"><![CDATA[ (#name)(#invoke)Reuse() ]]></template>
  <template key="reuse.vec">   <![CDATA[ (#name)(#invoke)clear() ]]></template>
  <template key="reuse.map">   <![CDATA[ (#name)(#invoke)clear() ]]></template>
  <template key="reuse.ref.any"><![CDATA[ (#body); ]]></template>
  <template key="reuse.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)*(#name) = (#deft);
    }
  ]]></template>
  <template key="reuse.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }
  ]]></template>
  <template key="reuse.ptr.vec"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }
  ]]></template>
  <template key="reuse.ptr.map"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }
  ]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[from]]></template>
  <template key="copy.method"><![CDATA[
    (#type)& (#type)::CopyFrom (const (#type) &from)
    {
      (#tab)if (this == &from) {
      (#tab)(#tab)return *this;
      (#tab)}(#body)
      (#tab)return *this;
    } //(#type)::CopyFrom(...)]]></template>
  <template key="copy.any"><![CDATA[ (#arg)(#split)(#name) ]]></template>
  <template key="copy.nest.n"><![CDATA[ const (#type) &(#name) = (#arg)_(#nameupper)[(#index)]; ]]></template>
  <template key="copy.nest.k"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->first; ]]></template>
  <template key="copy.nest.v"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->second; ]]></template>
  <template key="copy.vec.head"><![CDATA[(#type) &(#name) = ((#specupper)(#nameupper))[(#indexupper)];
    const (#type) &(#arg)_(#name) = (#arg)_(#nameupper)[(#indexupper)];(#brk)]]></template>
  <template key="copy.vec.for"><![CDATA[
    (#sizetype) (#len) = static_cast<(#sizetype)>((#arg)_(#name).size());
    (#name)(#invoke)reserve((#len));
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name)(#invoke)push_back((#value));
    }
  ]]></template>
  <template key="copy.map.head.k"><![CDATA[(#type) (#name);
  	const (#type) &(#arg)_(#name) = (#nameupper)Iter->first; //copy.map.head.k
  ]]></template>
  <template key="copy.map.head.v"><![CDATA[(#type) (#name);
  	const (#type) &(#arg)_(#name) = (#nameupper)Iter->second; //copy.map.head.v
  ]]></template>
  <template key="copy.map.for"><![CDATA[
    (#name)(#invoke)clear();
    (#type)::const_iterator (#name)Iter = (#arg)_(#name).begin();
    (#type)::const_iterator (#name)IEnd = (#arg)_(#name).end();
    while ((#name)Iter != (#name)IEnd) {(#body)
    (#tab)(#name)(#invoke)insert((#type)::value_type((#key), (#value)));
    (#tab)++(#name)Iter;
    }
  ]]></template>
  <template key="copy.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="copy.ref.vec"><![CDATA[ const (#type) &(#arg)_(#name) = (#arg).(#name);
    (#body) ]]></template>
  <template key="copy.ref.map"><![CDATA[ const (#type) &(#arg)_(#name) = (#arg).(#name);
    (#body) ]]></template>
  <template key="copy.ptr.any"><![CDATA[ CheckSet< (#type) > ((#name), (#arg).(#name));  ]]></template>
  <template key="copy.ptr.string"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).(#name) != (#null))) {
    (#tab)*(#name) = *(#body);
    }
  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).(#name) != (#null))) {
    (#tab)(#name)->CopyFrom(*(#body));
    }
  ]]></template>
  <template key="copy.ptr.vec"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).(#name) != (#null))) {
    (#tab)const (#type) &(#arg)_(#name) = *(#arg).(#name);(#bodyindent)
    }
  ]]></template>
  <template key="copy.ptr.map"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).(#name) != (#null))) {
    (#tab)const (#type) &(#arg)_(#name) = *(#arg).(#name);(#bodyindent)
    }
  ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[invar::BinaryReader]]></template>
  <template key="read.method.arg"><![CDATA[from]]></template>
  <template key="read.method"><![CDATA[
    (#type)& (#type)::Read (const BinaryReader &from)
    {(#body)
    (#tab)return *this;
    } //(#type)::Decode(...)]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).ReadByte()    ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).ReadInt16()   ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).ReadInt32()   ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).ReadInt64()   ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).ReadUByte()   ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).ReadUInt16()  ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).ReadUInt32()  ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).ReadUInt64()  ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).ReadSingle()  ]]></template>
  <template key="read.double"><![CDATA[ (#arg).ReadDouble()  ]]></template>
  <template key="read.string"><![CDATA[ (#arg).ReadString()  ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).ReadBoolean() ]]></template>
  <template key="read.enum">  <![CDATA[ static_cast<(#type)>((#arg).ReadInt32()) ]]></template>
  <template key="read.struct"><![CDATA[ (#name)(#invoke)Read((#arg)) ]]></template>
  <template key="read.nest.n">       <![CDATA[ ((#specupper)(#nameupper))[(#index)] = (#body); ]]></template>
  <template key="read.nest.k">       <![CDATA[ const (#type) &(#name) = (#body); ]]></template>
  <template key="read.nest.v">       <![CDATA[ const (#type) &(#name) = (#body); ]]></template>
  <template key="read.nest.n.struct"><![CDATA[ (#type) &(#name) = (#nameupper)[(#index)]; (#body); ]]></template>
  <template key="read.nest.k.struct"><![CDATA[ (#type) (#name); (#body); ]]></template>
  <template key="read.nest.v.struct"><![CDATA[ (#type) (#name); (#body); ]]></template>
  <template key="read.vec.head">  <![CDATA[(#type) &(#name) = ((#specupper)(#nameupper))[(#indexupper)]; //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    (#name)(#invoke)resize((#len));
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[(#type) (#name);(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    (#name)(#invoke)clear();
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name)(#invoke)insert((#type)::value_type((#key),(#value)));
    }
  ]]></template>
  <template key="read.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.vec"><![CDATA[ (#body) ]]></template>
  <template key="read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.any"><![CDATA[ CheckSet< (#type) > ((#name), (#body)); ]]></template>
  <template key="read.ptr.string"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).ReadByte() == (#byteyes))) {
    (#tab)*(#name) = (#body);
    }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).ReadByte() == (#byteyes))) {
    (#tab)(#body);
    }
  ]]></template>
  <template key="read.ptr.vec"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).ReadByte() == (#byteyes))) {(#bodyindent)
    }
  ]]></template>
  <template key="read.ptr.map"><![CDATA[
    if (NewOrDel< (#type) > ((#name), (#arg).ReadByte() == (#byteyes))) {(#bodyindent)
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[ invar::BinaryReader ]]></template>
  <template key="write.method.arg"><![CDATA[dest]]></template>
  <template key="write.method"><![CDATA[ void (#type)::Write (BinaryWriter &dest) const
    {(#body)(#brk)} //(#type)::Encode(...) ]]></template>
  <template key="write.int8">  <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int16"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int32"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int64"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint8"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint16"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint32"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint64"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.float"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.double"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.string"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.bool">  <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).Write(static_cast<int32_t>((#spec)(#name))); ]]></template>
  <template key="write.struct"><![CDATA[ (#name)(#invoke)Write((#arg)); ]]></template>
  <template key="write.nest.n"><![CDATA[ const (#type) &(#name) = *(#nameupper)Iter; (#body) ]]></template>
  <template key="write.nest.k"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->first;  (#body) ]]></template>
  <template key="write.nest.v"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->second; (#body) ]]></template>
  <template key="write.vec.head">  <![CDATA[ const (#type) &(#name) = *(#nameupper)Iter;(#brk) ]]></template>
  <template key="write.vec.for"><![CDATA[
    (#arg).Write(static_cast<(#sizetype)>((#name)(#invoke)size()));
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IEnd) {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
  <template key="write.map.head.k"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->first;(#brk)]]></template>
  <template key="write.map.head.v"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->second;(#brk)]]></template>
  <template key="write.map.for"><![CDATA[
    (#arg).Write(static_cast<(#sizetype)>((#name)(#invoke)size()));
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IEnd) {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
  <template key="write.ptr.any"><![CDATA[
    (#arg).Write((#name) != (#null) ? (#spec)(#name) : static_cast<(#type)>((#deft)));
  ]]></template>
  <template key="write.ptr.string"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));(#bodyindent);
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>


  <!-- To XML String -->
  <template key="toxml.import"><![CDATA[std::string]]></template>
  <template key="toxml.method.arg"><![CDATA[name]]></template>
  <template key="toxml.method"><![CDATA[ void (#type)::ToXmlString (const string &name, string &result) const
    {
    (#tab)string attrs;
    (#tab)string nodes;(#body)
    (#tab)result.append("<"); result.append(name); result.append(attrs);
    (#tab)if (nodes.compare("") == 0) {
    (#tab)(#tab)result.append("/>");
    (#tab)} else {
    (#tab)(#tab)result.append(">");
    (#tab)(#tab)result.append(nodes);
    (#tab)(#tab)result.append("</"); result.append(name); result.append(">");
    (#tab)}
    } //(#type)::ToXmlString(...) ]]></template>
  <template key="toxml.int8">  <![CDATA[ std::to_string(static_cast<int>((#spec)(#name))) ]]></template>
  <template key="toxml.int16"> <![CDATA[ std::to_string(static_cast<int>((#spec)(#name))) ]]></template>
  <template key="toxml.int32"> <![CDATA[ std::to_string((#spec)(#name)) ]]></template>
  <template key="toxml.int64"> <![CDATA[ std::to_string(static_cast<long long>((#spec)(#name))) ]]></template>
  <template key="toxml.uint8"> <![CDATA[ std::to_string(static_cast<unsigned>((#spec)(#name)))  ]]></template>
  <template key="toxml.uint16"><![CDATA[ std::to_string(static_cast<unsigned>((#spec)(#name))) ]]></template>
  <template key="toxml.uint32"><![CDATA[ std::to_string((#spec)(#name)) ]]></template>
  <template key="toxml.uint64"><![CDATA[ std::to_string(static_cast<unsigned long long>((#spec)(#name))) ]]></template>
  <template key="toxml.float"> <![CDATA[ std::to_string((#spec)(#name)) ]]></template>
  <template key="toxml.double"><![CDATA[ std::to_string((#spec)(#name)) ]]></template>
  <template key="toxml.bool">  <![CDATA[ (#spec)(#name) ? "true" : "false" ]]></template>
  <template key="toxml.enum">  <![CDATA[ std::to_string(static_cast<int32_t>((#spec)(#name))) ]]></template>
  <template key="toxml.string"><![CDATA[ (#spec)(#name) ]]></template>
  <template key="toxml.struct"><![CDATA[ ((#spec)(#name)).ToXmlString("(#name)", nodes) ]]></template>
  <template key="toxml.nest.n"><![CDATA[ const (#type) &(#name) = *(#nameupper)Iter;
    nodes.append("<(#name) value=\\"");
    nodes.append((#body)); nodes.append("\\">"); ]]></template>
  <template key="toxml.nest.k"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->first;
    nodes.append("<(#name) value=\\"");
    nodes.append((#body)); nodes.append("\\">"); ]]></template>
  <template key="toxml.nest.v"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->second;
    nodes.append("<(#name) value=\\"");
    nodes.append((#body)); nodes.append("\\">"); ]]></template>
  <template key="toxml.nest.n.struct"><![CDATA[ const (#type) &(#name) = *(#nameupper)Iter;(#brk)(#body); ]]></template>
  <template key="toxml.nest.k.struct"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->first;(#brk)(#body); ]]></template>
  <template key="toxml.nest.v.struct"><![CDATA[ const (#type) &(#name) = (#nameupper)Iter->second;(#brk)(#body); ]]></template>
  <template key="toxml.vec.head"><![CDATA[ const (#type) &(#name) = *(#nameupper)Iter;(#brk) ]]></template>
  <template key="toxml.vec.for"><![CDATA[
    nodes.append("<(#name)>");
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IEnd) {(#body)
    (#tab)++(#name)Iter;
    }
    nodes.append("</(#name)>");
  ]]></template>
  <template key="toxml.map.head.k"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->first;(#brk)]]></template>
  <template key="toxml.map.head.v"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->second;(#brk)]]></template>
  <template key="toxml.map.for"><![CDATA[
    nodes.append("<(#name)>");
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IEnd) {(#body)
    (#tab)++(#name)Iter;
    }
    nodes.append("</(#name)>");
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[ attrs.append(" (#name)=\\"");
    attrs.append((#body)); attrs.append("\\""); ]]></template>
  <template key="toxml.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if ((#name).size() > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)attrs.append(" (#name)=\\"");
    (#tab)attrs.append((#body)); attrs.append("\\"");
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if ((#name) != (#null) && (#name)->size() > 0) {(#bodyindent)
    }]]></template>
</tns:root>