<?php
/*===----------------------------*  PHP 5  *-------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/

namespace test\xyz;

require_once dirname(__FILE__) . '/../../invar/invar.codec.php';
require_once dirname(__FILE__) . '/../../test/abc/Conflict.php';
require_once dirname(__FILE__) . '/../../test/abc/Gender.php';
require_once dirname(__FILE__) . '/../../test/abc/Info.php';
require_once dirname(__FILE__) . '/../../test/xyz/Conflict.php';

use \invar\BinaryReader;
use \invar\BinaryWriter;
use \test\abc\Gender;
use \test\abc\Info;

final class InfoX
{
    const CRC32 = 0xF55867E1;

    static public function &CreateFromBytes (& $str)
    {
        $o = new InfoX;
        $o->read(new BinaryReader($str));
        return $o;
    }

    private $infos      ;/* 0 vec<vec<vec<vec<vec<test.abc.Info>>>>> */
    private $conflict_x ;/* 1 test.xyz.Conflict // Two types with the same name. */
    private $conflict_a ;/* 2 test.abc.Conflict // Two types with the same name. */
    private $mConflict  ;/* 3 map<int32,test.abc.Conflict> */
    private $info2d     ;/* 4 vec<vec<test.abc.Info>> // 2 dimension list */
    private $info3d     ;/* 5 vec<vec<vec<test.abc.Info>>> // 3 dimension list */
    private $info5d     ;/* 6 vec<vec<vec<vec<vec<test.abc.Info>>>>> */
    private $infovm     ;/* 7 vec<map<int16,test.abc.Info>> */
    private $mvei       ;/* 8 map<vec<test.abc.Gender>,test.abc.Info> */
    private $mive       ;/* 9 map<test.abc.Info,vec<test.abc.Gender>> */
    private $mvive      ;/* 10 map<vec<test.abc.Info>,vec<test.abc.Gender>> */
    private $vmvive     ;/* 11 vec<map<vec<test.abc.Info>,vec<test.abc.Gender>>> */
    private $hotfix     ;/* 12 map<string,string> // [AutoAdd] Hotfix */

    function __construct()
    {
        $this->infos      = array();
        $this->conflict_x = new test\xyz\Conflict;
        $this->conflict_a = new test\abc\Conflict;
        $this->mConflict  = array();
        $this->info2d     = array();
        $this->info3d     = array();
        $this->info5d     = array();
        $this->infovm     = array();
        $this->mvei       = array();
        $this->mive       = array();
        $this->mvive      = array();
        $this->vmvive     = array();
        $this->hotfix     = NULL;
    }
    /* End of constructor() */

    public function &copy (& $from)
    {
        if ($this == $from || $from == NULL) {
            return this;
        }
        if ($from->infos != NULL) {
            $this->infos = array_merge($from->infos);
        } else {
            $this->infos = array();
        }
        $this->conflict_x = $from->conflict_x;
        $this->conflict_a = $from->conflict_a;
        if ($from->mConflict != NULL) {
            $this->mConflict = array_merge($from->mConflict);
        } else {
            $this->mConflict = array();
        }
        if ($from->info2d != NULL) {
            $this->info2d = array_merge($from->info2d);
        } else {
            $this->info2d = array();
        }
        if ($from->info3d != NULL) {
            $this->info3d = array_merge($from->info3d);
        } else {
            $this->info3d = array();
        }
        if ($from->info5d != NULL) {
            $this->info5d = array_merge($from->info5d);
        } else {
            $this->info5d = array();
        }
        if ($from->infovm != NULL) {
            $this->infovm = array_merge($from->infovm);
        } else {
            $this->infovm = array();
        }
        if ($from->mvei != NULL) {
            $this->mvei = array_merge($from->mvei);
        } else {
            $this->mvei = array();
        }
        if ($from->mive != NULL) {
            $this->mive = array_merge($from->mive);
        } else {
            $this->mive = array();
        }
        if ($from->mvive != NULL) {
            $this->mvive = array_merge($from->mvive);
        } else {
            $this->mvive = array();
        }
        if ($from->vmvive != NULL) {
            $this->vmvive = array_merge($from->vmvive);
        } else {
            $this->vmvive = array();
        }
        if ($from->hotfix != NULL) {
            $this->hotfix = array();
            $this->hotfix = array_merge($from->hotfix);
        } else {
            $this->hotfix = NULL;
        }
        return $this;
    }
    /* End of copy(...) */

    public function &read (& $r)
    {
        $this->infos = array();
        $lenInfos = $r->readUInt32();
        for ($iInfos = 0; $iInfos < $lenInfos; ++$iInfos) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $n2 = array(); //read.vec.head
                $lenN2 = $r->readUInt32();
                for ($iN2 = 0; $iN2 < $lenN2; ++$iN2) {
                    $n3 = array(); //read.vec.head
                    $lenN3 = $r->readUInt32();
                    for ($iN3 = 0; $iN3 < $lenN3; ++$iN3) {
                        $n4 = array(); //read.vec.head
                        $lenN4 = $r->readUInt32();
                        for ($iN4 = 0; $iN4 < $lenN4; ++$iN4) {
                            $n5 = new Info();
                            $n5->read($r);
                            $n4[] = $n5;
                        }
                        $n3[] = $n4;
                    }
                    $n2[] = $n3;
                }
                $n1[] = $n2;
            }
            $this->infos[] = $n1;
        }
        $this->conflict_x->read($r);
        $this->conflict_a->read($r);
        $this->mConflict = array();
        $lenMConflict = $r->readUInt32();
        for ($iMConflict = 0; $iMConflict < $lenMConflict; ++$iMConflict) {
            $k1 = $r->readInt32();
            $v1 = new testabcConflict();
            $v1->read($r);
            $this->mConflict[$k1] = $v1;
        }
        $this->info2d = array();
        $lenInfo2d = $r->readUInt32();
        for ($iInfo2d = 0; $iInfo2d < $lenInfo2d; ++$iInfo2d) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $n2 = new Info();
                $n2->read($r);
                $n1[] = $n2;
            }
            $this->info2d[] = $n1;
        }
        $this->info3d = array();
        $lenInfo3d = $r->readUInt32();
        for ($iInfo3d = 0; $iInfo3d < $lenInfo3d; ++$iInfo3d) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $n2 = array(); //read.vec.head
                $lenN2 = $r->readUInt32();
                for ($iN2 = 0; $iN2 < $lenN2; ++$iN2) {
                    $n3 = new Info();
                    $n3->read($r);
                    $n2[] = $n3;
                }
                $n1[] = $n2;
            }
            $this->info3d[] = $n1;
        }
        $this->info5d = array();
        $lenInfo5d = $r->readUInt32();
        for ($iInfo5d = 0; $iInfo5d < $lenInfo5d; ++$iInfo5d) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $n2 = array(); //read.vec.head
                $lenN2 = $r->readUInt32();
                for ($iN2 = 0; $iN2 < $lenN2; ++$iN2) {
                    $n3 = array(); //read.vec.head
                    $lenN3 = $r->readUInt32();
                    for ($iN3 = 0; $iN3 < $lenN3; ++$iN3) {
                        $n4 = array(); //read.vec.head
                        $lenN4 = $r->readUInt32();
                        for ($iN4 = 0; $iN4 < $lenN4; ++$iN4) {
                            $n5 = new Info();
                            $n5->read($r);
                            $n4[] = $n5;
                        }
                        $n3[] = $n4;
                    }
                    $n2[] = $n3;
                }
                $n1[] = $n2;
            }
            $this->info5d[] = $n1;
        }
        $this->infovm = array();
        $lenInfovm = $r->readUInt32();
        for ($iInfovm = 0; $iInfovm < $lenInfovm; ++$iInfovm) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $k2 = $r->readInt16();
                $v2 = new Info();
                $v2->read($r);
                $n1[$k2] = $v2;
            }
            $this->infovm[] = $n1;
        }
        $this->mvei = array();
        $lenMvei = $r->readUInt32();
        for ($iMvei = 0; $iMvei < $lenMvei; ++$iMvei) {
            $k1 = array(); //read.map.head
            $lenK1 = $r->readUInt32();
            for ($iK1 = 0; $iK1 < $lenK1; ++$iK1) {
                $n2 = $r->readInt32();
                $k1[] = $n2;
            }
            $v1 = new Info();
            $v1->read($r);
            $this->mvei[$k1] = $v1;
        }
        $this->mive = array();
        $lenMive = $r->readUInt32();
        for ($iMive = 0; $iMive < $lenMive; ++$iMive) {
            $k1 = new Info();
            $k1->read($r);
            $v1 = array(); //read.map.head
            $lenV1 = $r->readUInt32();
            for ($iV1 = 0; $iV1 < $lenV1; ++$iV1) {
                $n2 = $r->readInt32();
                $v1[] = $n2;
            }
            $this->mive[$k1] = $v1;
        }
        $this->mvive = array();
        $lenMvive = $r->readUInt32();
        for ($iMvive = 0; $iMvive < $lenMvive; ++$iMvive) {
            $k1 = array(); //read.map.head
            $lenK1 = $r->readUInt32();
            for ($iK1 = 0; $iK1 < $lenK1; ++$iK1) {
                $n2 = new Info();
                $n2->read($r);
                $k1[] = $n2;
            }
            $v1 = array(); //read.map.head
            $lenV1 = $r->readUInt32();
            for ($iV1 = 0; $iV1 < $lenV1; ++$iV1) {
                $n2 = $r->readInt32();
                $v1[] = $n2;
            }
            $this->mvive[$k1] = $v1;
        }
        $this->vmvive = array();
        $lenVmvive = $r->readUInt32();
        for ($iVmvive = 0; $iVmvive < $lenVmvive; ++$iVmvive) {
            $n1 = array(); //read.vec.head
            $lenN1 = $r->readUInt32();
            for ($iN1 = 0; $iN1 < $lenN1; ++$iN1) {
                $k2 = array(); //read.map.head
                $lenK2 = $r->readUInt32();
                for ($iK2 = 0; $iK2 < $lenK2; ++$iK2) {
                    $n3 = new Info();
                    $n3->read($r);
                    $k2[] = $n3;
                }
                $v2 = array(); //read.map.head
                $lenV2 = $r->readUInt32();
                for ($iV2 = 0; $iV2 < $lenV2; ++$iV2) {
                    $n3 = $r->readInt32();
                    $v2[] = $n3;
                }
                $n1[$k2] = $v2;
            }
            $this->vmvive[] = $n1;
        }
        $hotfixExists = $r->readInt08();
        if (0x01 == $hotfixExists) {
            if ($this->hotfix == NULL) { $this->hotfix = array(); }
            $lenHotfix = $r->readUInt32();
            for ($iHotfix = 0; $iHotfix < $lenHotfix; ++$iHotfix) {
                $k1 = $r->readUTF();
                $v1 = $r->readUTF();
                $this->hotfix[$k1] = $v1;
            }
        }
        else if (0x00 == $hotfixExists) { $this->hotfix = NULL; }
        else { throw new \Exception('Protoc read error: The value of ' . $hotfixExists . ' is invalid.', 498); }
        return $this;
    }
    /* End of read(...) */

    public function write (& $str)
    {
        BinaryWriter::writeInt32(count($this->infos), $str);
        foreach ($this->infos as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as &$n2) {
                BinaryWriter::writeInt32(count($n2), $str);
                foreach ($n2 as &$n3) {
                    BinaryWriter::writeInt32(count($n3), $str);
                    foreach ($n3 as &$n4) {
                        BinaryWriter::writeInt32(count($n4), $str);
                        foreach ($n4 as &$n5) {
                            $n5->write($str);
                        }
                    }
                }
            }
        }
        $this->conflict_x->write($str);
        $this->conflict_a->write($str);
        BinaryWriter::writeInt32(count($this->mConflict), $str);
        foreach ($this->mConflict as $k1 => &$v1) {
            BinaryWriter::writeInt32($k1, $str);
            $v1->write($str);
        }
        BinaryWriter::writeInt32(count($this->info2d), $str);
        foreach ($this->info2d as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as &$n2) {
                $n2->write($str);
            }
        }
        BinaryWriter::writeInt32(count($this->info3d), $str);
        foreach ($this->info3d as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as &$n2) {
                BinaryWriter::writeInt32(count($n2), $str);
                foreach ($n2 as &$n3) {
                    $n3->write($str);
                }
            }
        }
        BinaryWriter::writeInt32(count($this->info5d), $str);
        foreach ($this->info5d as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as &$n2) {
                BinaryWriter::writeInt32(count($n2), $str);
                foreach ($n2 as &$n3) {
                    BinaryWriter::writeInt32(count($n3), $str);
                    foreach ($n3 as &$n4) {
                        BinaryWriter::writeInt32(count($n4), $str);
                        foreach ($n4 as &$n5) {
                            $n5->write($str);
                        }
                    }
                }
            }
        }
        BinaryWriter::writeInt32(count($this->infovm), $str);
        foreach ($this->infovm as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as $k2 => &$v2) {
                BinaryWriter::writeInt16($k2, $str);
                $v2->write($str);
            }
        }
        BinaryWriter::writeInt32(count($this->mvei), $str);
        foreach ($this->mvei as $k1 => &$v1) {
            BinaryWriter::writeInt32(count($k1), $str);
            foreach ($k1 as &$n2) {
                BinaryWriter::writeInt32($n2, $str);
            }
            $v1->write($str);
        }
        BinaryWriter::writeInt32(count($this->mive), $str);
        foreach ($this->mive as $k1 => &$v1) {
            $k1->write($str);
            BinaryWriter::writeInt32(count($v1), $str);
            foreach ($v1 as &$n2) {
                BinaryWriter::writeInt32($n2, $str);
            }
        }
        BinaryWriter::writeInt32(count($this->mvive), $str);
        foreach ($this->mvive as $k1 => &$v1) {
            BinaryWriter::writeInt32(count($k1), $str);
            foreach ($k1 as &$n2) {
                $n2->write($str);
            }
            BinaryWriter::writeInt32(count($v1), $str);
            foreach ($v1 as &$n2) {
                BinaryWriter::writeInt32($n2, $str);
            }
        }
        BinaryWriter::writeInt32(count($this->vmvive), $str);
        foreach ($this->vmvive as &$n1) {
            BinaryWriter::writeInt32(count($n1), $str);
            foreach ($n1 as $k2 => &$v2) {
                BinaryWriter::writeInt32(count($k2), $str);
                foreach ($k2 as &$n3) {
                    $n3->write($str);
                }
                BinaryWriter::writeInt32(count($v2), $str);
                foreach ($v2 as &$n3) {
                    BinaryWriter::writeInt32($n3, $str);
                }
            }
        }
        if ($this->hotfix != NULL) {
            BinaryWriter::writeInt08(0x01, $str);
            BinaryWriter::writeInt32(count($this->hotfix), $str);
            foreach ($this->hotfix as $k1 => &$v1) {
                BinaryWriter::writeUTF($k1, $str);
                BinaryWriter::writeUTF($v1, $str);
            }
        } else {
            BinaryWriter::writeInt08(0x00, $str);
        }
    }
    /* End of write(...) */

    /**  */
    public function &getInfos() { return $this->infos; }

    /** Two types with the same name. */
    public function &getConflict_x() { return $this->conflict_x; }

    /** Two types with the same name. */
    public function &getConflict_a() { return $this->conflict_a; }

    /**  */
    public function &getMConflict() { return $this->mConflict; }

    /** 2 dimension list */
    public function &getInfo2d() { return $this->info2d; }

    /** 3 dimension list */
    public function &getInfo3d() { return $this->info3d; }

    /**  */
    public function &getInfo5d() { return $this->info5d; }

    /**  */
    public function &getInfovm() { return $this->infovm; }

    /**  */
    public function &getMvei() { return $this->mvei; }

    /**  */
    public function &getMive() { return $this->mive; }

    /**  */
    public function &getMvive() { return $this->mvive; }

    /**  */
    public function &getVmvive() { return $this->vmvive; }

    /** [AutoAdd] Hotfix */
    public function getHotfix() { return $this->hotfix; }

    /** Two types with the same name. */
    public function setConflict_x($value) { $this->conflict_x = $value; return $this; }

    /** Two types with the same name. */
    public function setConflict_a($value) { $this->conflict_a = $value; return $this; }

    /** [AutoAdd] Hotfix */
    public function setHotfix($value) { $this->hotfix = $value; return $this; }

    public function &toString()
    {
        $s  = '{'; $s .= get_class($this);
        $s .= ','; $s .= 'infos'; $s .= ':';
        $s .= '('; $s .= count($this->infos); $s .= ')';
        $s .= ','; $s .= 'conflict_x'; $s .= ':';
        $s .= '<'; $s .= 'testxyzConflict'; $s .= '>';
        $s .= ','; $s .= 'conflict_a'; $s .= ':';
        $s .= '<'; $s .= 'testabcConflict'; $s .= '>';
        $s .= ','; $s .= 'mConflict'; $s .= ':';
        $s .= '['; $s .= count($this->mConflict); $s .= ']';
        $s .= ','; $s .= 'info2d'; $s .= ':';
        $s .= '('; $s .= count($this->info2d); $s .= ')';
        $s .= ','; $s .= 'info3d'; $s .= ':';
        $s .= '('; $s .= count($this->info3d); $s .= ')';
        $s .= ','; $s .= 'info5d'; $s .= ':';
        $s .= '('; $s .= count($this->info5d); $s .= ')';
        $s .= ','; $s .= 'infovm'; $s .= ':';
        $s .= '('; $s .= count($this->infovm); $s .= ')';
        $s .= ','; $s .= 'mvei'; $s .= ':';
        $s .= '['; $s .= count($this->mvei); $s .= ']';
        $s .= ','; $s .= 'mive'; $s .= ':';
        $s .= '['; $s .= count($this->mive); $s .= ']';
        $s .= ','; $s .= 'mvive'; $s .= ':';
        $s .= '['; $s .= count($this->mvive); $s .= ']';
        $s .= ','; $s .= 'vmvive'; $s .= ':';
        $s .= '('; $s .= count($this->vmvive); $s .= ')';
        $s .= ','; $s .= 'hotfix'; $s .= ':';
        if (isset($this->hotfix)) { $s .= '['; $s .= count($this->hotfix); $s .= ']'; }
        else { $s .= 'null'; }
        $s .= '}';
        return $s;
    }
    /* End of toString() */

    public function &toStringJSON()
    {
        $code = '';
        $this->writeJSON($code);
        return $code;
    }

    public function writeJSON(& $s)
    {
        $s .= "\n"; $s .= '{';
        $infosExists = (isset($this->infos) && count($this->infos) > 0);
        if ($infosExists) {
            $s .= '"'; $s .= 'infos'; $s .= '"'; $s .= ':'; $comma = ',';
            $infosSize = (!isset($this->infos) ? 0 : count($this->infos));
            $s .= "\n"; $s .= '[';
            $infosIdx = 0;
            foreach ($this->infos as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '[';
                $n1Idx = 0;
                foreach ($n1 as &$n2) {
                    $n2Size = (!isset($n2) ? 0 : count($n2));
                    $s .= "\n"; $s .= '[';
                    $n2Idx = 0;
                    foreach ($n2 as &$n3) {
                        $n3Size = (!isset($n3) ? 0 : count($n3));
                        $s .= "\n"; $s .= '[';
                        $n3Idx = 0;
                        foreach ($n3 as &$n4) {
                            $n4Size = (!isset($n4) ? 0 : count($n4));
                            $s .= "\n"; $s .= '[';
                            $n4Idx = 0;
                            foreach ($n4 as &$n5) {
                                $n5->writeJSON($s);
                                ++$n4Idx;
                                if ($n4Idx != $n4Size) { $s .= ','; }
                            }
                            $s .= ']';
                            ++$n3Idx;
                            if ($n3Idx != $n3Size) { $s .= ','; }
                        }
                        $s .= ']';
                        ++$n2Idx;
                        if ($n2Idx != $n2Size) { $s .= ','; }
                    }
                    $s .= ']';
                    ++$n1Idx;
                    if ($n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$infosIdx;
                if ($infosIdx != $infosSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $conflict_xExists = isset($this->conflict_x);
        if (!empty($comma) && $conflict_xExists) { $s .= $comma; $comma = ''; }
        if ($conflict_xExists) {
            $s .= '"'; $s .= 'conflict_x'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->conflict_x->writeJSON($s);
        }
        $conflict_aExists = isset($this->conflict_a);
        if (!empty($comma) && $conflict_aExists) { $s .= $comma; $comma = ''; }
        if ($conflict_aExists) {
            $s .= '"'; $s .= 'conflict_a'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->conflict_a->writeJSON($s);
        }
        $mConflictExists = (isset($this->mConflict) && count($this->mConflict) > 0);
        if (!empty($comma) && $mConflictExists) { $s .= $comma; $comma = ''; }
        if ($mConflictExists) {
            $s .= '"'; $s .= 'mConflict'; $s .= '"'; $s .= ':'; $comma = ',';
            $mConflictSize = (!isset($this->mConflict) ? 0 : count($this->mConflict));
            $s .= "\n"; $s .= '{';
            $mConflictIdx = 0;
            foreach ($this->mConflict as $k1 => &$v1) {
                $s .= $k1;
                $v1->writeJSON($s);
                ++$mConflictIdx;
                if (mConflictIdx != $mConflictSize) { $s .= ','; }
            }
            $s .= '}';
        }
        $info2dExists = (isset($this->info2d) && count($this->info2d) > 0);
        if (!empty($comma) && $info2dExists) { $s .= $comma; $comma = ''; }
        if ($info2dExists) {
            $s .= '"'; $s .= 'info2d'; $s .= '"'; $s .= ':'; $comma = ',';
            $info2dSize = (!isset($this->info2d) ? 0 : count($this->info2d));
            $s .= "\n"; $s .= '[';
            $info2dIdx = 0;
            foreach ($this->info2d as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '[';
                $n1Idx = 0;
                foreach ($n1 as &$n2) {
                    $n2->writeJSON($s);
                    ++$n1Idx;
                    if ($n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$info2dIdx;
                if ($info2dIdx != $info2dSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $info3dExists = (isset($this->info3d) && count($this->info3d) > 0);
        if (!empty($comma) && $info3dExists) { $s .= $comma; $comma = ''; }
        if ($info3dExists) {
            $s .= '"'; $s .= 'info3d'; $s .= '"'; $s .= ':'; $comma = ',';
            $info3dSize = (!isset($this->info3d) ? 0 : count($this->info3d));
            $s .= "\n"; $s .= '[';
            $info3dIdx = 0;
            foreach ($this->info3d as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '[';
                $n1Idx = 0;
                foreach ($n1 as &$n2) {
                    $n2Size = (!isset($n2) ? 0 : count($n2));
                    $s .= "\n"; $s .= '[';
                    $n2Idx = 0;
                    foreach ($n2 as &$n3) {
                        $n3->writeJSON($s);
                        ++$n2Idx;
                        if ($n2Idx != $n2Size) { $s .= ','; }
                    }
                    $s .= ']';
                    ++$n1Idx;
                    if ($n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$info3dIdx;
                if ($info3dIdx != $info3dSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $info5dExists = (isset($this->info5d) && count($this->info5d) > 0);
        if (!empty($comma) && $info5dExists) { $s .= $comma; $comma = ''; }
        if ($info5dExists) {
            $s .= '"'; $s .= 'info5d'; $s .= '"'; $s .= ':'; $comma = ',';
            $info5dSize = (!isset($this->info5d) ? 0 : count($this->info5d));
            $s .= "\n"; $s .= '[';
            $info5dIdx = 0;
            foreach ($this->info5d as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '[';
                $n1Idx = 0;
                foreach ($n1 as &$n2) {
                    $n2Size = (!isset($n2) ? 0 : count($n2));
                    $s .= "\n"; $s .= '[';
                    $n2Idx = 0;
                    foreach ($n2 as &$n3) {
                        $n3Size = (!isset($n3) ? 0 : count($n3));
                        $s .= "\n"; $s .= '[';
                        $n3Idx = 0;
                        foreach ($n3 as &$n4) {
                            $n4Size = (!isset($n4) ? 0 : count($n4));
                            $s .= "\n"; $s .= '[';
                            $n4Idx = 0;
                            foreach ($n4 as &$n5) {
                                $n5->writeJSON($s);
                                ++$n4Idx;
                                if ($n4Idx != $n4Size) { $s .= ','; }
                            }
                            $s .= ']';
                            ++$n3Idx;
                            if ($n3Idx != $n3Size) { $s .= ','; }
                        }
                        $s .= ']';
                        ++$n2Idx;
                        if ($n2Idx != $n2Size) { $s .= ','; }
                    }
                    $s .= ']';
                    ++$n1Idx;
                    if ($n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$info5dIdx;
                if ($info5dIdx != $info5dSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $infovmExists = (isset($this->infovm) && count($this->infovm) > 0);
        if (!empty($comma) && $infovmExists) { $s .= $comma; $comma = ''; }
        if ($infovmExists) {
            $s .= '"'; $s .= 'infovm'; $s .= '"'; $s .= ':'; $comma = ',';
            $infovmSize = (!isset($this->infovm) ? 0 : count($this->infovm));
            $s .= "\n"; $s .= '[';
            $infovmIdx = 0;
            foreach ($this->infovm as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '{';
                $n1Idx = 0;
                foreach ($n1 as $k2 => &$v2) {
                    $s .= $k2;
                    $v2->writeJSON($s);
                    ++$n1Idx;
                    if (n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= '}';
                ++$infovmIdx;
                if ($infovmIdx != $infovmSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $mveiExists = (isset($this->mvei) && count($this->mvei) > 0);
        if (!empty($comma) && $mveiExists) { $s .= $comma; $comma = ''; }
        if ($mveiExists) {
            $s .= '"'; $s .= 'mvei'; $s .= '"'; $s .= ':'; $comma = ',';
            $mveiSize = (!isset($this->mvei) ? 0 : count($this->mvei));
            $s .= "\n"; $s .= '{';
            $mveiIdx = 0;
            foreach ($this->mvei as $k1 => &$v1) {
                $k1Size = (!isset($k1) ? 0 : count($k1));
                $s .= "\n"; $s .= '[';
                $k1Idx = 0;
                foreach ($k1 as &$n2) {
                    $s .= $n2;
                    ++$k1Idx;
                    if ($k1Idx != $k1Size) { $s .= ','; }
                }
                $s .= ']';
                $v1->writeJSON($s);
                ++$mveiIdx;
                if (mveiIdx != $mveiSize) { $s .= ','; }
            }
            $s .= '}';
        }
        $miveExists = (isset($this->mive) && count($this->mive) > 0);
        if (!empty($comma) && $miveExists) { $s .= $comma; $comma = ''; }
        if ($miveExists) {
            $s .= '"'; $s .= 'mive'; $s .= '"'; $s .= ':'; $comma = ',';
            $miveSize = (!isset($this->mive) ? 0 : count($this->mive));
            $s .= "\n"; $s .= '{';
            $miveIdx = 0;
            foreach ($this->mive as $k1 => &$v1) {
                $k1->writeJSON($s);
                $v1Size = (!isset($v1) ? 0 : count($v1));
                $s .= "\n"; $s .= '[';
                $v1Idx = 0;
                foreach ($v1 as &$n2) {
                    $s .= $n2;
                    ++$v1Idx;
                    if ($v1Idx != $v1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$miveIdx;
                if (miveIdx != $miveSize) { $s .= ','; }
            }
            $s .= '}';
        }
        $mviveExists = (isset($this->mvive) && count($this->mvive) > 0);
        if (!empty($comma) && $mviveExists) { $s .= $comma; $comma = ''; }
        if ($mviveExists) {
            $s .= '"'; $s .= 'mvive'; $s .= '"'; $s .= ':'; $comma = ',';
            $mviveSize = (!isset($this->mvive) ? 0 : count($this->mvive));
            $s .= "\n"; $s .= '{';
            $mviveIdx = 0;
            foreach ($this->mvive as $k1 => &$v1) {
                $k1Size = (!isset($k1) ? 0 : count($k1));
                $s .= "\n"; $s .= '[';
                $k1Idx = 0;
                foreach ($k1 as &$n2) {
                    $n2->writeJSON($s);
                    ++$k1Idx;
                    if ($k1Idx != $k1Size) { $s .= ','; }
                }
                $s .= ']';
                $v1Size = (!isset($v1) ? 0 : count($v1));
                $s .= "\n"; $s .= '[';
                $v1Idx = 0;
                foreach ($v1 as &$n2) {
                    $s .= $n2;
                    ++$v1Idx;
                    if ($v1Idx != $v1Size) { $s .= ','; }
                }
                $s .= ']';
                ++$mviveIdx;
                if (mviveIdx != $mviveSize) { $s .= ','; }
            }
            $s .= '}';
        }
        $vmviveExists = (isset($this->vmvive) && count($this->vmvive) > 0);
        if (!empty($comma) && $vmviveExists) { $s .= $comma; $comma = ''; }
        if ($vmviveExists) {
            $s .= '"'; $s .= 'vmvive'; $s .= '"'; $s .= ':'; $comma = ',';
            $vmviveSize = (!isset($this->vmvive) ? 0 : count($this->vmvive));
            $s .= "\n"; $s .= '[';
            $vmviveIdx = 0;
            foreach ($this->vmvive as &$n1) {
                $n1Size = (!isset($n1) ? 0 : count($n1));
                $s .= "\n"; $s .= '{';
                $n1Idx = 0;
                foreach ($n1 as $k2 => &$v2) {
                    $k2Size = (!isset($k2) ? 0 : count($k2));
                    $s .= "\n"; $s .= '[';
                    $k2Idx = 0;
                    foreach ($k2 as &$n3) {
                        $n3->writeJSON($s);
                        ++$k2Idx;
                        if ($k2Idx != $k2Size) { $s .= ','; }
                    }
                    $s .= ']';
                    $v2Size = (!isset($v2) ? 0 : count($v2));
                    $s .= "\n"; $s .= '[';
                    $v2Idx = 0;
                    foreach ($v2 as &$n3) {
                        $s .= $n3;
                        ++$v2Idx;
                        if ($v2Idx != $v2Size) { $s .= ','; }
                    }
                    $s .= ']';
                    ++$n1Idx;
                    if (n1Idx != $n1Size) { $s .= ','; }
                }
                $s .= '}';
                ++$vmviveIdx;
                if ($vmviveIdx != $vmviveSize) { $s .= ','; }
            }
            $s .= ']';
        }
        $hotfixExists = (isset($this->hotfix) && count($this->hotfix) > 0);
        if (!empty($comma) && $hotfixExists) { $s .= $comma; $comma = ''; }
        if ($hotfixExists) {
            $s .= '"'; $s .= 'hotfix'; $s .= '"'; $s .= ':'; $comma = ',';
            $hotfixSize = (!isset($this->hotfix) ? 0 : count($this->hotfix));
            $s .= "\n"; $s .= '{';
            $hotfixIdx = 0;
            foreach ($this->hotfix as $k1 => &$v1) {
                $s .= '"'; $s .= $k1; $s .= '"';
                $s .= '"'; $s .= $v1; $s .= '"';
                ++$hotfixIdx;
                if (hotfixIdx != $hotfixSize) { $s .= ','; }
            }
            $s .= '}';
        }
        $s .= '}'; $s .= "\n";
    }
    /* End of writeJSON(...) */

    public function &toStringXML()
    {
        $code  = '<?xml version="1.0" encoding="UTF-8"?>';
        $code .= "\n"; $code .= '<!-- '; $code .= 'InfoX'; $code .= '.CRC32: 0x';
        $code .= strtoupper(dechex(self::CRC32)); $code .= ' -->';
        $code .= "\n"; $this->writeXML($code, 'InfoX');
        return $code;
    }

    public function writeXML (& $s, $name)
    {
        $attrs = ''; $nodes = '';
        if (count($this->infos) > 0) {
            $nodes .= '<'; $nodes .= 'infos'; $nodes .= '>';
            foreach ($this->infos as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= '>';
                    foreach ($n2 as &$n3) {
                        $nodes .= '<'; $nodes .= 'n3'; $nodes .= '>';
                        foreach ($n3 as &$n4) {
                            $nodes .= '<'; $nodes .= 'n4'; $nodes .= '>';
                            foreach ($n4 as &$n5) {
                                $n5->writeXML($nodes, 'n5');
                            }
                            $nodes .= '</'; $nodes .= 'n4'; $nodes .= '>';
                        }
                        $nodes .= '</'; $nodes .= 'n3'; $nodes .= '>';
                    }
                    $nodes .= '</'; $nodes .= 'n2'; $nodes .= '>';
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'infos'; $nodes .= '>';
        }
        $this->conflict_x->writeXML($nodes, 'conflict_x');
        $this->conflict_a->writeXML($nodes, 'conflict_a');
        if (count($this->mConflict) > 0) {
            $nodes .= '<'; $nodes .= 'mConflict'; $nodes .= '>';
            foreach ($this->mConflict as $k1 => &$v1) {
                $nodes .= '<'; $nodes .= 'k1'; $nodes .= ' ';
                $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                $nodes .= $$k1; $nodes .= '"';  $nodes .= '/>';
                $v1->writeXML($nodes, 'v1');
            }
            $nodes .= '</'; $nodes .= 'mConflict'; $nodes .= '>';
        }
        if (count($this->info2d) > 0) {
            $nodes .= '<'; $nodes .= 'info2d'; $nodes .= '>';
            foreach ($this->info2d as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as &$n2) {
                    $n2->writeXML($nodes, 'n2');
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'info2d'; $nodes .= '>';
        }
        if (count($this->info3d) > 0) {
            $nodes .= '<'; $nodes .= 'info3d'; $nodes .= '>';
            foreach ($this->info3d as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= '>';
                    foreach ($n2 as &$n3) {
                        $n3->writeXML($nodes, 'n3');
                    }
                    $nodes .= '</'; $nodes .= 'n2'; $nodes .= '>';
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'info3d'; $nodes .= '>';
        }
        if (count($this->info5d) > 0) {
            $nodes .= '<'; $nodes .= 'info5d'; $nodes .= '>';
            foreach ($this->info5d as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= '>';
                    foreach ($n2 as &$n3) {
                        $nodes .= '<'; $nodes .= 'n3'; $nodes .= '>';
                        foreach ($n3 as &$n4) {
                            $nodes .= '<'; $nodes .= 'n4'; $nodes .= '>';
                            foreach ($n4 as &$n5) {
                                $n5->writeXML($nodes, 'n5');
                            }
                            $nodes .= '</'; $nodes .= 'n4'; $nodes .= '>';
                        }
                        $nodes .= '</'; $nodes .= 'n3'; $nodes .= '>';
                    }
                    $nodes .= '</'; $nodes .= 'n2'; $nodes .= '>';
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'info5d'; $nodes .= '>';
        }
        if (count($this->infovm) > 0) {
            $nodes .= '<'; $nodes .= 'infovm'; $nodes .= '>';
            foreach ($this->infovm as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as $k2 => &$v2) {
                    $nodes .= '<'; $nodes .= 'k2'; $nodes .= ' ';
                    $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                    $nodes .= $$k2; $nodes .= '"';  $nodes .= '/>';
                    $v2->writeXML($nodes, 'v2');
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'infovm'; $nodes .= '>';
        }
        if (count($this->mvei) > 0) {
            $nodes .= '<'; $nodes .= 'mvei'; $nodes .= '>';
            foreach ($this->mvei as $k1 => &$v1) {
                $nodes .= '<'; $nodes .= 'k1'; $nodes .= '>';
                foreach ($k1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= ' ';
                    $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                    $nodes .= $$n2; $nodes .= '"';  $nodes .= '/>';
                }
                $nodes .= '</'; $nodes .= 'k1'; $nodes .= '>';
                $v1->writeXML($nodes, 'v1');
            }
            $nodes .= '</'; $nodes .= 'mvei'; $nodes .= '>';
        }
        if (count($this->mive) > 0) {
            $nodes .= '<'; $nodes .= 'mive'; $nodes .= '>';
            foreach ($this->mive as $k1 => &$v1) {
                $k1->writeXML($nodes, 'k1');
                $nodes .= '<'; $nodes .= 'v1'; $nodes .= '>';
                foreach ($v1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= ' ';
                    $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                    $nodes .= $$n2; $nodes .= '"';  $nodes .= '/>';
                }
                $nodes .= '</'; $nodes .= 'v1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'mive'; $nodes .= '>';
        }
        if (count($this->mvive) > 0) {
            $nodes .= '<'; $nodes .= 'mvive'; $nodes .= '>';
            foreach ($this->mvive as $k1 => &$v1) {
                $nodes .= '<'; $nodes .= 'k1'; $nodes .= '>';
                foreach ($k1 as &$n2) {
                    $n2->writeXML($nodes, 'n2');
                }
                $nodes .= '</'; $nodes .= 'k1'; $nodes .= '>';
                $nodes .= '<'; $nodes .= 'v1'; $nodes .= '>';
                foreach ($v1 as &$n2) {
                    $nodes .= '<'; $nodes .= 'n2'; $nodes .= ' ';
                    $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                    $nodes .= $$n2; $nodes .= '"';  $nodes .= '/>';
                }
                $nodes .= '</'; $nodes .= 'v1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'mvive'; $nodes .= '>';
        }
        if (count($this->vmvive) > 0) {
            $nodes .= '<'; $nodes .= 'vmvive'; $nodes .= '>';
            foreach ($this->vmvive as &$n1) {
                $nodes .= '<'; $nodes .= 'n1'; $nodes .= '>';
                foreach ($n1 as $k2 => &$v2) {
                    $nodes .= '<'; $nodes .= 'k2'; $nodes .= '>';
                    foreach ($k2 as &$n3) {
                        $n3->writeXML($nodes, 'n3');
                    }
                    $nodes .= '</'; $nodes .= 'k2'; $nodes .= '>';
                    $nodes .= '<'; $nodes .= 'v2'; $nodes .= '>';
                    foreach ($v2 as &$n3) {
                        $nodes .= '<'; $nodes .= 'n3'; $nodes .= ' ';
                        $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                        $nodes .= $$n3; $nodes .= '"';  $nodes .= '/>';
                    }
                    $nodes .= '</'; $nodes .= 'v2'; $nodes .= '>';
                }
                $nodes .= '</'; $nodes .= 'n1'; $nodes .= '>';
            }
            $nodes .= '</'; $nodes .= 'vmvive'; $nodes .= '>';
        }
        if (isset($this->hotfix) && count($this->hotfix) > 0) {
            $nodes .= '<'; $nodes .= 'hotfix'; $nodes .= '>';
            foreach ($this->hotfix as $k1 => &$v1) {
                $nodes .= '<'; $nodes .= 'k1'; $nodes .= ' ';
                $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                $nodes .= $$k1; $nodes .= '"';  $nodes .= '/>';
                $nodes .= '<'; $nodes .= 'v1'; $nodes .= ' ';
                $nodes .= 'value'; $nodes .= '='; $nodes .= '"';
                $nodes .= $$v1; $nodes .= '"';  $nodes .= '/>';
            }
            $nodes .= '</'; $nodes .= 'hotfix'; $nodes .= '>';
        }
        $s .= '<';
        $s .= $name;
        $s .= $attrs;
        if (strlen($nodes) == 0) {
            $s .= '/>';
        } else {
            $s .= '>'; $s .= $nodes;
            $s .= '</'; $s .= $name; $s .= '>';
        }
    }
    /* End of writeXML(...) */

}
