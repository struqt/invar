/*===----------------------------*  Java 6  *------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.xyz;

import invar.lib.CodecError;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import test.abc.Gender;
import test.abc.Info;

/** Complex data structure */
public final class InfoX
implements
invar.lib.InvarCodec.BinaryDecode,
invar.lib.InvarCodec.BinaryEncode,
invar.lib.InvarCodec.XMLEncode,
invar.lib.InvarCodec.JSONEncode
{
    static public final long CRC32 = 0xF55867E1L;

    static public InfoX Create()
    {
        return new InfoX();
    }

    private LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> infos     ;
    private test.xyz.Conflict                                                conflict_x;/* Two types with the same name. */
    private test.abc.Conflict                                                conflict_a;/* Two types with the same name. */
    private LinkedHashMap<Integer,test.abc.Conflict>                         mConflict ;
    private LinkedList<LinkedList<Info>>                                     info2d    ;/* 2 dimension list */
    private LinkedList<LinkedList<LinkedList<Info>>>                         info3d    ;/* 3 dimension list */
    private LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> info5d    ;
    private LinkedList<LinkedHashMap<Short,Info>>                            infovm    ;
    private LinkedHashMap<LinkedList<Gender>,Info>                           mvei      ;
    private LinkedHashMap<Info,LinkedList<Gender>>                           mive      ;
    private LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>               mvive     ;
    private LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>>   vmvive    ;
    private LinkedHashMap<String,String>                                     hotfix    ;/* [AutoAdd] Hotfix */

    public InfoX()
    {
        infos      = new LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>>();
        conflict_x = test.xyz.Conflict.Create();
        conflict_a = test.abc.Conflict.Create();
        mConflict  = new LinkedHashMap<Integer,test.abc.Conflict>();
        info2d     = new LinkedList<LinkedList<Info>>();
        info3d     = new LinkedList<LinkedList<LinkedList<Info>>>();
        info5d     = new LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>>();
        infovm     = new LinkedList<LinkedHashMap<Short,Info>>();
        mvei       = new LinkedHashMap<LinkedList<Gender>,Info>();
        mive       = new LinkedHashMap<Info,LinkedList<Gender>>();
        mvive      = new LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>();
        vmvive     = new LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>>();
        hotfix     = null;
    }

    public InfoX reuse()
    {
        infos.clear();
        conflict_x.reuse();
        conflict_a.reuse();
        mConflict.clear();
        info2d.clear();
        info3d.clear();
        info5d.clear();
        infovm.clear();
        mvei.clear();
        mive.clear();
        mvive.clear();
        vmvive.clear();
        if (hotfix != null) {
            hotfix.clear();
        }
        return this;
    }

    /**  */
    @invar.lib.InvarRule(T="vec<vec<vec<vec<vec<test.abc.Info>>>>>", S="f0")
    public LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> getInfos() { return infos; }
    /** Two types with the same name. */
    @invar.lib.InvarRule(T="test.xyz.Conflict", S="f1")
    public test.xyz.Conflict getConflict_x() { return conflict_x; }
    /** Two types with the same name. */
    @invar.lib.InvarRule(T="test.abc.Conflict", S="f2")
    public test.abc.Conflict getConflict_a() { return conflict_a; }
    /**  */
    @invar.lib.InvarRule(T="map<int32,test.abc.Conflict>", S="f3")
    public LinkedHashMap<Integer,test.abc.Conflict> getMConflict() { return mConflict; }
    /** 2 dimension list */
    @invar.lib.InvarRule(T="vec<vec<test.abc.Info>>", S="f4")
    public LinkedList<LinkedList<Info>> getInfo2d() { return info2d; }
    /** 3 dimension list */
    @invar.lib.InvarRule(T="vec<vec<vec<test.abc.Info>>>", S="f5")
    public LinkedList<LinkedList<LinkedList<Info>>> getInfo3d() { return info3d; }
    /**  */
    @invar.lib.InvarRule(T="vec<vec<vec<vec<vec<test.abc.Info>>>>>", S="f6")
    public LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> getInfo5d() { return info5d; }
    /**  */
    @invar.lib.InvarRule(T="vec<map<int16,test.abc.Info>>", S="f7")
    public LinkedList<LinkedHashMap<Short,Info>> getInfovm() { return infovm; }
    /**  */
    @invar.lib.InvarRule(T="map<vec<test.abc.Gender>,test.abc.Info>", S="f8")
    public LinkedHashMap<LinkedList<Gender>,Info> getMvei() { return mvei; }
    /**  */
    @invar.lib.InvarRule(T="map<test.abc.Info,vec<test.abc.Gender>>", S="f9")
    public LinkedHashMap<Info,LinkedList<Gender>> getMive() { return mive; }
    /**  */
    @invar.lib.InvarRule(T="map<vec<test.abc.Info>,vec<test.abc.Gender>>", S="f10")
    public LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> getMvive() { return mvive; }
    /**  */
    @invar.lib.InvarRule(T="vec<map<vec<test.abc.Info>,vec<test.abc.Gender>>>", S="f11")
    public LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>> getVmvive() { return vmvive; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f12")
    public LinkedHashMap<java.lang.String,java.lang.String> getHotfix() { return hotfix; }

    /** Two types with the same name. */
    @invar.lib.InvarRule(T="test.xyz.Conflict", S="f1")
    public void setConflict_x(test.xyz.Conflict value) { this.conflict_x = value; }
    /** Two types with the same name. */
    @invar.lib.InvarRule(T="test.abc.Conflict", S="f2")
    public void setConflict_a(test.abc.Conflict value) { this.conflict_a = value; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f12")
    public void setHotfix(LinkedHashMap<java.lang.String,java.lang.String> value) { this.hotfix = value; }

    /** Shallow copy */
    public InfoX copy(InfoX from_)
    {
        if (this == from_ || from_ == null) {
            return this;
        }
        infos.clear();
        infos.addAll(from_.infos);
        conflict_x = from_.conflict_x;
        conflict_a = from_.conflict_a;
        mConflict.clear();
        mConflict.putAll(from_.mConflict);
        info2d.clear();
        info2d.addAll(from_.info2d);
        info3d.clear();
        info3d.addAll(from_.info3d);
        info5d.clear();
        info5d.addAll(from_.info5d);
        infovm.clear();
        infovm.addAll(from_.infovm);
        mvei.clear();
        mvei.putAll(from_.mvei);
        mive.clear();
        mive.putAll(from_.mive);
        mvive.clear();
        mvive.putAll(from_.mvive);
        vmvive.clear();
        vmvive.addAll(from_.vmvive);
        if (null == from_.hotfix) {
            hotfix = null;
        } else {
            if (null == hotfix) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            else { hotfix.clear(); }
            hotfix.putAll(from_.hotfix);
        }
        return this;
    } /* copyFrom(...) */

    public void read(InputStream from_) throws IOException, CodecError
    {
        this.read((DataInput)new DataInputStream(from_));
    }

    public void read(DataInput from_) throws IOException, CodecError
    {
        infos.clear();
        Long lenInfos = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iInfos = 0L; iInfos < lenInfos; ++iInfos) {
            LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 = new LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<LinkedList<LinkedList<Info>>> n2 = new LinkedList<LinkedList<LinkedList<Info>>>(); //read.vec.head
                Long lenN2 = from_.readInt() & 0xFFFFFFFFL;
                for (Long/*U32*/ iN2 = 0L; iN2 < lenN2; ++iN2) {
                    LinkedList<LinkedList<Info>> n3 = new LinkedList<LinkedList<Info>>(); //read.vec.head
                    Long lenN3 = from_.readInt() & 0xFFFFFFFFL;
                    for (Long/*U32*/ iN3 = 0L; iN3 < lenN3; ++iN3) {
                        LinkedList<Info> n4 = new LinkedList<Info>(); //read.vec.head
                        Long lenN4 = from_.readInt() & 0xFFFFFFFFL;
                        for (Long/*U32*/ iN4 = 0L; iN4 < lenN4; ++iN4) {
                            Info n5 = Info.Create();
                            n5.read(from_);
                            n4.add(n5);
                        }
                        n3.add(n4);
                    }
                    n2.add(n3);
                }
                n1.add(n2);
            }
            infos.add(n1);
        }
        conflict_x.read(from_);
        conflict_a.read(from_);
        mConflict.clear();
        Long lenMConflict = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMConflict = 0L; iMConflict < lenMConflict; ++iMConflict) {
            Integer k1 = from_.readInt();
            test.abc.Conflict v1 = test.abc.Conflict.Create();
            v1.read(from_);
            mConflict.put(k1,v1);
        }
        info2d.clear();
        Long lenInfo2d = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iInfo2d = 0L; iInfo2d < lenInfo2d; ++iInfo2d) {
            LinkedList<Info> n1 = new LinkedList<Info>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                Info n2 = Info.Create();
                n2.read(from_);
                n1.add(n2);
            }
            info2d.add(n1);
        }
        info3d.clear();
        Long lenInfo3d = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iInfo3d = 0L; iInfo3d < lenInfo3d; ++iInfo3d) {
            LinkedList<LinkedList<Info>> n1 = new LinkedList<LinkedList<Info>>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<Info> n2 = new LinkedList<Info>(); //read.vec.head
                Long lenN2 = from_.readInt() & 0xFFFFFFFFL;
                for (Long/*U32*/ iN2 = 0L; iN2 < lenN2; ++iN2) {
                    Info n3 = Info.Create();
                    n3.read(from_);
                    n2.add(n3);
                }
                n1.add(n2);
            }
            info3d.add(n1);
        }
        info5d.clear();
        Long lenInfo5d = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iInfo5d = 0L; iInfo5d < lenInfo5d; ++iInfo5d) {
            LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 = new LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<LinkedList<LinkedList<Info>>> n2 = new LinkedList<LinkedList<LinkedList<Info>>>(); //read.vec.head
                Long lenN2 = from_.readInt() & 0xFFFFFFFFL;
                for (Long/*U32*/ iN2 = 0L; iN2 < lenN2; ++iN2) {
                    LinkedList<LinkedList<Info>> n3 = new LinkedList<LinkedList<Info>>(); //read.vec.head
                    Long lenN3 = from_.readInt() & 0xFFFFFFFFL;
                    for (Long/*U32*/ iN3 = 0L; iN3 < lenN3; ++iN3) {
                        LinkedList<Info> n4 = new LinkedList<Info>(); //read.vec.head
                        Long lenN4 = from_.readInt() & 0xFFFFFFFFL;
                        for (Long/*U32*/ iN4 = 0L; iN4 < lenN4; ++iN4) {
                            Info n5 = Info.Create();
                            n5.read(from_);
                            n4.add(n5);
                        }
                        n3.add(n4);
                    }
                    n2.add(n3);
                }
                n1.add(n2);
            }
            info5d.add(n1);
        }
        infovm.clear();
        Long lenInfovm = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iInfovm = 0L; iInfovm < lenInfovm; ++iInfovm) {
            LinkedHashMap<Short,Info> n1 = new LinkedHashMap<Short,Info>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                Short k2 = from_.readShort();
                Info v2 = Info.Create();
                v2.read(from_);
                n1.put(k2,v2);
            }
            infovm.add(n1);
        }
        mvei.clear();
        Long lenMvei = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMvei = 0L; iMvei < lenMvei; ++iMvei) {
            LinkedList<Gender> k1 = new LinkedList<Gender>(); //read.map.head
            Long lenK1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iK1 = 0L; iK1 < lenK1; ++iK1) {
                Gender n2 = Gender.valueOf(from_.readInt());
                k1.add(n2);
            }
            Info v1 = Info.Create();
            v1.read(from_);
            mvei.put(k1,v1);
        }
        mive.clear();
        Long lenMive = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMive = 0L; iMive < lenMive; ++iMive) {
            Info k1 = Info.Create();
            k1.read(from_);
            LinkedList<Gender> v1 = new LinkedList<Gender>(); //read.map.head
            Long lenV1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iV1 = 0L; iV1 < lenV1; ++iV1) {
                Gender n2 = Gender.valueOf(from_.readInt());
                v1.add(n2);
            }
            mive.put(k1,v1);
        }
        mvive.clear();
        Long lenMvive = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMvive = 0L; iMvive < lenMvive; ++iMvive) {
            LinkedList<Info> k1 = new LinkedList<Info>(); //read.map.head
            Long lenK1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iK1 = 0L; iK1 < lenK1; ++iK1) {
                Info n2 = Info.Create();
                n2.read(from_);
                k1.add(n2);
            }
            LinkedList<Gender> v1 = new LinkedList<Gender>(); //read.map.head
            Long lenV1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iV1 = 0L; iV1 < lenV1; ++iV1) {
                Gender n2 = Gender.valueOf(from_.readInt());
                v1.add(n2);
            }
            mvive.put(k1,v1);
        }
        vmvive.clear();
        Long lenVmvive = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iVmvive = 0L; iVmvive < lenVmvive; ++iVmvive) {
            LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 = new LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>(); //read.vec.head
            Long lenN1 = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<Info> k2 = new LinkedList<Info>(); //read.map.head
                Long lenK2 = from_.readInt() & 0xFFFFFFFFL;
                for (Long/*U32*/ iK2 = 0L; iK2 < lenK2; ++iK2) {
                    Info n3 = Info.Create();
                    n3.read(from_);
                    k2.add(n3);
                }
                LinkedList<Gender> v2 = new LinkedList<Gender>(); //read.map.head
                Long lenV2 = from_.readInt() & 0xFFFFFFFFL;
                for (Long/*U32*/ iV2 = 0L; iV2 < lenV2; ++iV2) {
                    Gender n3 = Gender.valueOf(from_.readInt());
                    v2.add(n3);
                }
                n1.put(k2,v2);
            }
            vmvive.add(n1);
        }
        byte hotfixExists = from_.readByte();
        if ((byte)0x01 == hotfixExists) {
            if (hotfix == null) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            Long lenHotfix = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iHotfix = 0L; iHotfix < lenHotfix; ++iHotfix) {
                java.lang.String k1 = from_.readUTF();
                java.lang.String v1 = from_.readUTF();
                hotfix.put(k1,v1);
            }
        }
        else if ((byte)0x00 == hotfixExists) { hotfix = null; }
        else { throw new CodecError(CodecError.ERR_DECODE_VEC_MAP_P); }
    }

    public void write(OutputStream dest_) throws IOException
    {
        this.write((DataOutput)new DataOutputStream(dest_));
    }

    public void write(DataOutput dest_) throws IOException
    {
        dest_.writeInt(infos.size());
        for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : infos) {
            dest_.writeInt(n1.size());
            for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                dest_.writeInt(n2.size());
                for (LinkedList<LinkedList<Info>> n3 : n2) {
                    dest_.writeInt(n3.size());
                    for (LinkedList<Info> n4 : n3) {
                        dest_.writeInt(n4.size());
                        for (Info n5 : n4) {
                            n5.write(dest_);
                        }
                    }
                }
            }
        }
        conflict_x.write(dest_);
        conflict_a.write(dest_);
        dest_.writeInt(mConflict.size());
        for (Map.Entry<Integer,test.abc.Conflict> mConflictIter : mConflict.entrySet()) {
            Integer k1 = mConflictIter.getKey();
            dest_.writeInt(k1);
            test.abc.Conflict v1 = mConflictIter.getValue();
            v1.write(dest_);
        }
        dest_.writeInt(info2d.size());
        for (LinkedList<Info> n1 : info2d) {
            dest_.writeInt(n1.size());
            for (Info n2 : n1) {
                n2.write(dest_);
            }
        }
        dest_.writeInt(info3d.size());
        for (LinkedList<LinkedList<Info>> n1 : info3d) {
            dest_.writeInt(n1.size());
            for (LinkedList<Info> n2 : n1) {
                dest_.writeInt(n2.size());
                for (Info n3 : n2) {
                    n3.write(dest_);
                }
            }
        }
        dest_.writeInt(info5d.size());
        for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : info5d) {
            dest_.writeInt(n1.size());
            for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                dest_.writeInt(n2.size());
                for (LinkedList<LinkedList<Info>> n3 : n2) {
                    dest_.writeInt(n3.size());
                    for (LinkedList<Info> n4 : n3) {
                        dest_.writeInt(n4.size());
                        for (Info n5 : n4) {
                            n5.write(dest_);
                        }
                    }
                }
            }
        }
        dest_.writeInt(infovm.size());
        for (LinkedHashMap<Short,Info> n1 : infovm) {
            dest_.writeInt(n1.size());
            for (Map.Entry<Short,Info> n1Iter : n1.entrySet()) {
                Short k2 = n1Iter.getKey();
                dest_.writeShort(k2);
                Info v2 = n1Iter.getValue();
                v2.write(dest_);
            }
        }
        dest_.writeInt(mvei.size());
        for (Map.Entry<LinkedList<Gender>,Info> mveiIter : mvei.entrySet()) {
            LinkedList<Gender> k1 = mveiIter.getKey();
            dest_.writeInt(k1.size());
            for (Gender n2 : k1) {
                dest_.writeInt(n2.value());
            }
            Info v1 = mveiIter.getValue();
            v1.write(dest_);
        }
        dest_.writeInt(mive.size());
        for (Map.Entry<Info,LinkedList<Gender>> miveIter : mive.entrySet()) {
            Info k1 = miveIter.getKey();
            k1.write(dest_);
            LinkedList<Gender> v1 = miveIter.getValue();
            dest_.writeInt(v1.size());
            for (Gender n2 : v1) {
                dest_.writeInt(n2.value());
            }
        }
        dest_.writeInt(mvive.size());
        for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> mviveIter : mvive.entrySet()) {
            LinkedList<Info> k1 = mviveIter.getKey();
            dest_.writeInt(k1.size());
            for (Info n2 : k1) {
                n2.write(dest_);
            }
            LinkedList<Gender> v1 = mviveIter.getValue();
            dest_.writeInt(v1.size());
            for (Gender n2 : v1) {
                dest_.writeInt(n2.value());
            }
        }
        dest_.writeInt(vmvive.size());
        for (LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 : vmvive) {
            dest_.writeInt(n1.size());
            for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> n1Iter : n1.entrySet()) {
                LinkedList<Info> k2 = n1Iter.getKey();
                dest_.writeInt(k2.size());
                for (Info n3 : k2) {
                    n3.write(dest_);
                }
                LinkedList<Gender> v2 = n1Iter.getValue();
                dest_.writeInt(v2.size());
                for (Gender n3 : v2) {
                    dest_.writeInt(n3.value());
                }
            }
        }
        if (hotfix != null) {
            dest_.writeByte((byte)0x01);
            dest_.writeInt(hotfix.size());
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                dest_.writeUTF(k1);
                java.lang.String v1 = hotfixIter.getValue();
                dest_.writeUTF(v1);
            }
        } else {
            dest_.writeByte((byte)0x00);
        }
    }

    public String toString()
    {
        StringBuilder s = new StringBuilder();
        s.append('{');
        s.append(getClass().getName());
        s.append(',').append("infos").append(':');
        s.append('(').append(infos.size()).append(')');
        s.append(',').append("conflict_x").append(':');
        s.append('<').append("test.xyz.Conflict").append('>');
        s.append(',').append("conflict_a").append(':');
        s.append('<').append("test.abc.Conflict").append('>');
        s.append(',').append("mConflict").append(':');
        s.append('[').append(mConflict.size()).append(']');
        s.append(',').append("info2d").append(':');
        s.append('(').append(info2d.size()).append(')');
        s.append(',').append("info3d").append(':');
        s.append('(').append(info3d.size()).append(')');
        s.append(',').append("info5d").append(':');
        s.append('(').append(info5d.size()).append(')');
        s.append(',').append("infovm").append(':');
        s.append('(').append(infovm.size()).append(')');
        s.append(',').append("mvei").append(':');
        s.append('[').append(mvei.size()).append(']');
        s.append(',').append("mive").append(':');
        s.append('[').append(mive.size()).append(']');
        s.append(',').append("mvive").append(':');
        s.append('[').append(mvive.size()).append(']');
        s.append(',').append("vmvive").append(':');
        s.append('(').append(vmvive.size()).append(')');
        s.append(", hotfix:");
        if (hotfix != null) {
            s.append('[').append(hotfix.size()).append(']');
        } else {
            s.append("null");
        }
        s.append('}');
        return s.toString();
    } //InfoX::toString ()

    public String toStringJSON()
    {
        StringBuilder code = new StringBuilder();
        this.writeJSON(code);
        return code.toString();
    }

    public void writeJSON(StringBuilder s_)
    {
        s_.append('{');
        char comma = '\0';
        boolean infosExists = (null != infos);
        if (infosExists) { s_.append('"').append("infos").append('"').append(':'); comma = ','; }
        if (null != infos) {
            s_.append('[');
            int infosSize = infos.size();
            int infosIdx = 0;
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : infos) { /* vec.for: infos */
                ++infosIdx;
                if (null != n1) {
                    s_.append('[');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) { /* vec.for: n1 */
                        ++n1Idx;
                        if (null != n2) {
                            s_.append('[');
                            int n2Size = n2.size();
                            int n2Idx = 0;
                            for (LinkedList<LinkedList<Info>> n3 : n2) { /* vec.for: n2 */
                                ++n2Idx;
                                if (null != n3) {
                                    s_.append('[');
                                    int n3Size = n3.size();
                                    int n3Idx = 0;
                                    for (LinkedList<Info> n4 : n3) { /* vec.for: n3 */
                                        ++n3Idx;
                                        if (null != n4) {
                                            s_.append('[');
                                            int n4Size = n4.size();
                                            int n4Idx = 0;
                                            for (Info n5 : n4) { /* vec.for: n4 */
                                                ++n4Idx;
                                                n5.writeJSON(s_);
                                                if (n4Idx != n4Size) { s_.append(','); }
                                            }
                                            s_.append(']');
                                        }
                                        if (n3Idx != n3Size) { s_.append(','); }
                                    }
                                    s_.append(']');
                                }
                                if (n2Idx != n2Size) { s_.append(','); }
                            }
                            s_.append(']');
                        }
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (infosIdx != infosSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean conflict_xExists = (null != conflict_x);
        if ('\0' != comma && conflict_xExists) { s_.append(comma); comma = '\0'; }
        if (conflict_xExists) {
            s_.append('"').append("conflict_x").append('"').append(':'); comma = ','; conflict_x.writeJSON(s_);
        }
        boolean conflict_aExists = (null != conflict_a);
        if ('\0' != comma && conflict_aExists) { s_.append(comma); comma = '\0'; }
        if (conflict_aExists) {
            s_.append('"').append("conflict_a").append('"').append(':'); comma = ','; conflict_a.writeJSON(s_);
        }
        boolean mConflictExists = (null != mConflict);
        if ('\0' != comma && mConflictExists) { s_.append(comma); comma = '\0'; }
        if (mConflictExists) { s_.append('"').append("mConflict").append('"').append(':'); comma = ','; }
        if (null != mConflict) {
            s_.append('{');
            int mConflictSize = mConflict.size();
            int mConflictIdx = 0;
            for (Map.Entry<Integer,test.abc.Conflict> mConflictIter : mConflict.entrySet()) { /* map.for: mConflict */
                ++mConflictIdx;
                Integer k1 = mConflictIter.getKey(); /* nest.k */
                s_.append('"'); s_.append(k1.toString()); s_.append('"').append(':');
                test.abc.Conflict v1 = mConflictIter.getValue(); /* nest.v */
                v1.writeJSON(s_);
                if (mConflictIdx != mConflictSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean info2dExists = (null != info2d);
        if ('\0' != comma && info2dExists) { s_.append(comma); comma = '\0'; }
        if (info2dExists) { s_.append('"').append("info2d").append('"').append(':'); comma = ','; }
        if (null != info2d) {
            s_.append('[');
            int info2dSize = info2d.size();
            int info2dIdx = 0;
            for (LinkedList<Info> n1 : info2d) { /* vec.for: info2d */
                ++info2dIdx;
                if (null != n1) {
                    s_.append('[');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (Info n2 : n1) { /* vec.for: n1 */
                        ++n1Idx;
                        n2.writeJSON(s_);
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (info2dIdx != info2dSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean info3dExists = (null != info3d);
        if ('\0' != comma && info3dExists) { s_.append(comma); comma = '\0'; }
        if (info3dExists) { s_.append('"').append("info3d").append('"').append(':'); comma = ','; }
        if (null != info3d) {
            s_.append('[');
            int info3dSize = info3d.size();
            int info3dIdx = 0;
            for (LinkedList<LinkedList<Info>> n1 : info3d) { /* vec.for: info3d */
                ++info3dIdx;
                if (null != n1) {
                    s_.append('[');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (LinkedList<Info> n2 : n1) { /* vec.for: n1 */
                        ++n1Idx;
                        if (null != n2) {
                            s_.append('[');
                            int n2Size = n2.size();
                            int n2Idx = 0;
                            for (Info n3 : n2) { /* vec.for: n2 */
                                ++n2Idx;
                                n3.writeJSON(s_);
                                if (n2Idx != n2Size) { s_.append(','); }
                            }
                            s_.append(']');
                        }
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (info3dIdx != info3dSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean info5dExists = (null != info5d);
        if ('\0' != comma && info5dExists) { s_.append(comma); comma = '\0'; }
        if (info5dExists) { s_.append('"').append("info5d").append('"').append(':'); comma = ','; }
        if (null != info5d) {
            s_.append('[');
            int info5dSize = info5d.size();
            int info5dIdx = 0;
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : info5d) { /* vec.for: info5d */
                ++info5dIdx;
                if (null != n1) {
                    s_.append('[');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) { /* vec.for: n1 */
                        ++n1Idx;
                        if (null != n2) {
                            s_.append('[');
                            int n2Size = n2.size();
                            int n2Idx = 0;
                            for (LinkedList<LinkedList<Info>> n3 : n2) { /* vec.for: n2 */
                                ++n2Idx;
                                if (null != n3) {
                                    s_.append('[');
                                    int n3Size = n3.size();
                                    int n3Idx = 0;
                                    for (LinkedList<Info> n4 : n3) { /* vec.for: n3 */
                                        ++n3Idx;
                                        if (null != n4) {
                                            s_.append('[');
                                            int n4Size = n4.size();
                                            int n4Idx = 0;
                                            for (Info n5 : n4) { /* vec.for: n4 */
                                                ++n4Idx;
                                                n5.writeJSON(s_);
                                                if (n4Idx != n4Size) { s_.append(','); }
                                            }
                                            s_.append(']');
                                        }
                                        if (n3Idx != n3Size) { s_.append(','); }
                                    }
                                    s_.append(']');
                                }
                                if (n2Idx != n2Size) { s_.append(','); }
                            }
                            s_.append(']');
                        }
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (info5dIdx != info5dSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean infovmExists = (null != infovm);
        if ('\0' != comma && infovmExists) { s_.append(comma); comma = '\0'; }
        if (infovmExists) { s_.append('"').append("infovm").append('"').append(':'); comma = ','; }
        if (null != infovm) {
            s_.append('[');
            int infovmSize = infovm.size();
            int infovmIdx = 0;
            for (LinkedHashMap<Short,Info> n1 : infovm) { /* vec.for: infovm */
                ++infovmIdx;
                if (null != n1) {
                    s_.append('{');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (Map.Entry<Short,Info> n1Iter : n1.entrySet()) { /* map.for: n1 */
                        ++n1Idx;
                        Short k2 = n1Iter.getKey(); /* nest.k */
                        s_.append('"'); s_.append(k2.toString()); s_.append('"').append(':');
                        Info v2 = n1Iter.getValue(); /* nest.v */
                        v2.writeJSON(s_);
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append('}');
                }
                if (infovmIdx != infovmSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean mveiExists = (null != mvei);
        if ('\0' != comma && mveiExists) { s_.append(comma); comma = '\0'; }
        if (mveiExists) { s_.append('"').append("mvei").append('"').append(':'); comma = ','; }
        if (null != mvei) {
            s_.append('{');
            int mveiSize = mvei.size();
            int mveiIdx = 0;
            for (Map.Entry<LinkedList<Gender>,Info> mveiIter : mvei.entrySet()) { /* map.for: mvei */
                ++mveiIdx;
                LinkedList<Gender> k1 = mveiIter.getKey();
                if (null != k1) {
                    s_.append('[');
                    int k1Size = k1.size();
                    int k1Idx = 0;
                    for (Gender n2 : k1) { /* vec.for: k1 */
                        ++k1Idx;
                        s_.append(n2.value());
                        if (k1Idx != k1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                Info v1 = mveiIter.getValue(); /* nest.v */
                v1.writeJSON(s_);
                if (mveiIdx != mveiSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean miveExists = (null != mive);
        if ('\0' != comma && miveExists) { s_.append(comma); comma = '\0'; }
        if (miveExists) { s_.append('"').append("mive").append('"').append(':'); comma = ','; }
        if (null != mive) {
            s_.append('{');
            int miveSize = mive.size();
            int miveIdx = 0;
            for (Map.Entry<Info,LinkedList<Gender>> miveIter : mive.entrySet()) { /* map.for: mive */
                ++miveIdx;
                Info k1 = miveIter.getKey(); /* nest.k */
                s_.append('"'); k1.writeJSON(s_); s_.append('"').append(':');
                LinkedList<Gender> v1 = miveIter.getValue();
                if (null != v1) {
                    s_.append('[');
                    int v1Size = v1.size();
                    int v1Idx = 0;
                    for (Gender n2 : v1) { /* vec.for: v1 */
                        ++v1Idx;
                        s_.append(n2.value());
                        if (v1Idx != v1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (miveIdx != miveSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean mviveExists = (null != mvive);
        if ('\0' != comma && mviveExists) { s_.append(comma); comma = '\0'; }
        if (mviveExists) { s_.append('"').append("mvive").append('"').append(':'); comma = ','; }
        if (null != mvive) {
            s_.append('{');
            int mviveSize = mvive.size();
            int mviveIdx = 0;
            for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> mviveIter : mvive.entrySet()) { /* map.for: mvive */
                ++mviveIdx;
                LinkedList<Info> k1 = mviveIter.getKey();
                if (null != k1) {
                    s_.append('[');
                    int k1Size = k1.size();
                    int k1Idx = 0;
                    for (Info n2 : k1) { /* vec.for: k1 */
                        ++k1Idx;
                        n2.writeJSON(s_);
                        if (k1Idx != k1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                LinkedList<Gender> v1 = mviveIter.getValue();
                if (null != v1) {
                    s_.append('[');
                    int v1Size = v1.size();
                    int v1Idx = 0;
                    for (Gender n2 : v1) { /* vec.for: v1 */
                        ++v1Idx;
                        s_.append(n2.value());
                        if (v1Idx != v1Size) { s_.append(','); }
                    }
                    s_.append(']');
                }
                if (mviveIdx != mviveSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean vmviveExists = (null != vmvive);
        if ('\0' != comma && vmviveExists) { s_.append(comma); comma = '\0'; }
        if (vmviveExists) { s_.append('"').append("vmvive").append('"').append(':'); comma = ','; }
        if (null != vmvive) {
            s_.append('[');
            int vmviveSize = vmvive.size();
            int vmviveIdx = 0;
            for (LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 : vmvive) { /* vec.for: vmvive */
                ++vmviveIdx;
                if (null != n1) {
                    s_.append('{');
                    int n1Size = n1.size();
                    int n1Idx = 0;
                    for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> n1Iter : n1.entrySet()) { /* map.for: n1 */
                        ++n1Idx;
                        LinkedList<Info> k2 = n1Iter.getKey();
                        if (null != k2) {
                            s_.append('[');
                            int k2Size = k2.size();
                            int k2Idx = 0;
                            for (Info n3 : k2) { /* vec.for: k2 */
                                ++k2Idx;
                                n3.writeJSON(s_);
                                if (k2Idx != k2Size) { s_.append(','); }
                            }
                            s_.append(']');
                        }
                        LinkedList<Gender> v2 = n1Iter.getValue();
                        if (null != v2) {
                            s_.append('[');
                            int v2Size = v2.size();
                            int v2Idx = 0;
                            for (Gender n3 : v2) { /* vec.for: v2 */
                                ++v2Idx;
                                s_.append(n3.value());
                                if (v2Idx != v2Size) { s_.append(','); }
                            }
                            s_.append(']');
                        }
                        if (n1Idx != n1Size) { s_.append(','); }
                    }
                    s_.append('}');
                }
                if (vmviveIdx != vmviveSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean hotfixExists = (null != hotfix);
        if ('\0' != comma && hotfixExists) { s_.append(comma); comma = '\0'; }
        if (hotfixExists) {
            s_.append('"').append("hotfix").append('"').append(':'); comma = ',';
            if (null != hotfix) {
                s_.append('{');
                int hotfixSize = hotfix.size();
                int hotfixIdx = 0;
                for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) { /* map.for: hotfix */
                    ++hotfixIdx;
                    java.lang.String k1 = hotfixIter.getKey(); /* nest.k */
                    s_.append('"').append(k1.toString()).append('"'); s_.append(':');
                    java.lang.String v1 = hotfixIter.getValue(); /* nest.v */
                    s_.append('"').append(v1.toString()).append('"');
                    if (hotfixIdx != hotfixSize) { s_.append(','); }
                }
                s_.append('}');
            }
        }
        s_.append('}');
    } /* InfoX::writeJSON(...) */

    public String toStringXML()
    {
        StringBuilder code = new StringBuilder();
        this.writeXML(code, "InfoX");
        return code.toString();
    }

    public void writeXML(StringBuilder result_, String name_)
    {
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes = new StringBuilder();
        if (infos.size() > 0) {
            nodes.append('<').append("infos").append('>');
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : infos) {
                nodes.append('<').append("n1").append('>');
                for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                    nodes.append('<').append("n2").append('>');
                    for (LinkedList<LinkedList<Info>> n3 : n2) {
                        nodes.append('<').append("n3").append('>');
                        for (LinkedList<Info> n4 : n3) {
                            nodes.append('<').append("n4").append('>');
                            for (Info n5 : n4) {
                                n5.writeXML(nodes, "n5");
                            }
                            nodes.append('<').append('/').append("n4").append('>');
                        }
                        nodes.append('<').append('/').append("n3").append('>');
                    }
                    nodes.append('<').append('/').append("n2").append('>');
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("infos").append('>');
        }
        conflict_x.writeXML(nodes, "conflict_x");
        conflict_a.writeXML(nodes, "conflict_a");
        if (mConflict.size() > 0) {
            nodes.append('<').append("mConflict").append('>');
            for (Map.Entry<Integer,test.abc.Conflict> mConflictIter : mConflict.entrySet()) {
                Integer k1 = mConflictIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1.toString()).append('"').append('/').append('>');
                test.abc.Conflict v1 = mConflictIter.getValue();
                v1.writeXML(nodes, "v1");
            }
            nodes.append('<').append('/').append("mConflict").append('>');
        }
        if (info2d.size() > 0) {
            nodes.append('<').append("info2d").append('>');
            for (LinkedList<Info> n1 : info2d) {
                nodes.append('<').append("n1").append('>');
                for (Info n2 : n1) {
                    n2.writeXML(nodes, "n2");
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("info2d").append('>');
        }
        if (info3d.size() > 0) {
            nodes.append('<').append("info3d").append('>');
            for (LinkedList<LinkedList<Info>> n1 : info3d) {
                nodes.append('<').append("n1").append('>');
                for (LinkedList<Info> n2 : n1) {
                    nodes.append('<').append("n2").append('>');
                    for (Info n3 : n2) {
                        n3.writeXML(nodes, "n3");
                    }
                    nodes.append('<').append('/').append("n2").append('>');
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("info3d").append('>');
        }
        if (info5d.size() > 0) {
            nodes.append('<').append("info5d").append('>');
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : info5d) {
                nodes.append('<').append("n1").append('>');
                for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                    nodes.append('<').append("n2").append('>');
                    for (LinkedList<LinkedList<Info>> n3 : n2) {
                        nodes.append('<').append("n3").append('>');
                        for (LinkedList<Info> n4 : n3) {
                            nodes.append('<').append("n4").append('>');
                            for (Info n5 : n4) {
                                n5.writeXML(nodes, "n5");
                            }
                            nodes.append('<').append('/').append("n4").append('>');
                        }
                        nodes.append('<').append('/').append("n3").append('>');
                    }
                    nodes.append('<').append('/').append("n2").append('>');
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("info5d").append('>');
        }
        if (infovm.size() > 0) {
            nodes.append('<').append("infovm").append('>');
            for (LinkedHashMap<Short,Info> n1 : infovm) {
                nodes.append('<').append("n1").append('>');
                for (Map.Entry<Short,Info> n1Iter : n1.entrySet()) {
                    Short k2 = n1Iter.getKey();
                    nodes.append('<').append("k2").append(' ').append("value").append('=').append('"');
                    nodes.append(k2.toString()).append('"').append('/').append('>');
                    Info v2 = n1Iter.getValue();
                    v2.writeXML(nodes, "v2");
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("infovm").append('>');
        }
        if (mvei.size() > 0) {
            nodes.append('<').append("mvei").append('>');
            for (Map.Entry<LinkedList<Gender>,Info> mveiIter : mvei.entrySet()) {
                LinkedList<Gender> k1 = mveiIter.getKey();
                nodes.append('<').append("k1").append('>');
                for (Gender n2 : k1) {
                    nodes.append('<').append("n2").append(' ').append("value").append('=').append('"');
                    nodes.append(n2.value()).append('"').append('/').append('>');
                }
                nodes.append('<').append('/').append("k1").append('>');
                Info v1 = mveiIter.getValue();
                v1.writeXML(nodes, "v1");
            }
            nodes.append('<').append('/').append("mvei").append('>');
        }
        if (mive.size() > 0) {
            nodes.append('<').append("mive").append('>');
            for (Map.Entry<Info,LinkedList<Gender>> miveIter : mive.entrySet()) {
                Info k1 = miveIter.getKey();
                k1.writeXML(nodes, "k1");
                LinkedList<Gender> v1 = miveIter.getValue();
                nodes.append('<').append("v1").append('>');
                for (Gender n2 : v1) {
                    nodes.append('<').append("n2").append(' ').append("value").append('=').append('"');
                    nodes.append(n2.value()).append('"').append('/').append('>');
                }
                nodes.append('<').append('/').append("v1").append('>');
            }
            nodes.append('<').append('/').append("mive").append('>');
        }
        if (mvive.size() > 0) {
            nodes.append('<').append("mvive").append('>');
            for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> mviveIter : mvive.entrySet()) {
                LinkedList<Info> k1 = mviveIter.getKey();
                nodes.append('<').append("k1").append('>');
                for (Info n2 : k1) {
                    n2.writeXML(nodes, "n2");
                }
                nodes.append('<').append('/').append("k1").append('>');
                LinkedList<Gender> v1 = mviveIter.getValue();
                nodes.append('<').append("v1").append('>');
                for (Gender n2 : v1) {
                    nodes.append('<').append("n2").append(' ').append("value").append('=').append('"');
                    nodes.append(n2.value()).append('"').append('/').append('>');
                }
                nodes.append('<').append('/').append("v1").append('>');
            }
            nodes.append('<').append('/').append("mvive").append('>');
        }
        if (vmvive.size() > 0) {
            nodes.append('<').append("vmvive").append('>');
            for (LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 : vmvive) {
                nodes.append('<').append("n1").append('>');
                for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> n1Iter : n1.entrySet()) {
                    LinkedList<Info> k2 = n1Iter.getKey();
                    nodes.append('<').append("k2").append('>');
                    for (Info n3 : k2) {
                        n3.writeXML(nodes, "n3");
                    }
                    nodes.append('<').append('/').append("k2").append('>');
                    LinkedList<Gender> v2 = n1Iter.getValue();
                    nodes.append('<').append("v2").append('>');
                    for (Gender n3 : v2) {
                        nodes.append('<').append("n3").append(' ').append("value").append('=').append('"');
                        nodes.append(n3.value()).append('"').append('/').append('>');
                    }
                    nodes.append('<').append('/').append("v2").append('>');
                }
                nodes.append('<').append('/').append("n1").append('>');
            }
            nodes.append('<').append('/').append("vmvive").append('>');
        }
        if (hotfix != null && hotfix.size() > 0) {
            nodes.append('<').append("hotfix").append('>');
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1).append('"').append('/').append('>');
                java.lang.String v1 = hotfixIter.getValue();
                nodes.append('<').append("v1").append(' ').append("value").append('=').append('"');
                nodes.append(v1).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("hotfix").append('>');
        }
        result_.append('<').append(name_).append(attrs);
        if (nodes.length() == 0) {
            result_.append('/').append('>');
        } else {
            result_.append('>').append(nodes);
            result_.append('<').append('/').append(name_).append('>');
        }
    } /* InfoX::writeXML(...) */

}

