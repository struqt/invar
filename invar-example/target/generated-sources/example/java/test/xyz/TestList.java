/*===----------------------------*  Java 6  *------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.xyz;

import invar.lib.CodecError;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.util.LinkedList;
import test.abc.Custom;
import test.abc.Gender;

/** 测试基本的列表类型 */
public final class TestList
implements
invar.lib.InvarCodec.BinaryDecode,
invar.lib.InvarCodec.BinaryEncode,
invar.lib.InvarCodec.XMLEncode
{
    static public final long CRC32 = 0x5FD1194AL;

    static public TestList Create()
    {
        return new TestList();
    }

    private LinkedList<Byte>           listI08    ;/* 有符号的8位整数 */
    private LinkedList<Short>          listI16    ;/* 有符号的16位整数 */
    private LinkedList<Integer>        listI32    ;/* 有符号的32位整数 */
    private LinkedList<Long>           listI64    ;/* 有符号的64位整数 */
    private LinkedList<Integer/*U08*/> listU08    ;/* 无符号的8位整数 */
    private LinkedList<Integer/*U16*/> listU16    ;/* 无符号的16位整数 */
    private LinkedList<Long/*U32*/>    listU32    ;/* 无符号的32位整数 */
    private LinkedList<BigInteger>     listU64    ;/* 无符号的64位整数 */
    private LinkedList<Float>          listSingle ;/* 单精度浮点小数 */
    private LinkedList<Double>         listDouble ;/* 双精度浮点小数 */
    private LinkedList<Boolean>        listBoolean;/* 布尔值 */
    private LinkedList<String>         listString ;/* 字符串 */
    private LinkedList<Gender>         listEnum   ;/* 枚举值 */
    private LinkedList<Custom>         listStruct ;/* 自定义结构 */

    public TestList()
    {
        listI08     = new LinkedList<Byte>();
        listI16     = new LinkedList<Short>();
        listI32     = new LinkedList<Integer>();
        listI64     = new LinkedList<Long>();
        listU08     = new LinkedList<Integer/*U08*/>();
        listU16     = new LinkedList<Integer/*U16*/>();
        listU32     = new LinkedList<Long/*U32*/>();
        listU64     = new LinkedList<BigInteger>();
        listSingle  = new LinkedList<Float>();
        listDouble  = new LinkedList<Double>();
        listBoolean = new LinkedList<Boolean>();
        listString  = new LinkedList<String>();
        listEnum    = new LinkedList<Gender>();
        listStruct  = new LinkedList<Custom>();
    }

    public TestList reuse()
    {
        listI08.clear();
        listI16.clear();
        listI32.clear();
        listI64.clear();
        listU08.clear();
        listU16.clear();
        listU32.clear();
        listU64.clear();
        listSingle.clear();
        listDouble.clear();
        listBoolean.clear();
        listString.clear();
        listEnum.clear();
        listStruct.clear();
        return this;
    }

    /** 有符号的8位整数 */
    @invar.lib.InvarRule(T="vec<int8>", S="f0")
    public LinkedList<java.lang.Byte> getListI08() { return listI08; }
    /** 有符号的16位整数 */
    @invar.lib.InvarRule(T="vec<int16>", S="f1")
    public LinkedList<Short> getListI16() { return listI16; }
    /** 有符号的32位整数 */
    @invar.lib.InvarRule(T="vec<int32>", S="f2")
    public LinkedList<Integer> getListI32() { return listI32; }
    /** 有符号的64位整数 */
    @invar.lib.InvarRule(T="vec<int64>", S="f3")
    public LinkedList<Long> getListI64() { return listI64; }
    /** 无符号的8位整数 */
    @invar.lib.InvarRule(T="vec<uint8>", S="f4")
    public LinkedList<Integer/*U08*/> getListU08() { return listU08; }
    /** 无符号的16位整数 */
    @invar.lib.InvarRule(T="vec<uint16>", S="f5")
    public LinkedList<Integer/*U16*/> getListU16() { return listU16; }
    /** 无符号的32位整数 */
    @invar.lib.InvarRule(T="vec<uint32>", S="f6")
    public LinkedList<Long/*U32*/> getListU32() { return listU32; }
    /** 无符号的64位整数 */
    @invar.lib.InvarRule(T="vec<uint64>", S="f7")
    public LinkedList<BigInteger> getListU64() { return listU64; }
    /** 单精度浮点小数 */
    @invar.lib.InvarRule(T="vec<float>", S="f8")
    public LinkedList<Float> getListSingle() { return listSingle; }
    /** 双精度浮点小数 */
    @invar.lib.InvarRule(T="vec<double>", S="f9")
    public LinkedList<java.lang.Double> getListDouble() { return listDouble; }
    /** 布尔值 */
    @invar.lib.InvarRule(T="vec<bool>", S="f10")
    public LinkedList<java.lang.Boolean> getListBoolean() { return listBoolean; }
    /** 字符串 */
    @invar.lib.InvarRule(T="vec<string>", S="f11")
    public LinkedList<java.lang.String> getListString() { return listString; }
    /** 枚举值 */
    @invar.lib.InvarRule(T="vec<test.abc.Gender>", S="f12")
    public LinkedList<Gender> getListEnum() { return listEnum; }
    /** 自定义结构 */
    @invar.lib.InvarRule(T="vec<test.abc.Custom>", S="f13")
    public LinkedList<Custom> getListStruct() { return listStruct; }

    /** Shallow copy */
    public TestList copy(TestList from_)
    {
        if (this == from_ || from_ == null) {
            return this;
        }
        listI08.clear();
        listI08.addAll(from_.listI08);
        listI16.clear();
        listI16.addAll(from_.listI16);
        listI32.clear();
        listI32.addAll(from_.listI32);
        listI64.clear();
        listI64.addAll(from_.listI64);
        listU08.clear();
        listU08.addAll(from_.listU08);
        listU16.clear();
        listU16.addAll(from_.listU16);
        listU32.clear();
        listU32.addAll(from_.listU32);
        listU64.clear();
        listU64.addAll(from_.listU64);
        listSingle.clear();
        listSingle.addAll(from_.listSingle);
        listDouble.clear();
        listDouble.addAll(from_.listDouble);
        listBoolean.clear();
        listBoolean.addAll(from_.listBoolean);
        listString.clear();
        listString.addAll(from_.listString);
        listEnum.clear();
        listEnum.addAll(from_.listEnum);
        listStruct.clear();
        listStruct.addAll(from_.listStruct);
        return this;
    } /* copyFrom(...) */

    public void read(InputStream from_) throws IOException, CodecError
    {
        this.read((DataInput)new DataInputStream(from_));
    }

    public void read(DataInput from_) throws IOException, CodecError
    {
        listI08.clear();
        Long lenListI08 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListI08 = 0L; iListI08 < lenListI08; ++iListI08) {
            java.lang.Byte n1 = from_.readByte();
            listI08.add(n1);
        }
        listI16.clear();
        Long lenListI16 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListI16 = 0L; iListI16 < lenListI16; ++iListI16) {
            Short n1 = from_.readShort();
            listI16.add(n1);
        }
        listI32.clear();
        Long lenListI32 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListI32 = 0L; iListI32 < lenListI32; ++iListI32) {
            Integer n1 = from_.readInt();
            listI32.add(n1);
        }
        listI64.clear();
        Long lenListI64 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListI64 = 0L; iListI64 < lenListI64; ++iListI64) {
            Long n1 = from_.readLong();
            listI64.add(n1);
        }
        listU08.clear();
        Long lenListU08 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListU08 = 0L; iListU08 < lenListU08; ++iListU08) {
            Integer/*U08*/ n1 = from_.readUnsignedByte();
            listU08.add(n1);
        }
        listU16.clear();
        Long lenListU16 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListU16 = 0L; iListU16 < lenListU16; ++iListU16) {
            Integer/*U16*/ n1 = from_.readUnsignedShort();
            listU16.add(n1);
        }
        listU32.clear();
        Long lenListU32 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListU32 = 0L; iListU32 < lenListU32; ++iListU32) {
            Long/*U32*/ n1 = from_.readInt() & 0xFFFFFFFFL;
            listU32.add(n1);
        }
        listU64.clear();
        Long lenListU64 = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListU64 = 0L; iListU64 < lenListU64; ++iListU64) {
            byte[] n1Bytes = new byte[8]; from_.readFully(n1Bytes, 0, 8);
            BigInteger n1 = new BigInteger(1, n1Bytes);
            listU64.add(n1);
        }
        listSingle.clear();
        Long lenListSingle = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListSingle = 0L; iListSingle < lenListSingle; ++iListSingle) {
            Float n1 = from_.readFloat();
            listSingle.add(n1);
        }
        listDouble.clear();
        Long lenListDouble = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListDouble = 0L; iListDouble < lenListDouble; ++iListDouble) {
            java.lang.Double n1 = from_.readDouble();
            listDouble.add(n1);
        }
        listBoolean.clear();
        Long lenListBoolean = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListBoolean = 0L; iListBoolean < lenListBoolean; ++iListBoolean) {
            java.lang.Boolean n1 = from_.readBoolean();
            listBoolean.add(n1);
        }
        listString.clear();
        Long lenListString = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListString = 0L; iListString < lenListString; ++iListString) {
            java.lang.String n1 = from_.readUTF();
            listString.add(n1);
        }
        listEnum.clear();
        Long lenListEnum = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListEnum = 0L; iListEnum < lenListEnum; ++iListEnum) {
            Gender n1 = Gender.valueOf(from_.readInt());
            listEnum.add(n1);
        }
        listStruct.clear();
        Long lenListStruct = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iListStruct = 0L; iListStruct < lenListStruct; ++iListStruct) {
            Custom n1 = Custom.Create();
            n1.read(from_);
            listStruct.add(n1);
        }
    }

    public void write(OutputStream dest_) throws IOException
    {
        this.write((DataOutput)new DataOutputStream(dest_));
    }

    public void write(DataOutput dest_) throws IOException
    {
        dest_.writeInt(listI08.size());
        for (java.lang.Byte n1 : listI08) {
            dest_.writeByte(n1);
        }
        dest_.writeInt(listI16.size());
        for (Short n1 : listI16) {
            dest_.writeShort(n1);
        }
        dest_.writeInt(listI32.size());
        for (Integer n1 : listI32) {
            dest_.writeInt(n1);
        }
        dest_.writeInt(listI64.size());
        for (Long n1 : listI64) {
            dest_.writeLong(n1);
        }
        dest_.writeInt(listU08.size());
        for (Integer/*U08*/ n1 : listU08) {
            dest_.writeByte(n1);
        }
        dest_.writeInt(listU16.size());
        for (Integer/*U16*/ n1 : listU16) {
            dest_.writeShort(n1);
        }
        dest_.writeInt(listU32.size());
        for (Long/*U32*/ n1 : listU32) {
            dest_.writeInt(n1.intValue());
        }
        dest_.writeInt(listU64.size());
        for (BigInteger n1 : listU64) {
            dest_.writeLong(n1.longValue());
        }
        dest_.writeInt(listSingle.size());
        for (Float n1 : listSingle) {
            dest_.writeFloat(n1);
        }
        dest_.writeInt(listDouble.size());
        for (java.lang.Double n1 : listDouble) {
            dest_.writeDouble(n1);
        }
        dest_.writeInt(listBoolean.size());
        for (java.lang.Boolean n1 : listBoolean) {
            dest_.writeBoolean(n1);
        }
        dest_.writeInt(listString.size());
        for (java.lang.String n1 : listString) {
            dest_.writeUTF(n1);
        }
        dest_.writeInt(listEnum.size());
        for (Gender n1 : listEnum) {
            dest_.writeInt(n1.value());
        }
        dest_.writeInt(listStruct.size());
        for (Custom n1 : listStruct) {
            n1.write(dest_);
        }
    }

    public String toString()
    {
        StringBuilder s = new StringBuilder();
        s.append('{');
        s.append(getClass().getName());
        s.append(',').append("listI08").append(':');
        s.append('(').append(listI08.size()).append(')');
        s.append(',').append("listI16").append(':');
        s.append('(').append(listI16.size()).append(')');
        s.append(',').append("listI32").append(':');
        s.append('(').append(listI32.size()).append(')');
        s.append(',').append("listI64").append(':');
        s.append('(').append(listI64.size()).append(')');
        s.append(',').append("listU08").append(':');
        s.append('(').append(listU08.size()).append(')');
        s.append(',').append("listU16").append(':');
        s.append('(').append(listU16.size()).append(')');
        s.append(',').append("listU32").append(':');
        s.append('(').append(listU32.size()).append(')');
        s.append(',').append("listU64").append(':');
        s.append('(').append(listU64.size()).append(')');
        s.append(',').append("listSingle").append(':');
        s.append('(').append(listSingle.size()).append(')');
        s.append(',').append("listDouble").append(':');
        s.append('(').append(listDouble.size()).append(')');
        s.append(',').append("listBoolean").append(':');
        s.append('(').append(listBoolean.size()).append(')');
        s.append(',').append("listString").append(':');
        s.append('(').append(listString.size()).append(')');
        s.append(',').append("listEnum").append(':');
        s.append('(').append(listEnum.size()).append(')');
        s.append(',').append("listStruct").append(':');
        s.append('(').append(listStruct.size()).append(')');
        s.append('}');
        return s.toString();
    } //TestList::toString ()

    public String toStringJSON()
    {
        StringBuilder code = new StringBuilder();
        this.writeJSON(code);
        return code.toString();
    }

    public void writeJSON(StringBuilder s_)
    {
        s_.append('{');
        char comma = '\0';
        boolean listI08Exists = (null != listI08 && listI08.size() > 0);
        if (listI08Exists) { s_.append('"').append("listI08").append('"').append(':'); comma = ','; }
        int listI08Size = (null == listI08 ? 0 : listI08.size());
        if (listI08Size > 0) {
            s_.append('[');
            int listI08Idx = 0;
            for (java.lang.Byte n1 : listI08) { /* vec.for: listI08 */
                ++listI08Idx;
                s_.append(n1.toString());
                if (listI08Idx != listI08Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listI16Exists = (null != listI16 && listI16.size() > 0);
        if ('\0' != comma && listI16Exists) { s_.append(comma); comma = '\0'; }
        if (listI16Exists) { s_.append('"').append("listI16").append('"').append(':'); comma = ','; }
        int listI16Size = (null == listI16 ? 0 : listI16.size());
        if (listI16Size > 0) {
            s_.append('[');
            int listI16Idx = 0;
            for (Short n1 : listI16) { /* vec.for: listI16 */
                ++listI16Idx;
                s_.append(n1.toString());
                if (listI16Idx != listI16Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listI32Exists = (null != listI32 && listI32.size() > 0);
        if ('\0' != comma && listI32Exists) { s_.append(comma); comma = '\0'; }
        if (listI32Exists) { s_.append('"').append("listI32").append('"').append(':'); comma = ','; }
        int listI32Size = (null == listI32 ? 0 : listI32.size());
        if (listI32Size > 0) {
            s_.append('[');
            int listI32Idx = 0;
            for (Integer n1 : listI32) { /* vec.for: listI32 */
                ++listI32Idx;
                s_.append(n1.toString());
                if (listI32Idx != listI32Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listI64Exists = (null != listI64 && listI64.size() > 0);
        if ('\0' != comma && listI64Exists) { s_.append(comma); comma = '\0'; }
        if (listI64Exists) { s_.append('"').append("listI64").append('"').append(':'); comma = ','; }
        int listI64Size = (null == listI64 ? 0 : listI64.size());
        if (listI64Size > 0) {
            s_.append('[');
            int listI64Idx = 0;
            for (Long n1 : listI64) { /* vec.for: listI64 */
                ++listI64Idx;
                s_.append(n1.toString());
                if (listI64Idx != listI64Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listU08Exists = (null != listU08 && listU08.size() > 0);
        if ('\0' != comma && listU08Exists) { s_.append(comma); comma = '\0'; }
        if (listU08Exists) { s_.append('"').append("listU08").append('"').append(':'); comma = ','; }
        int listU08Size = (null == listU08 ? 0 : listU08.size());
        if (listU08Size > 0) {
            s_.append('[');
            int listU08Idx = 0;
            for (Integer/*U08*/ n1 : listU08) { /* vec.for: listU08 */
                ++listU08Idx;
                s_.append(n1.toString());
                if (listU08Idx != listU08Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listU16Exists = (null != listU16 && listU16.size() > 0);
        if ('\0' != comma && listU16Exists) { s_.append(comma); comma = '\0'; }
        if (listU16Exists) { s_.append('"').append("listU16").append('"').append(':'); comma = ','; }
        int listU16Size = (null == listU16 ? 0 : listU16.size());
        if (listU16Size > 0) {
            s_.append('[');
            int listU16Idx = 0;
            for (Integer/*U16*/ n1 : listU16) { /* vec.for: listU16 */
                ++listU16Idx;
                s_.append(n1.toString());
                if (listU16Idx != listU16Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listU32Exists = (null != listU32 && listU32.size() > 0);
        if ('\0' != comma && listU32Exists) { s_.append(comma); comma = '\0'; }
        if (listU32Exists) { s_.append('"').append("listU32").append('"').append(':'); comma = ','; }
        int listU32Size = (null == listU32 ? 0 : listU32.size());
        if (listU32Size > 0) {
            s_.append('[');
            int listU32Idx = 0;
            for (Long/*U32*/ n1 : listU32) { /* vec.for: listU32 */
                ++listU32Idx;
                s_.append(n1.toString());
                if (listU32Idx != listU32Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listU64Exists = (null != listU64 && listU64.size() > 0);
        if ('\0' != comma && listU64Exists) { s_.append(comma); comma = '\0'; }
        if (listU64Exists) { s_.append('"').append("listU64").append('"').append(':'); comma = ','; }
        int listU64Size = (null == listU64 ? 0 : listU64.size());
        if (listU64Size > 0) {
            s_.append('[');
            int listU64Idx = 0;
            for (BigInteger n1 : listU64) { /* vec.for: listU64 */
                ++listU64Idx;
                s_.append(n1.toString());
                if (listU64Idx != listU64Size) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listSingleExists = (null != listSingle && listSingle.size() > 0);
        if ('\0' != comma && listSingleExists) { s_.append(comma); comma = '\0'; }
        if (listSingleExists) { s_.append('"').append("listSingle").append('"').append(':'); comma = ','; }
        int listSingleSize = (null == listSingle ? 0 : listSingle.size());
        if (listSingleSize > 0) {
            s_.append('[');
            int listSingleIdx = 0;
            for (Float n1 : listSingle) { /* vec.for: listSingle */
                ++listSingleIdx;
                s_.append(n1.toString());
                if (listSingleIdx != listSingleSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listDoubleExists = (null != listDouble && listDouble.size() > 0);
        if ('\0' != comma && listDoubleExists) { s_.append(comma); comma = '\0'; }
        if (listDoubleExists) { s_.append('"').append("listDouble").append('"').append(':'); comma = ','; }
        int listDoubleSize = (null == listDouble ? 0 : listDouble.size());
        if (listDoubleSize > 0) {
            s_.append('[');
            int listDoubleIdx = 0;
            for (java.lang.Double n1 : listDouble) { /* vec.for: listDouble */
                ++listDoubleIdx;
                s_.append(n1.toString());
                if (listDoubleIdx != listDoubleSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listBooleanExists = (null != listBoolean && listBoolean.size() > 0);
        if ('\0' != comma && listBooleanExists) { s_.append(comma); comma = '\0'; }
        if (listBooleanExists) { s_.append('"').append("listBoolean").append('"').append(':'); comma = ','; }
        int listBooleanSize = (null == listBoolean ? 0 : listBoolean.size());
        if (listBooleanSize > 0) {
            s_.append('[');
            int listBooleanIdx = 0;
            for (java.lang.Boolean n1 : listBoolean) { /* vec.for: listBoolean */
                ++listBooleanIdx;
                s_.append(n1.toString().toLowerCase());
                if (listBooleanIdx != listBooleanSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listStringExists = (null != listString && listString.size() > 0);
        if ('\0' != comma && listStringExists) { s_.append(comma); comma = '\0'; }
        if (listStringExists) { s_.append('"').append("listString").append('"').append(':'); comma = ','; }
        int listStringSize = (null == listString ? 0 : listString.size());
        if (listStringSize > 0) {
            s_.append('[');
            int listStringIdx = 0;
            for (java.lang.String n1 : listString) { /* vec.for: listString */
                ++listStringIdx;
                s_.append('"').append(n1.toString()).append('"');
                if (listStringIdx != listStringSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listEnumExists = (null != listEnum && listEnum.size() > 0);
        if ('\0' != comma && listEnumExists) { s_.append(comma); comma = '\0'; }
        if (listEnumExists) { s_.append('"').append("listEnum").append('"').append(':'); comma = ','; }
        int listEnumSize = (null == listEnum ? 0 : listEnum.size());
        if (listEnumSize > 0) {
            s_.append('[');
            int listEnumIdx = 0;
            for (Gender n1 : listEnum) { /* vec.for: listEnum */
                ++listEnumIdx;
                s_.append(n1.value());
                if (listEnumIdx != listEnumSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean listStructExists = (null != listStruct && listStruct.size() > 0);
        if ('\0' != comma && listStructExists) { s_.append(comma); comma = '\0'; }
        if (listStructExists) { s_.append('"').append("listStruct").append('"').append(':'); comma = ','; }
        int listStructSize = (null == listStruct ? 0 : listStruct.size());
        if (listStructSize > 0) {
            s_.append('[');
            int listStructIdx = 0;
            for (Custom n1 : listStruct) { /* vec.for: listStruct */
                ++listStructIdx;
                n1.writeJSON(s_);
                if (listStructIdx != listStructSize) { s_.append(','); }
            }
            s_.append(']');
        }
        s_.append('}');
    } /* TestList::writeJSON(...) */

    public String toStringXML()
    {
        StringBuilder code = new StringBuilder();
        this.writeXML(code, "TestList");
        return code.toString();
    }

    public void writeXML(StringBuilder result_, String name_)
    {
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes = new StringBuilder();
        if (listI08.size() > 0) {
            nodes.append('<').append("listI08").append('>');
            for (java.lang.Byte n1 : listI08) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listI08").append('>');
        }
        if (listI16.size() > 0) {
            nodes.append('<').append("listI16").append('>');
            for (Short n1 : listI16) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listI16").append('>');
        }
        if (listI32.size() > 0) {
            nodes.append('<').append("listI32").append('>');
            for (Integer n1 : listI32) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listI32").append('>');
        }
        if (listI64.size() > 0) {
            nodes.append('<').append("listI64").append('>');
            for (Long n1 : listI64) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listI64").append('>');
        }
        if (listU08.size() > 0) {
            nodes.append('<').append("listU08").append('>');
            for (Integer/*U08*/ n1 : listU08) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listU08").append('>');
        }
        if (listU16.size() > 0) {
            nodes.append('<').append("listU16").append('>');
            for (Integer/*U16*/ n1 : listU16) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listU16").append('>');
        }
        if (listU32.size() > 0) {
            nodes.append('<').append("listU32").append('>');
            for (Long/*U32*/ n1 : listU32) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listU32").append('>');
        }
        if (listU64.size() > 0) {
            nodes.append('<').append("listU64").append('>');
            for (BigInteger n1 : listU64) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listU64").append('>');
        }
        if (listSingle.size() > 0) {
            nodes.append('<').append("listSingle").append('>');
            for (Float n1 : listSingle) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listSingle").append('>');
        }
        if (listDouble.size() > 0) {
            nodes.append('<').append("listDouble").append('>');
            for (java.lang.Double n1 : listDouble) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listDouble").append('>');
        }
        if (listBoolean.size() > 0) {
            nodes.append('<').append("listBoolean").append('>');
            for (java.lang.Boolean n1 : listBoolean) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listBoolean").append('>');
        }
        if (listString.size() > 0) {
            nodes.append('<').append("listString").append('>');
            for (java.lang.String n1 : listString) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listString").append('>');
        }
        if (listEnum.size() > 0) {
            nodes.append('<').append("listEnum").append('>');
            for (Gender n1 : listEnum) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.value()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("listEnum").append('>');
        }
        if (listStruct.size() > 0) {
            nodes.append('<').append("listStruct").append('>');
            for (Custom n1 : listStruct) {
                n1.writeXML(nodes, "n1");
            }
            nodes.append('<').append('/').append("listStruct").append('>');
        }
        result_.append('<').append(name_).append(attrs);
        if (nodes.length() == 0) {
            result_.append('/').append('>');
        } else {
            result_.append('>').append(nodes);
            result_.append('<').append('/').append(name_).append('>');
        }
    } /* TestList::writeXML(...) */

}

