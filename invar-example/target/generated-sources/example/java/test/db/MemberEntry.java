/*===----------------------------*  Java 6  *------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.db;

import invar.lib.CodecError;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/** 名字冲突的类型 */
public final class MemberEntry
implements
invar.lib.InvarCodec.BinaryDecode,
invar.lib.InvarCodec.BinaryEncode,
invar.lib.InvarCodec.XMLEncode
{
    static public final long CRC32 = 0x00240151L;

    static public MemberEntry Create()
    {
        return new MemberEntry();
    }

    private Long/*U32*/                  id        ;/* 主键，自增长 */
    private String                       phone     ;/* 手机号码 */
    private String                       nickName  ;/* 会员昵称 */
    private Long                         createTime;/* 创建时间 */
    private Long                         updateTime;/* 创建时间 */
    private LinkedHashMap<String,String> hotfix    ;/* [AutoAdd] Hotfix */

    public MemberEntry()
    {
        id         = 0L;
        phone      = "";
        nickName   = "";
        createTime = -1L;
        updateTime = -1L;
        hotfix     = null;
    }

    public MemberEntry reuse()
    {
        id = 0L;
        phone = "";
        nickName = "";
        createTime = -1L;
        updateTime = -1L;
        if (hotfix != null) {
            hotfix.clear();
        }
        return this;
    }

    /** 主键，自增长 */
    @invar.lib.InvarRule(T="uint32", S="f0")
    public Long/*U32*/ getId() { return id; }
    /** 手机号码 */
    @invar.lib.InvarRule(T="string", S="f1")
    public String getPhone() { return phone; }
    /** 会员昵称 */
    @invar.lib.InvarRule(T="string", S="f2")
    public String getNickName() { return nickName; }
    /** 创建时间 */
    @invar.lib.InvarRule(T="int64", S="f3")
    public Long getCreateTime() { return createTime; }
    /** 创建时间 */
    @invar.lib.InvarRule(T="int64", S="f4")
    public Long getUpdateTime() { return updateTime; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f5")
    public LinkedHashMap<java.lang.String,java.lang.String> getHotfix() { return hotfix; }

    /** 主键，自增长 */
    @invar.lib.InvarRule(T="uint32", S="f0")
    public void setId(long value) throws NumberFormatException
    {
        if (value < 0 || value > 0xFFFFFFFFL) {
            throw new NumberFormatException("uint32 value out of range: " + value);
        }
        this.id = value;
    }
    /** 手机号码 */
    @invar.lib.InvarRule(T="string", S="f1")
    public void setPhone(String value) { this.phone = value; }
    /** 会员昵称 */
    @invar.lib.InvarRule(T="string", S="f2")
    public void setNickName(String value) { this.nickName = value; }
    /** 创建时间 */
    @invar.lib.InvarRule(T="int64", S="f3")
    public void setCreateTime(Long value) { this.createTime = value; }
    /** 创建时间 */
    @invar.lib.InvarRule(T="int64", S="f4")
    public void setUpdateTime(Long value) { this.updateTime = value; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f5")
    public void setHotfix(LinkedHashMap<java.lang.String,java.lang.String> value) { this.hotfix = value; }

    /** Shallow copy */
    public MemberEntry copy(MemberEntry from_)
    {
        if (this == from_ || from_ == null) {
            return this;
        }
        id = from_.id;
        phone = from_.phone;
        nickName = from_.nickName;
        createTime = from_.createTime;
        updateTime = from_.updateTime;
        if (null == from_.hotfix) {
            hotfix = null;
        } else {
            if (null == hotfix) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            else { hotfix.clear(); }
            hotfix.putAll(from_.hotfix);
        }
        return this;
    } /* copyFrom(...) */

    public void read(InputStream from_) throws IOException, CodecError
    {
        this.read((DataInput)new DataInputStream(from_));
    }

    public void read(DataInput from_) throws IOException, CodecError
    {
        id = from_.readInt() & 0xFFFFFFFFL;
        phone = from_.readUTF();
        nickName = from_.readUTF();
        createTime = from_.readLong();
        updateTime = from_.readLong();
        byte hotfixExists = from_.readByte();
        if ((byte)0x01 == hotfixExists) {
            if (hotfix == null) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            Long lenHotfix = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iHotfix = 0L; iHotfix < lenHotfix; ++iHotfix) {
                java.lang.String k1 = from_.readUTF();
                java.lang.String v1 = from_.readUTF();
                hotfix.put(k1,v1);
            }
        }
        else if ((byte)0x00 == hotfixExists) { hotfix = null; }
        else { throw new CodecError(CodecError.ERR_DECODE_VEC_MAP_P); }
    }

    public void write(OutputStream dest_) throws IOException
    {
        this.write((DataOutput)new DataOutputStream(dest_));
    }

    public void write(DataOutput dest_) throws IOException
    {
        dest_.writeInt(id.intValue());
        dest_.writeUTF(phone);
        dest_.writeUTF(nickName);
        dest_.writeLong(createTime);
        dest_.writeLong(updateTime);
        if (hotfix != null) {
            dest_.writeByte((byte)0x01);
            dest_.writeInt(hotfix.size());
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                dest_.writeUTF(k1);
                java.lang.String v1 = hotfixIter.getValue();
                dest_.writeUTF(v1);
            }
        } else {
            dest_.writeByte((byte)0x00);
        }
    }

    public String toString()
    {
        StringBuilder s = new StringBuilder();
        s.append('{');
        s.append(getClass().getName());
        s.append(',').append("id").append(':');
        s.append(id.toString());
        s.append(',').append("phone").append(':');
        s.append('"').append(phone).append('"');
        s.append(',').append("nickName").append(':');
        s.append('"').append(nickName).append('"');
        s.append(',').append("createTime").append(':');
        s.append(createTime.toString());
        s.append(',').append("updateTime").append(':');
        s.append(updateTime.toString());
        s.append(", hotfix:");
        if (hotfix != null) {
            s.append('[').append(hotfix.size()).append(']');
        } else {
            s.append("null");
        }
        s.append('}');
        return s.toString();
    } //MemberEntry::toString ()

    public String toStringJSON()
    {
        StringBuilder code = new StringBuilder();
        this.writeJSON(code);
        return code.toString();
    }

    public void writeJSON(StringBuilder s_)
    {
        s_.append('{');
        char comma = '\0';
        s_.append('"').append("id").append('"').append(':');
        s_.append(id.toString()); comma = ',';
        boolean phoneExists = phone != null && phone.length() > 0;
        if ('\0' != comma && phoneExists) { s_.append(comma); comma = '\0'; }
        if (phoneExists) {
            s_.append('"').append("phone").append('"').append(':'); comma = ','; s_.append('"').append(phone.toString()).append('"');
        }
        boolean nickNameExists = nickName != null && nickName.length() > 0;
        if ('\0' != comma && nickNameExists) { s_.append(comma); comma = '\0'; }
        if (nickNameExists) {
            s_.append('"').append("nickName").append('"').append(':'); comma = ','; s_.append('"').append(nickName.toString()).append('"');
        }
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("createTime").append('"').append(':');
        s_.append(createTime.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("updateTime").append('"').append(':');
        s_.append(updateTime.toString()); comma = ',';
        boolean hotfixExists = (null != hotfix && hotfix.size() > 0);
        if ('\0' != comma && hotfixExists) { s_.append(comma); comma = '\0'; }
        if (hotfixExists) {
            s_.append('"').append("hotfix").append('"').append(':'); comma = ',';
            int hotfixSize = (null == hotfix ? 0 : hotfix.size());
            if (hotfixSize > 0) {
                s_.append('{');
                int hotfixIdx = 0;
                for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) { /* map.for: hotfix */
                    ++hotfixIdx;
                    java.lang.String k1 = hotfixIter.getKey(); /* nest.k */
                    s_.append('"').append(k1.toString()).append('"'); s_.append(':');
                    java.lang.String v1 = hotfixIter.getValue(); /* nest.v */
                    s_.append('"').append(v1.toString()).append('"');
                    if (hotfixIdx != hotfixSize) { s_.append(','); }
                }
                s_.append('}');
            }
        }
        s_.append('}');
    } /* MemberEntry::writeJSON(...) */

    public String toStringXML()
    {
        StringBuilder code = new StringBuilder();
        this.writeXML(code, "MemberEntry");
        return code.toString();
    }

    public void writeXML(StringBuilder result_, String name_)
    {
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes = new StringBuilder();
        attrs.append(' ').append("id").append('=').append('"');
        attrs.append(id.toString()).append('"');
        attrs.append(' ').append("phone").append('=').append('"');
        attrs.append(phone).append('"');
        attrs.append(' ').append("nickName").append('=').append('"');
        attrs.append(nickName).append('"');
        attrs.append(' ').append("createTime").append('=').append('"');
        attrs.append(createTime.toString()).append('"');
        attrs.append(' ').append("updateTime").append('=').append('"');
        attrs.append(updateTime.toString()).append('"');
        if (hotfix != null && hotfix.size() > 0) {
            nodes.append('<').append("hotfix").append('>');
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1).append('"').append('/').append('>');
                java.lang.String v1 = hotfixIter.getValue();
                nodes.append('<').append("v1").append(' ').append("value").append('=').append('"');
                nodes.append(v1).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("hotfix").append('>');
        }
        result_.append('<').append(name_).append(attrs);
        if (nodes.length() == 0) {
            result_.append('/').append('>');
        } else {
            result_.append('>').append(nodes);
            result_.append('<').append('/').append(name_).append('>');
        }
    } /* MemberEntry::writeXML(...) */

    public Object[] sqlParamsAll()
    {
        return new Object[] {
            phone,
            nickName,
        };
    }

    static public final class SQL {

        static public final String TABLE = "tbl_member";

        static public invar.lib.InvarSQL getBuilder() {
            if (builder == null) {
                builder = invar.lib.InvarSQL.Create(
                    TABLE, getWritableFields(), getAliasMap());
            }
            return builder;
        }

        static private invar.lib.InvarSQL builder = null;

        static private List<String> writableFields = null;

        static private List<String> getWritableFields() {
            if (writableFields != null) {
                return writableFields;
            }
            List<String> list = new ArrayList<String>();
            list.add("phone");
            list.add("nick_name");
            return writableFields = list;
        }

        static private Map<String, String> aliasMap = null;

        static private Map<String, String> getAliasMap() {
            if (aliasMap != null) {
                return aliasMap;
            }
            Map<String, String> map = new LinkedHashMap<String, String>();
            map.put("id", "id");
            map.put("phone", "phone");
            map.put("nick_name", "nickName");
            map.put("create_time", "createTime");
            map.put("update_time", "updateTime");
            return aliasMap = map;
        }

    }

}

