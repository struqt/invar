/*===----------------------------*  Java 6  *------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.abc;

import invar.lib.CodecError;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;

/** Test comments */
public final class Info
implements
invar.lib.InvarCodec.BinaryDecode,
invar.lib.InvarCodec.BinaryEncode,
invar.lib.InvarCodec.XMLEncode,
invar.lib.InvarCodec.JSONEncode
{
    static public final long CRC32 = 0x120FDCDBL;

    static public Info Create()
    {
        return new Info();
    }

    private Integer                       key          ;
    private Byte                          number01     ;
    private Short                         number02     ;
    private Integer                       number03     ;
    private Long                          number04     ;/* Test field comments */
    private Integer/*U08*/                number05     ;
    private Integer/*U16*/                number06     ;
    private Long/*U32*/                   number07     ;
    private BigInteger                    number08     ;
    private Float                         number09     ;
    private Double                        number10     ;
    private Boolean                       isReal       ;
    private String                        s            ;/* a string */
    private LinkedList<String>            world        ;
    private Gender                        gender       ;
    private Info                          next         ;
    private test.abc.Conflict             conflict     ;
    private LinkedList<test.xyz.Conflict> conflicts    ;
    private LinkedList<Double>            numbers      ;
    private LinkedHashMap<Info,Gender>    mapInfoG     ;
    private LinkedHashMap<Gender,Info>    mapGenderInfo;
    private LinkedHashMap<Integer,Double> mapDouble    ;
    private LinkedHashMap<String,String>  hotfix       ;/* [AutoAdd] Hotfix */

    public Info()
    {
        key           = 123;
        number01      = -1;
        number02      = -1;
        number03      = -1;
        number04      = -1L;
        number05      = 0;
        number06      = 0;
        number07      = 0L;
        number08      = BigInteger.valueOf(0L);
        number09      = 0.0F;
        number10      = 0.00;
        isReal        = false;
        s             = "hello";
        world         = new LinkedList<String>();
        gender        = Gender.NONE;
        next          = null;
        conflict      = test.abc.Conflict.Create();
        conflicts     = new LinkedList<test.xyz.Conflict>();
        numbers       = new LinkedList<Double>();
        mapInfoG      = new LinkedHashMap<Info,Gender>();
        mapGenderInfo = new LinkedHashMap<Gender,Info>();
        mapDouble     = new LinkedHashMap<Integer,Double>();
        hotfix        = null;
    }

    public Info reuse()
    {
        key = 123;
        number01 = -1;
        number02 = -1;
        number03 = -1;
        number04 = -1L;
        number05 = 0;
        number06 = 0;
        number07 = 0L;
        number08 = BigInteger.valueOf(0L);
        number09 = 0.0F;
        number10 = 0.00;
        isReal = false;
        s = "hello";
        world.clear();
        gender = Gender.NONE;
        if (next != null) {
            next.reuse();
        }
        conflict.reuse();
        conflicts.clear();
        numbers.clear();
        mapInfoG.clear();
        mapGenderInfo.clear();
        mapDouble.clear();
        if (hotfix != null) {
            hotfix.clear();
        }
        return this;
    }

    /**  */
    @invar.lib.InvarRule(T="int32", S="f0")
    public Integer getKey() { return key; }
    /**  */
    @invar.lib.InvarRule(T="int8", S="f1")
    public Byte getNumber01() { return number01; }
    /**  */
    @invar.lib.InvarRule(T="int16", S="f2")
    public Short getNumber02() { return number02; }
    /**  */
    @invar.lib.InvarRule(T="int32", S="f3")
    public Integer getNumber03() { return number03; }
    /** Test field comments */
    @invar.lib.InvarRule(T="int64", S="f4")
    public Long getNumber04() { return number04; }
    /**  */
    @invar.lib.InvarRule(T="uint8", S="f5")
    public Integer/*U08*/ getNumber05() { return number05; }
    /**  */
    @invar.lib.InvarRule(T="uint16", S="f6")
    public Integer/*U16*/ getNumber06() { return number06; }
    /**  */
    @invar.lib.InvarRule(T="uint32", S="f7")
    public Long/*U32*/ getNumber07() { return number07; }
    /**  */
    @invar.lib.InvarRule(T="uint64", S="f8")
    public BigInteger getNumber08() { return number08; }
    /**  */
    @invar.lib.InvarRule(T="float", S="f9")
    public Float getNumber09() { return number09; }
    /**  */
    @invar.lib.InvarRule(T="double", S="f10")
    public Double getNumber10() { return number10; }
    /**  */
    @invar.lib.InvarRule(T="bool", S="f11")
    public Boolean getIsReal() { return isReal; }
    /** a string */
    @invar.lib.InvarRule(T="string", S="f12")
    public String getS() { return s; }
    /**  */
    @invar.lib.InvarRule(T="vec<string>", S="f13")
    public LinkedList<java.lang.String> getWorld() { return world; }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Gender", S="f14")
    public Gender getGender() { return gender; }
    public Integer getGenderV() { return gender.value(); }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Info", S="f15")
    public Info getNext() { return next; }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Conflict", S="f16")
    public test.abc.Conflict getConflict() { return conflict; }
    /**  */
    @invar.lib.InvarRule(T="vec<test.xyz.Conflict>", S="f17")
    public LinkedList<test.xyz.Conflict> getConflicts() { return conflicts; }
    /**  */
    @invar.lib.InvarRule(T="vec<double>", S="f18")
    public LinkedList<java.lang.Double> getNumbers() { return numbers; }
    /**  */
    @invar.lib.InvarRule(T="map<test.abc.Info,test.abc.Gender>", S="f19")
    public LinkedHashMap<Info,Gender> getMapInfoG() { return mapInfoG; }
    /**  */
    @invar.lib.InvarRule(T="map<test.abc.Gender,test.abc.Info>", S="f20")
    public LinkedHashMap<Gender,Info> getMapGenderInfo() { return mapGenderInfo; }
    /**  */
    @invar.lib.InvarRule(T="map<int32,double>", S="f21")
    public LinkedHashMap<Integer,java.lang.Double> getMapDouble() { return mapDouble; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f22")
    public LinkedHashMap<java.lang.String,java.lang.String> getHotfix() { return hotfix; }

    /**  */
    @invar.lib.InvarRule(T="int32", S="f0")
    public void setKey(Integer value) { this.key = value; }
    /**  */
    @invar.lib.InvarRule(T="int8", S="f1")
    public void setNumber01(Byte value) { this.number01 = value; }
    public void setNumber01(int value) throws NumberFormatException
    {
        if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {
            throw new NumberFormatException("int8 value out of range: " + value);
        }
        this.number01 = Integer.valueOf(value).byteValue();
    }
    /**  */
    @invar.lib.InvarRule(T="int16", S="f2")
    public void setNumber02(Short value) { this.number02 = value; }
    public void setNumber02(int value) throws NumberFormatException
    {
        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
            throw new NumberFormatException("int16 value out of range: " + value);
        }
        this.number02 = Integer.valueOf(value).shortValue();
    }
    /**  */
    @invar.lib.InvarRule(T="int32", S="f3")
    public void setNumber03(Integer value) { this.number03 = value; }
    /** Test field comments */
    @invar.lib.InvarRule(T="int64", S="f4")
    public void setNumber04(Long value) { this.number04 = value; }
    /**  */
    @invar.lib.InvarRule(T="uint8", S="f5")
    public void setNumber05(int value) throws NumberFormatException
    {
        if (value < 0 || value > 0xFF) {
            throw new NumberFormatException("uint8 value out of range: " + value);
        }
        this.number05 = value;
    }
    /**  */
    @invar.lib.InvarRule(T="uint16", S="f6")
    public void setNumber06(int value) throws NumberFormatException
    {
        if (value < 0 || value > 0xFFFF) {
            throw new NumberFormatException("uint16 value out of range: " + value);
        }
        this.number06 = value;
    }
    /**  */
    @invar.lib.InvarRule(T="uint32", S="f7")
    public void setNumber07(long value) throws NumberFormatException
    {
        if (value < 0 || value > 0xFFFFFFFFL) {
            throw new NumberFormatException("uint32 value out of range: " + value);
        }
        this.number07 = value;
    }
    /**  */
    @invar.lib.InvarRule(T="uint64", S="f8")
    public void setNumber08(BigInteger value) { this.number08 = value; }
    /**  */
    @invar.lib.InvarRule(T="float", S="f9")
    public void setNumber09(Float value) { this.number09 = value; }
    /**  */
    @invar.lib.InvarRule(T="double", S="f10")
    public void setNumber10(Double value) { this.number10 = value; }
    /**  */
    @invar.lib.InvarRule(T="bool", S="f11")
    public void setIsReal(Boolean value) { this.isReal = value; }
    /** a string */
    @invar.lib.InvarRule(T="string", S="f12")
    public void setS(String value) { this.s = value; }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Gender", S="f14")
    public void setGender(Gender value) { this.gender = value; }
    public void setGenderV(Integer value) { this.gender = Gender.valueOf(value); }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Info", S="f15")
    public void setNext(Info value) { this.next = value; }
    /**  */
    @invar.lib.InvarRule(T="test.abc.Conflict", S="f16")
    public void setConflict(test.abc.Conflict value) { this.conflict = value; }
    /** [AutoAdd] Hotfix */
    @invar.lib.InvarRule(T="map<string,string>", S="f22")
    public void setHotfix(LinkedHashMap<java.lang.String,java.lang.String> value) { this.hotfix = value; }

    /** Shallow copy */
    public Info copy(Info from_)
    {
        if (this == from_ || from_ == null) {
            return this;
        }
        key = from_.key;
        number01 = from_.number01;
        number02 = from_.number02;
        number03 = from_.number03;
        number04 = from_.number04;
        number05 = from_.number05;
        number06 = from_.number06;
        number07 = from_.number07;
        number08 = from_.number08;
        number09 = from_.number09;
        number10 = from_.number10;
        isReal = from_.isReal;
        s = from_.s;
        world.clear();
        world.addAll(from_.world);
        gender = from_.gender;
        if (from_.next != null) {
            next.copy(from_.next);
        } else {
            next = null;
        }
        conflict = from_.conflict;
        conflicts.clear();
        conflicts.addAll(from_.conflicts);
        numbers.clear();
        numbers.addAll(from_.numbers);
        mapInfoG.clear();
        mapInfoG.putAll(from_.mapInfoG);
        mapGenderInfo.clear();
        mapGenderInfo.putAll(from_.mapGenderInfo);
        mapDouble.clear();
        mapDouble.putAll(from_.mapDouble);
        if (null == from_.hotfix) {
            hotfix = null;
        } else {
            if (null == hotfix) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            else { hotfix.clear(); }
            hotfix.putAll(from_.hotfix);
        }
        return this;
    } /* copyFrom(...) */

    public void read(InputStream from_) throws IOException, CodecError
    {
        this.read((DataInput)new DataInputStream(from_));
    }

    public void read(DataInput from_) throws IOException, CodecError
    {
        key = from_.readInt();
        number01 = from_.readByte();
        number02 = from_.readShort();
        number03 = from_.readInt();
        number04 = from_.readLong();
        number05 = from_.readUnsignedByte();
        number06 = from_.readUnsignedShort();
        number07 = from_.readInt() & 0xFFFFFFFFL;
        byte[] number08Bytes = new byte[8]; from_.readFully(number08Bytes, 0, 8);
        number08 = new BigInteger(1, number08Bytes);
        number09 = from_.readFloat();
        number10 = from_.readDouble();
        isReal = from_.readBoolean();
        s = from_.readUTF();
        world.clear();
        Long lenWorld = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iWorld = 0L; iWorld < lenWorld; ++iWorld) {
            java.lang.String n1 = from_.readUTF();
            world.add(n1);
        }
        gender = Gender.valueOf(from_.readInt());
        byte nextExists = from_.readByte();
        if ((byte)0x01 == nextExists) {
            if (next == null) { next = Info.Create(); }
            next.read(from_);
        }
        else if ((byte)0x00 == nextExists) { next = null; }
        else { throw new CodecError(CodecError.ERR_DECODE_STRUCT_P); }
        conflict.read(from_);
        conflicts.clear();
        Long lenConflicts = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iConflicts = 0L; iConflicts < lenConflicts; ++iConflicts) {
            test.xyz.Conflict n1 = test.xyz.Conflict.Create();
            n1.read(from_);
            conflicts.add(n1);
        }
        numbers.clear();
        Long lenNumbers = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iNumbers = 0L; iNumbers < lenNumbers; ++iNumbers) {
            java.lang.Double n1 = from_.readDouble();
            numbers.add(n1);
        }
        mapInfoG.clear();
        Long lenMapInfoG = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMapInfoG = 0L; iMapInfoG < lenMapInfoG; ++iMapInfoG) {
            Info k1 = Info.Create();
            k1.read(from_);
            Gender v1 = Gender.valueOf(from_.readInt());
            mapInfoG.put(k1,v1);
        }
        mapGenderInfo.clear();
        Long lenMapGenderInfo = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMapGenderInfo = 0L; iMapGenderInfo < lenMapGenderInfo; ++iMapGenderInfo) {
            Gender k1 = Gender.valueOf(from_.readInt());
            Info v1 = Info.Create();
            v1.read(from_);
            mapGenderInfo.put(k1,v1);
        }
        mapDouble.clear();
        Long lenMapDouble = from_.readInt() & 0xFFFFFFFFL;
        for (Long/*U32*/ iMapDouble = 0L; iMapDouble < lenMapDouble; ++iMapDouble) {
            Integer k1 = from_.readInt();
            java.lang.Double v1 = from_.readDouble();
            mapDouble.put(k1,v1);
        }
        byte hotfixExists = from_.readByte();
        if ((byte)0x01 == hotfixExists) {
            if (hotfix == null) { hotfix = new LinkedHashMap<java.lang.String,java.lang.String>(); }
            Long lenHotfix = from_.readInt() & 0xFFFFFFFFL;
            for (Long/*U32*/ iHotfix = 0L; iHotfix < lenHotfix; ++iHotfix) {
                java.lang.String k1 = from_.readUTF();
                java.lang.String v1 = from_.readUTF();
                hotfix.put(k1,v1);
            }
        }
        else if ((byte)0x00 == hotfixExists) { hotfix = null; }
        else { throw new CodecError(CodecError.ERR_DECODE_VEC_MAP_P); }
    }

    public void write(OutputStream dest_) throws IOException
    {
        this.write((DataOutput)new DataOutputStream(dest_));
    }

    public void write(DataOutput dest_) throws IOException
    {
        dest_.writeInt(key);
        dest_.writeByte(number01);
        dest_.writeShort(number02);
        dest_.writeInt(number03);
        dest_.writeLong(number04);
        dest_.writeByte(number05);
        dest_.writeShort(number06);
        dest_.writeInt(number07.intValue());
        dest_.writeLong(number08.longValue());
        dest_.writeFloat(number09);
        dest_.writeDouble(number10);
        dest_.writeBoolean(isReal);
        dest_.writeUTF(s);
        dest_.writeInt(world.size());
        for (java.lang.String n1 : world) {
            dest_.writeUTF(n1);
        }
        dest_.writeInt(gender.value());
        if (next != null) {
            dest_.writeByte((byte)0x01);
            next.write(dest_);
        } else {
            dest_.writeByte((byte)0x00);
        }
        conflict.write(dest_);
        dest_.writeInt(conflicts.size());
        for (test.xyz.Conflict n1 : conflicts) {
            n1.write(dest_);
        }
        dest_.writeInt(numbers.size());
        for (java.lang.Double n1 : numbers) {
            dest_.writeDouble(n1);
        }
        dest_.writeInt(mapInfoG.size());
        for (Map.Entry<Info,Gender> mapInfoGIter : mapInfoG.entrySet()) {
            Info k1 = mapInfoGIter.getKey();
            k1.write(dest_);
            Gender v1 = mapInfoGIter.getValue();
            dest_.writeInt(v1.value());
        }
        dest_.writeInt(mapGenderInfo.size());
        for (Map.Entry<Gender,Info> mapGenderInfoIter : mapGenderInfo.entrySet()) {
            Gender k1 = mapGenderInfoIter.getKey();
            dest_.writeInt(k1.value());
            Info v1 = mapGenderInfoIter.getValue();
            v1.write(dest_);
        }
        dest_.writeInt(mapDouble.size());
        for (Map.Entry<Integer,java.lang.Double> mapDoubleIter : mapDouble.entrySet()) {
            Integer k1 = mapDoubleIter.getKey();
            dest_.writeInt(k1);
            java.lang.Double v1 = mapDoubleIter.getValue();
            dest_.writeDouble(v1);
        }
        if (hotfix != null) {
            dest_.writeByte((byte)0x01);
            dest_.writeInt(hotfix.size());
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                dest_.writeUTF(k1);
                java.lang.String v1 = hotfixIter.getValue();
                dest_.writeUTF(v1);
            }
        } else {
            dest_.writeByte((byte)0x00);
        }
    }

    public String toString()
    {
        StringBuilder s = new StringBuilder();
        s.append('{');
        s.append(getClass().getName());
        s.append(',').append("key").append(':');
        s.append(key.toString());
        s.append(',').append("number01").append(':');
        s.append(number01.toString());
        s.append(',').append("number02").append(':');
        s.append(number02.toString());
        s.append(',').append("number03").append(':');
        s.append(number03.toString());
        s.append(',').append("number04").append(':');
        s.append(number04.toString());
        s.append(',').append("number05").append(':');
        s.append(number05.toString());
        s.append(',').append("number06").append(':');
        s.append(number06.toString());
        s.append(',').append("number07").append(':');
        s.append(number07.toString());
        s.append(',').append("number08").append(':');
        s.append(number08.toString());
        s.append(',').append("number09").append(':');
        s.append(number09.toString());
        s.append(',').append("number10").append(':');
        s.append(number10.toString());
        s.append(',').append("isReal").append(':');
        s.append(isReal.toString());
        s.append(',').append("s").append(':');
        s.append('"').append(s).append('"');
        s.append(',').append("world").append(':');
        s.append('(').append(world.size()).append(')');
        s.append(',').append("gender").append(':');
        s.append(gender.toString());
        s.append(", next:");
        if (next != null) {
            s.append('<').append("Info").append('>');
        } else {
            s.append("null");
        }
        s.append(',').append("conflict").append(':');
        s.append('<').append("test.abc.Conflict").append('>');
        s.append(',').append("conflicts").append(':');
        s.append('(').append(conflicts.size()).append(')');
        s.append(',').append("numbers").append(':');
        s.append('(').append(numbers.size()).append(')');
        s.append(',').append("mapInfoG").append(':');
        s.append('[').append(mapInfoG.size()).append(']');
        s.append(',').append("mapGenderInfo").append(':');
        s.append('[').append(mapGenderInfo.size()).append(']');
        s.append(',').append("mapDouble").append(':');
        s.append('[').append(mapDouble.size()).append(']');
        s.append(", hotfix:");
        if (hotfix != null) {
            s.append('[').append(hotfix.size()).append(']');
        } else {
            s.append("null");
        }
        s.append('}');
        return s.toString();
    } //Info::toString ()

    public String toStringJSON()
    {
        StringBuilder code = new StringBuilder();
        this.writeJSON(code);
        return code.toString();
    }

    public void writeJSON(StringBuilder s_)
    {
        s_.append('{');
        char comma = '\0';
        s_.append('"').append("key").append('"').append(':');
        s_.append(key.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number01").append('"').append(':');
        s_.append(number01.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number02").append('"').append(':');
        s_.append(number02.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number03").append('"').append(':');
        s_.append(number03.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number04").append('"').append(':');
        s_.append(number04.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number05").append('"').append(':');
        s_.append(number05.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number06").append('"').append(':');
        s_.append(number06.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number07").append('"').append(':');
        s_.append(number07.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number08").append('"').append(':');
        s_.append(number08.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number09").append('"').append(':');
        s_.append(number09.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("number10").append('"').append(':');
        s_.append(number10.toString()); comma = ',';
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("isReal").append('"').append(':');
        s_.append(isReal.toString().toLowerCase()); comma = ',';
        boolean sExists = s != null && s.length() > 0;
        if ('\0' != comma && sExists) { s_.append(comma); comma = '\0'; }
        if (sExists) {
            s_.append('"').append("s").append('"').append(':'); comma = ','; s_.append('"').append(s.toString()).append('"');
        }
        boolean worldExists = (null != world);
        if ('\0' != comma && worldExists) { s_.append(comma); comma = '\0'; }
        if (worldExists) { s_.append('"').append("world").append('"').append(':'); comma = ','; }
        if (null != world) {
            s_.append('[');
            int worldSize = world.size();
            int worldIdx = 0;
            for (java.lang.String n1 : world) { /* vec.for: world */
                ++worldIdx;
                s_.append('"').append(n1.toString()).append('"');
                if (worldIdx != worldSize) { s_.append(','); }
            }
            s_.append(']');
        }
        if ('\0' != comma) { s_.append(comma); comma = '\0'; }
        s_.append('"').append("gender").append('"').append(':');
        s_.append(gender.value()); comma = ',';
        boolean nextExists = (null != next);
        if ('\0' != comma && nextExists) { s_.append(comma); comma = '\0'; }
        if (nextExists) {
            s_.append('"').append("next").append('"').append(':'); comma = ','; next.writeJSON(s_);
        }
        boolean conflictExists = (null != conflict);
        if ('\0' != comma && conflictExists) { s_.append(comma); comma = '\0'; }
        if (conflictExists) {
            s_.append('"').append("conflict").append('"').append(':'); comma = ','; conflict.writeJSON(s_);
        }
        boolean conflictsExists = (null != conflicts);
        if ('\0' != comma && conflictsExists) { s_.append(comma); comma = '\0'; }
        if (conflictsExists) { s_.append('"').append("conflicts").append('"').append(':'); comma = ','; }
        if (null != conflicts) {
            s_.append('[');
            int conflictsSize = conflicts.size();
            int conflictsIdx = 0;
            for (test.xyz.Conflict n1 : conflicts) { /* vec.for: conflicts */
                ++conflictsIdx;
                n1.writeJSON(s_);
                if (conflictsIdx != conflictsSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean numbersExists = (null != numbers);
        if ('\0' != comma && numbersExists) { s_.append(comma); comma = '\0'; }
        if (numbersExists) { s_.append('"').append("numbers").append('"').append(':'); comma = ','; }
        if (null != numbers) {
            s_.append('[');
            int numbersSize = numbers.size();
            int numbersIdx = 0;
            for (java.lang.Double n1 : numbers) { /* vec.for: numbers */
                ++numbersIdx;
                s_.append(n1.toString());
                if (numbersIdx != numbersSize) { s_.append(','); }
            }
            s_.append(']');
        }
        boolean mapInfoGExists = (null != mapInfoG);
        if ('\0' != comma && mapInfoGExists) { s_.append(comma); comma = '\0'; }
        if (mapInfoGExists) { s_.append('"').append("mapInfoG").append('"').append(':'); comma = ','; }
        if (null != mapInfoG) {
            s_.append('{');
            int mapInfoGSize = mapInfoG.size();
            int mapInfoGIdx = 0;
            for (Map.Entry<Info,Gender> mapInfoGIter : mapInfoG.entrySet()) { /* map.for: mapInfoG */
                ++mapInfoGIdx;
                Info k1 = mapInfoGIter.getKey(); /* nest.k */
                s_.append('"'); k1.writeJSON(s_); s_.append('"').append(':');
                Gender v1 = mapInfoGIter.getValue(); /* nest.v */
                s_.append(v1.value());
                if (mapInfoGIdx != mapInfoGSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean mapGenderInfoExists = (null != mapGenderInfo);
        if ('\0' != comma && mapGenderInfoExists) { s_.append(comma); comma = '\0'; }
        if (mapGenderInfoExists) { s_.append('"').append("mapGenderInfo").append('"').append(':'); comma = ','; }
        if (null != mapGenderInfo) {
            s_.append('{');
            int mapGenderInfoSize = mapGenderInfo.size();
            int mapGenderInfoIdx = 0;
            for (Map.Entry<Gender,Info> mapGenderInfoIter : mapGenderInfo.entrySet()) { /* map.for: mapGenderInfo */
                ++mapGenderInfoIdx;
                Gender k1 = mapGenderInfoIter.getKey(); /* nest.k */
                s_.append('"'); s_.append(k1.value()); s_.append('"').append(':');
                Info v1 = mapGenderInfoIter.getValue(); /* nest.v */
                v1.writeJSON(s_);
                if (mapGenderInfoIdx != mapGenderInfoSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean mapDoubleExists = (null != mapDouble);
        if ('\0' != comma && mapDoubleExists) { s_.append(comma); comma = '\0'; }
        if (mapDoubleExists) { s_.append('"').append("mapDouble").append('"').append(':'); comma = ','; }
        if (null != mapDouble) {
            s_.append('{');
            int mapDoubleSize = mapDouble.size();
            int mapDoubleIdx = 0;
            for (Map.Entry<Integer,java.lang.Double> mapDoubleIter : mapDouble.entrySet()) { /* map.for: mapDouble */
                ++mapDoubleIdx;
                Integer k1 = mapDoubleIter.getKey(); /* nest.k */
                s_.append('"'); s_.append(k1.toString()); s_.append('"').append(':');
                java.lang.Double v1 = mapDoubleIter.getValue(); /* nest.v */
                s_.append(v1.toString());
                if (mapDoubleIdx != mapDoubleSize) { s_.append(','); }
            }
            s_.append('}');
        }
        boolean hotfixExists = (null != hotfix);
        if ('\0' != comma && hotfixExists) { s_.append(comma); comma = '\0'; }
        if (hotfixExists) {
            s_.append('"').append("hotfix").append('"').append(':'); comma = ',';
            if (null != hotfix) {
                s_.append('{');
                int hotfixSize = hotfix.size();
                int hotfixIdx = 0;
                for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) { /* map.for: hotfix */
                    ++hotfixIdx;
                    java.lang.String k1 = hotfixIter.getKey(); /* nest.k */
                    s_.append('"').append(k1.toString()).append('"'); s_.append(':');
                    java.lang.String v1 = hotfixIter.getValue(); /* nest.v */
                    s_.append('"').append(v1.toString()).append('"');
                    if (hotfixIdx != hotfixSize) { s_.append(','); }
                }
                s_.append('}');
            }
        }
        s_.append('}');
    } /* Info::writeJSON(...) */

    public String toStringXML()
    {
        StringBuilder code = new StringBuilder();
        this.writeXML(code, "Info");
        return code.toString();
    }

    public void writeXML(StringBuilder result_, String name_)
    {
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes = new StringBuilder();
        attrs.append(' ').append("key").append('=').append('"');
        attrs.append(key.toString()).append('"');
        attrs.append(' ').append("number01").append('=').append('"');
        attrs.append(number01.toString()).append('"');
        attrs.append(' ').append("number02").append('=').append('"');
        attrs.append(number02.toString()).append('"');
        attrs.append(' ').append("number03").append('=').append('"');
        attrs.append(number03.toString()).append('"');
        attrs.append(' ').append("number04").append('=').append('"');
        attrs.append(number04.toString()).append('"');
        attrs.append(' ').append("number05").append('=').append('"');
        attrs.append(number05.toString()).append('"');
        attrs.append(' ').append("number06").append('=').append('"');
        attrs.append(number06.toString()).append('"');
        attrs.append(' ').append("number07").append('=').append('"');
        attrs.append(number07.toString()).append('"');
        attrs.append(' ').append("number08").append('=').append('"');
        attrs.append(number08.toString()).append('"');
        attrs.append(' ').append("number09").append('=').append('"');
        attrs.append(number09.toString()).append('"');
        attrs.append(' ').append("number10").append('=').append('"');
        attrs.append(number10.toString()).append('"');
        attrs.append(' ').append("isReal").append('=').append('"');
        attrs.append(isReal.toString()).append('"');
        attrs.append(' ').append("s").append('=').append('"');
        attrs.append(s).append('"');
        if (world.size() > 0) {
            nodes.append('<').append("world").append('>');
            for (java.lang.String n1 : world) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("world").append('>');
        }
        attrs.append(' ').append("gender").append('=').append('"');
        attrs.append(gender.value()).append('"');
        if (next != null) {
            next.writeXML(nodes, "next");
        }
        conflict.writeXML(nodes, "conflict");
        if (conflicts.size() > 0) {
            nodes.append('<').append("conflicts").append('>');
            for (test.xyz.Conflict n1 : conflicts) {
                n1.writeXML(nodes, "n1");
            }
            nodes.append('<').append('/').append("conflicts").append('>');
        }
        if (numbers.size() > 0) {
            nodes.append('<').append("numbers").append('>');
            for (java.lang.Double n1 : numbers) {
                nodes.append('<').append("n1").append(' ').append("value").append('=').append('"');
                nodes.append(n1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("numbers").append('>');
        }
        if (mapInfoG.size() > 0) {
            nodes.append('<').append("mapInfoG").append('>');
            for (Map.Entry<Info,Gender> mapInfoGIter : mapInfoG.entrySet()) {
                Info k1 = mapInfoGIter.getKey();
                k1.writeXML(nodes, "k1");
                Gender v1 = mapInfoGIter.getValue();
                nodes.append('<').append("v1").append(' ').append("value").append('=').append('"');
                nodes.append(v1.value()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("mapInfoG").append('>');
        }
        if (mapGenderInfo.size() > 0) {
            nodes.append('<').append("mapGenderInfo").append('>');
            for (Map.Entry<Gender,Info> mapGenderInfoIter : mapGenderInfo.entrySet()) {
                Gender k1 = mapGenderInfoIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1.value()).append('"').append('/').append('>');
                Info v1 = mapGenderInfoIter.getValue();
                v1.writeXML(nodes, "v1");
            }
            nodes.append('<').append('/').append("mapGenderInfo").append('>');
        }
        if (mapDouble.size() > 0) {
            nodes.append('<').append("mapDouble").append('>');
            for (Map.Entry<Integer,java.lang.Double> mapDoubleIter : mapDouble.entrySet()) {
                Integer k1 = mapDoubleIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1.toString()).append('"').append('/').append('>');
                java.lang.Double v1 = mapDoubleIter.getValue();
                nodes.append('<').append("v1").append(' ').append("value").append('=').append('"');
                nodes.append(v1.toString()).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("mapDouble").append('>');
        }
        if (hotfix != null && hotfix.size() > 0) {
            nodes.append('<').append("hotfix").append('>');
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                nodes.append('<').append("k1").append(' ').append("value").append('=').append('"');
                nodes.append(k1).append('"').append('/').append('>');
                java.lang.String v1 = hotfixIter.getValue();
                nodes.append('<').append("v1").append(' ').append("value").append('=').append('"');
                nodes.append(v1).append('"').append('/').append('>');
            }
            nodes.append('<').append('/').append("hotfix").append('>');
        }
        result_.append('<').append(name_).append(attrs);
        if (nodes.length() == 0) {
            result_.append('/').append('>');
        } else {
            result_.append('>').append(nodes);
            result_.append('<').append('/').append(name_).append('>');
        }
    } /* Info::writeXML(...) */

}

