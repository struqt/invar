/*===----------------------------*  Java  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.xyz;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import test.abc.Gender;
import test.abc.Info;

/** Complex data structure */
public final class InfoX
{
    static public final long CRC32 = 0xF55867E1;

    private LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> infos     ;
    private test.xyz.Conflict                                                conflict_x;/* Two types with the same name. */
    private test.abc.Conflict                                                conflict_a;/* Two types with the same name. */
    private LinkedHashMap<Integer,test.abc.Conflict>                         mConflict ;
    private LinkedList<LinkedList<Info>>                                     info2d    ;/* 2 dimension list */
    private LinkedList<LinkedList<LinkedList<Info>>>                         info3d    ;/* 3 dimension list */
    private LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> info5d    ;
    private LinkedList<LinkedHashMap<Short,Info>>                            infovm    ;
    private LinkedHashMap<LinkedList<Gender>,Info>                           mvei      ;
    private LinkedHashMap<Info,LinkedList<Gender>>                           mive      ;
    private LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>               mvive     ;
    private LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>>   vmvive    ;
    private LinkedHashMap<String,String>                                     hotfix    ;/* [AutoAdd] Hotfix */

    public InfoX()
    {
        infos      = new LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>>();
        conflict_x = new test.xyz.Conflict();
        conflict_a = new test.abc.Conflict();
        mConflict  = new LinkedHashMap<Integer,test.abc.Conflict>();
        info2d     = new LinkedList<LinkedList<Info>>();
        info3d     = new LinkedList<LinkedList<LinkedList<Info>>>();
        info5d     = new LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>>();
        infovm     = new LinkedList<LinkedHashMap<Short,Info>>();
        mvei       = new LinkedHashMap<LinkedList<Gender>,Info>();
        mive       = new LinkedHashMap<Info,LinkedList<Gender>>();
        mvive      = new LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>();
        vmvive     = new LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>>();
        hotfix     = null;
    }

    public InfoX reuse()
    {
        infos.clear();
        conflict_x.reuse();
        conflict_a.reuse();
        mConflict.clear();
        info2d.clear();
        info3d.clear();
        info5d.clear();
        infovm.clear();
        mvei.clear();
        mive.clear();
        mvive.clear();
        vmvive.clear();
        if (hotfix != null) {
            hotfix.clear();
        }
        return this;
    }

    /**  */
    @invar.InvarRule(T="vec<vec<vec<vec<vec<test.abc.Info>>>>>", S="f0")
    public LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> getInfos() { return infos; }

    /** Two types with the same name. */
    @invar.InvarRule(T="test.xyz.Conflict", S="f1")
    public test.xyz.Conflict getConflict_x() { return conflict_x; }

    /** Two types with the same name. */
    @invar.InvarRule(T="test.abc.Conflict", S="f2")
    public test.abc.Conflict getConflict_a() { return conflict_a; }

    /**  */
    @invar.InvarRule(T="map<int32,test.abc.Conflict>", S="f3")
    public LinkedHashMap<Integer,test.abc.Conflict> getMConflict() { return mConflict; }

    /** 2 dimension list */
    @invar.InvarRule(T="vec<vec<test.abc.Info>>", S="f4")
    public LinkedList<LinkedList<Info>> getInfo2d() { return info2d; }

    /** 3 dimension list */
    @invar.InvarRule(T="vec<vec<vec<test.abc.Info>>>", S="f5")
    public LinkedList<LinkedList<LinkedList<Info>>> getInfo3d() { return info3d; }

    /**  */
    @invar.InvarRule(T="vec<vec<vec<vec<vec<test.abc.Info>>>>>", S="f6")
    public LinkedList<LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>> getInfo5d() { return info5d; }

    /**  */
    @invar.InvarRule(T="vec<map<int16,test.abc.Info>>", S="f7")
    public LinkedList<LinkedHashMap<Short,Info>> getInfovm() { return infovm; }

    /**  */
    @invar.InvarRule(T="map<vec<test.abc.Gender>,test.abc.Info>", S="f8")
    public LinkedHashMap<LinkedList<Gender>,Info> getMvei() { return mvei; }

    /**  */
    @invar.InvarRule(T="map<test.abc.Info,vec<test.abc.Gender>>", S="f9")
    public LinkedHashMap<Info,LinkedList<Gender>> getMive() { return mive; }

    /**  */
    @invar.InvarRule(T="map<vec<test.abc.Info>,vec<test.abc.Gender>>", S="f10")
    public LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> getMvive() { return mvive; }

    /**  */
    @invar.InvarRule(T="vec<map<vec<test.abc.Info>,vec<test.abc.Gender>>>", S="f11")
    public LinkedList<LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>> getVmvive() { return vmvive; }

    /** [AutoAdd] Hotfix */
    @invar.InvarRule(T="map<string,string>", S="f12")
    public LinkedHashMap<String,String> getHotfix() { return hotfix; }

    /** Two types with the same name. */
    @invar.InvarRule(T="test.xyz.Conflict", S="f1")
    public InfoX setConflict_x(test.xyz.Conflict value) { this.conflict_x = value; return this; }

    /** Two types with the same name. */
    @invar.InvarRule(T="test.abc.Conflict", S="f2")
    public InfoX setConflict_a(test.abc.Conflict value) { this.conflict_a = value; return this; }

    /** [AutoAdd] Hotfix */
    @invar.InvarRule(T="map<string,string>", S="f12")
    public InfoX setHotfix(LinkedHashMap<String,String> value) { this.hotfix = value; return this; }

    public InfoX copy (InfoX from)
    {
        if (this == from || from == null) {
            return this;
        }
        infos.clear();
        infos.addAll(from.infos);
        conflict_x = from.conflict_x;
        conflict_a = from.conflict_a;
        mConflict.clear();
        mConflict.putAll(from.mConflict);
        info2d.clear();
        info2d.addAll(from.info2d);
        info3d.clear();
        info3d.addAll(from.info3d);
        info5d.clear();
        info5d.addAll(from.info5d);
        infovm.clear();
        infovm.addAll(from.infovm);
        mvei.clear();
        mvei.putAll(from.mvei);
        mive.clear();
        mive.putAll(from.mive);
        mvive.clear();
        mvive.putAll(from.mvive);
        vmvive.clear();
        vmvive.addAll(from.vmvive);
        if (from.hotfix != null) {
            hotfix.clear();
            hotfix.putAll(from.hotfix);
        } else {
            hotfix = null;
        }
        return this;
    } //copyFrom(...)

    public InfoX read(InputStream from) throws IOException
    {
        return this.read((DataInput)new DataInputStream(from));
    }

    public InfoX read(DataInput from) throws IOException
    {
        infos.clear();
        Long lenInfos = from.readInt() & 0xFFFFFFFFL;
        for (Long iInfos = 0L; iInfos < lenInfos; ++iInfos) {
            LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 = new LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<LinkedList<LinkedList<Info>>> n2 = new LinkedList<LinkedList<LinkedList<Info>>>(); //read.vec.head
                Long lenN2 = from.readInt() & 0xFFFFFFFFL;
                for (Long iN2 = 0L; iN2 < lenN2; ++iN2) {
                    LinkedList<LinkedList<Info>> n3 = new LinkedList<LinkedList<Info>>(); //read.vec.head
                    Long lenN3 = from.readInt() & 0xFFFFFFFFL;
                    for (Long iN3 = 0L; iN3 < lenN3; ++iN3) {
                        LinkedList<Info> n4 = new LinkedList<Info>(); //read.vec.head
                        Long lenN4 = from.readInt() & 0xFFFFFFFFL;
                        for (Long iN4 = 0L; iN4 < lenN4; ++iN4) {
                            Info n5 = new Info();
                            n5.read(from);
                            n4.add(n5);
                        }
                        n3.add(n4);
                    }
                    n2.add(n3);
                }
                n1.add(n2);
            }
            infos.add(n1);
        }
        conflict_x.read(from);
        conflict_a.read(from);
        mConflict.clear();
        Long lenMConflict = from.readInt() & 0xFFFFFFFFL;
        for (Long iMConflict = 0L; iMConflict < lenMConflict; ++iMConflict) {
            Integer k1 = from.readUnsignedShort();
            test.abc.Conflict v1 = new test.abc.Conflict();
            v1.read(from);
            mConflict.put(k1,v1);
        }
        info2d.clear();
        Long lenInfo2d = from.readInt() & 0xFFFFFFFFL;
        for (Long iInfo2d = 0L; iInfo2d < lenInfo2d; ++iInfo2d) {
            LinkedList<Info> n1 = new LinkedList<Info>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                Info n2 = new Info();
                n2.read(from);
                n1.add(n2);
            }
            info2d.add(n1);
        }
        info3d.clear();
        Long lenInfo3d = from.readInt() & 0xFFFFFFFFL;
        for (Long iInfo3d = 0L; iInfo3d < lenInfo3d; ++iInfo3d) {
            LinkedList<LinkedList<Info>> n1 = new LinkedList<LinkedList<Info>>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<Info> n2 = new LinkedList<Info>(); //read.vec.head
                Long lenN2 = from.readInt() & 0xFFFFFFFFL;
                for (Long iN2 = 0L; iN2 < lenN2; ++iN2) {
                    Info n3 = new Info();
                    n3.read(from);
                    n2.add(n3);
                }
                n1.add(n2);
            }
            info3d.add(n1);
        }
        info5d.clear();
        Long lenInfo5d = from.readInt() & 0xFFFFFFFFL;
        for (Long iInfo5d = 0L; iInfo5d < lenInfo5d; ++iInfo5d) {
            LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 = new LinkedList<LinkedList<LinkedList<LinkedList<Info>>>>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<LinkedList<LinkedList<Info>>> n2 = new LinkedList<LinkedList<LinkedList<Info>>>(); //read.vec.head
                Long lenN2 = from.readInt() & 0xFFFFFFFFL;
                for (Long iN2 = 0L; iN2 < lenN2; ++iN2) {
                    LinkedList<LinkedList<Info>> n3 = new LinkedList<LinkedList<Info>>(); //read.vec.head
                    Long lenN3 = from.readInt() & 0xFFFFFFFFL;
                    for (Long iN3 = 0L; iN3 < lenN3; ++iN3) {
                        LinkedList<Info> n4 = new LinkedList<Info>(); //read.vec.head
                        Long lenN4 = from.readInt() & 0xFFFFFFFFL;
                        for (Long iN4 = 0L; iN4 < lenN4; ++iN4) {
                            Info n5 = new Info();
                            n5.read(from);
                            n4.add(n5);
                        }
                        n3.add(n4);
                    }
                    n2.add(n3);
                }
                n1.add(n2);
            }
            info5d.add(n1);
        }
        infovm.clear();
        Long lenInfovm = from.readInt() & 0xFFFFFFFFL;
        for (Long iInfovm = 0L; iInfovm < lenInfovm; ++iInfovm) {
            LinkedHashMap<Short,Info> n1 = new LinkedHashMap<Short,Info>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                Short k2 = from.readShort();
                Info v2 = new Info();
                v2.read(from);
                n1.put(k2,v2);
            }
            infovm.add(n1);
        }
        mvei.clear();
        Long lenMvei = from.readInt() & 0xFFFFFFFFL;
        for (Long iMvei = 0L; iMvei < lenMvei; ++iMvei) {
            LinkedList<Gender> k1 = new LinkedList<Gender>(); //read.map.head
            Long lenK1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iK1 = 0L; iK1 < lenK1; ++iK1) {
                Gender n2 = Gender.valueOf(from.readInt());
                k1.add(n2);
            }
            Info v1 = new Info();
            v1.read(from);
            mvei.put(k1,v1);
        }
        mive.clear();
        Long lenMive = from.readInt() & 0xFFFFFFFFL;
        for (Long iMive = 0L; iMive < lenMive; ++iMive) {
            Info k1 = new Info();
            k1.read(from);
            LinkedList<Gender> v1 = new LinkedList<Gender>(); //read.map.head
            Long lenV1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iV1 = 0L; iV1 < lenV1; ++iV1) {
                Gender n2 = Gender.valueOf(from.readInt());
                v1.add(n2);
            }
            mive.put(k1,v1);
        }
        mvive.clear();
        Long lenMvive = from.readInt() & 0xFFFFFFFFL;
        for (Long iMvive = 0L; iMvive < lenMvive; ++iMvive) {
            LinkedList<Info> k1 = new LinkedList<Info>(); //read.map.head
            Long lenK1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iK1 = 0L; iK1 < lenK1; ++iK1) {
                Info n2 = new Info();
                n2.read(from);
                k1.add(n2);
            }
            LinkedList<Gender> v1 = new LinkedList<Gender>(); //read.map.head
            Long lenV1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iV1 = 0L; iV1 < lenV1; ++iV1) {
                Gender n2 = Gender.valueOf(from.readInt());
                v1.add(n2);
            }
            mvive.put(k1,v1);
        }
        vmvive.clear();
        Long lenVmvive = from.readInt() & 0xFFFFFFFFL;
        for (Long iVmvive = 0L; iVmvive < lenVmvive; ++iVmvive) {
            LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 = new LinkedHashMap<LinkedList<Info>,LinkedList<Gender>>(); //read.vec.head
            Long lenN1 = from.readInt() & 0xFFFFFFFFL;
            for (Long iN1 = 0L; iN1 < lenN1; ++iN1) {
                LinkedList<Info> k2 = new LinkedList<Info>(); //read.map.head
                Long lenK2 = from.readInt() & 0xFFFFFFFFL;
                for (Long iK2 = 0L; iK2 < lenK2; ++iK2) {
                    Info n3 = new Info();
                    n3.read(from);
                    k2.add(n3);
                }
                LinkedList<Gender> v2 = new LinkedList<Gender>(); //read.map.head
                Long lenV2 = from.readInt() & 0xFFFFFFFFL;
                for (Long iV2 = 0L; iV2 < lenV2; ++iV2) {
                    Gender n3 = Gender.valueOf(from.readInt());
                    v2.add(n3);
                }
                n1.put(k2,v2);
            }
            vmvive.add(n1);
        }
        hotfix.clear();
        if (from.readByte() == (byte)0x01) {
            Long lenHotfix = from.readInt() & 0xFFFFFFFFL;
            for (Long iHotfix = 0L; iHotfix < lenHotfix; ++iHotfix) {
                java.lang.String k1 = from.readUTF();
                java.lang.String v1 = from.readUTF();
                hotfix.put(k1,v1);
            }
        }
        return this;
    }

    public InfoX writeStream(OutputStream from) throws IOException
    {
        return this.write((DataOutput)new DataOutputStream(from));
    }

    public InfoX write(DataOutput dest) throws IOException
    {
        dest.writeInt(infos.size());
        for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : infos) {
            dest.writeInt(n1.size());
            for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                dest.writeInt(n2.size());
                for (LinkedList<LinkedList<Info>> n3 : n2) {
                    dest.writeInt(n3.size());
                    for (LinkedList<Info> n4 : n3) {
                        dest.writeInt(n4.size());
                        for (Info n5 : n4) {
                            n5.write(dest);
                        }
                    }
                }
            }
        }
        conflict_x.write(dest);
        conflict_a.write(dest);
        dest.writeInt(mConflict.size());
        for (Map.Entry<Integer,test.abc.Conflict> mConflictIter : mConflict.entrySet()) {
            Integer k1 = mConflictIter.getKey();
            dest.writeShort(k1);
            test.abc.Conflict v1 = mConflictIter.getValue();
            v1.write(dest);
        }
        dest.writeInt(info2d.size());
        for (LinkedList<Info> n1 : info2d) {
            dest.writeInt(n1.size());
            for (Info n2 : n1) {
                n2.write(dest);
            }
        }
        dest.writeInt(info3d.size());
        for (LinkedList<LinkedList<Info>> n1 : info3d) {
            dest.writeInt(n1.size());
            for (LinkedList<Info> n2 : n1) {
                dest.writeInt(n2.size());
                for (Info n3 : n2) {
                    n3.write(dest);
                }
            }
        }
        dest.writeInt(info5d.size());
        for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : info5d) {
            dest.writeInt(n1.size());
            for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                dest.writeInt(n2.size());
                for (LinkedList<LinkedList<Info>> n3 : n2) {
                    dest.writeInt(n3.size());
                    for (LinkedList<Info> n4 : n3) {
                        dest.writeInt(n4.size());
                        for (Info n5 : n4) {
                            n5.write(dest);
                        }
                    }
                }
            }
        }
        dest.writeInt(infovm.size());
        for (LinkedHashMap<Short,Info> n1 : infovm) {
            dest.writeInt(n1.size());
            for (Map.Entry<Short,Info> n1Iter : n1.entrySet()) {
                Short k2 = n1Iter.getKey();
                dest.writeShort(k2);
                Info v2 = n1Iter.getValue();
                v2.write(dest);
            }
        }
        dest.writeInt(mvei.size());
        for (Map.Entry<LinkedList<Gender>,Info> mveiIter : mvei.entrySet()) {
            LinkedList<Gender> k1 = mveiIter.getKey();
            dest.writeInt(k1.size());
            for (Gender n2 : k1) {
                dest.writeInt(n2.getValue());
            }
            Info v1 = mveiIter.getValue();
            v1.write(dest);
        }
        dest.writeInt(mive.size());
        for (Map.Entry<Info,LinkedList<Gender>> miveIter : mive.entrySet()) {
            Info k1 = miveIter.getKey();
            k1.write(dest);
            LinkedList<Gender> v1 = miveIter.getValue();
            dest.writeInt(v1.size());
            for (Gender n2 : v1) {
                dest.writeInt(n2.getValue());
            }
        }
        dest.writeInt(mvive.size());
        for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> mviveIter : mvive.entrySet()) {
            LinkedList<Info> k1 = mviveIter.getKey();
            dest.writeInt(k1.size());
            for (Info n2 : k1) {
                n2.write(dest);
            }
            LinkedList<Gender> v1 = mviveIter.getValue();
            dest.writeInt(v1.size());
            for (Gender n2 : v1) {
                dest.writeInt(n2.getValue());
            }
        }
        dest.writeInt(vmvive.size());
        for (LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 : vmvive) {
            dest.writeInt(n1.size());
            for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> n1Iter : n1.entrySet()) {
                LinkedList<Info> k2 = n1Iter.getKey();
                dest.writeInt(k2.size());
                for (Info n3 : k2) {
                    n3.write(dest);
                }
                LinkedList<Gender> v2 = n1Iter.getValue();
                dest.writeInt(v2.size());
                for (Gender n3 : v2) {
                    dest.writeInt(n3.getValue());
                }
            }
        }
        if (hotfix != null) {
            dest.writeByte((byte)0x01);
            dest.writeInt(hotfix.size());
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                dest.writeUTF(k1);
                java.lang.String v1 = hotfixIter.getValue();
                dest.writeUTF(v1);
            }
        } else {
            dest.writeByte((byte)0x00);
        }
        return this;
    }

    public String toStringXml (String name)
    {
        StringBuilder result = new StringBuilder();
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes  = new StringBuilder();
        if (infos.size() > 0) {
            nodes.append("<infos>");
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : infos) {
                nodes.append("<n1>");
                for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                    nodes.append("<n2>");
                    for (LinkedList<LinkedList<Info>> n3 : n2) {
                        nodes.append("<n3>");
                        for (LinkedList<Info> n4 : n3) {
                            nodes.append("<n4>");
                            for (Info n5 : n4) {
                                nodes.append(n5.toStringXml("n5"));
                            }
                            nodes.append("</n4>");
                        }
                        nodes.append("</n3>");
                    }
                    nodes.append("</n2>");
                }
                nodes.append("</n1>");
            }
            nodes.append("</infos>");
        }
        nodes.append(conflict_x.toStringXml("conflict_x"));
        nodes.append(conflict_a.toStringXml("conflict_a"));
        if (mConflict.size() > 0) {
            nodes.append("<mConflict>");
            for (Map.Entry<Integer,test.abc.Conflict> mConflictIter : mConflict.entrySet()) {
                Integer k1 = mConflictIter.getKey();
                nodes.append("<k1 value=\"");
                nodes.append(k1.toString());
                nodes.append("\">");
                test.abc.Conflict v1 = mConflictIter.getValue();
                nodes.append(v1.toStringXml("v1"));
            }
            nodes.append("</mConflict>");
        }
        if (info2d.size() > 0) {
            nodes.append("<info2d>");
            for (LinkedList<Info> n1 : info2d) {
                nodes.append("<n1>");
                for (Info n2 : n1) {
                    nodes.append(n2.toStringXml("n2"));
                }
                nodes.append("</n1>");
            }
            nodes.append("</info2d>");
        }
        if (info3d.size() > 0) {
            nodes.append("<info3d>");
            for (LinkedList<LinkedList<Info>> n1 : info3d) {
                nodes.append("<n1>");
                for (LinkedList<Info> n2 : n1) {
                    nodes.append("<n2>");
                    for (Info n3 : n2) {
                        nodes.append(n3.toStringXml("n3"));
                    }
                    nodes.append("</n2>");
                }
                nodes.append("</n1>");
            }
            nodes.append("</info3d>");
        }
        if (info5d.size() > 0) {
            nodes.append("<info5d>");
            for (LinkedList<LinkedList<LinkedList<LinkedList<Info>>>> n1 : info5d) {
                nodes.append("<n1>");
                for (LinkedList<LinkedList<LinkedList<Info>>> n2 : n1) {
                    nodes.append("<n2>");
                    for (LinkedList<LinkedList<Info>> n3 : n2) {
                        nodes.append("<n3>");
                        for (LinkedList<Info> n4 : n3) {
                            nodes.append("<n4>");
                            for (Info n5 : n4) {
                                nodes.append(n5.toStringXml("n5"));
                            }
                            nodes.append("</n4>");
                        }
                        nodes.append("</n3>");
                    }
                    nodes.append("</n2>");
                }
                nodes.append("</n1>");
            }
            nodes.append("</info5d>");
        }
        if (infovm.size() > 0) {
            nodes.append("<infovm>");
            for (LinkedHashMap<Short,Info> n1 : infovm) {
                nodes.append("<n1>");
                for (Map.Entry<Short,Info> n1Iter : n1.entrySet()) {
                    Short k2 = n1Iter.getKey();
                    nodes.append("<k2 value=\"");
                    nodes.append(k2.toString());
                    nodes.append("\">");
                    Info v2 = n1Iter.getValue();
                    nodes.append(v2.toStringXml("v2"));
                }
                nodes.append("</n1>");
            }
            nodes.append("</infovm>");
        }
        if (mvei.size() > 0) {
            nodes.append("<mvei>");
            for (Map.Entry<LinkedList<Gender>,Info> mveiIter : mvei.entrySet()) {
                LinkedList<Gender> k1 = mveiIter.getKey();
                nodes.append("<k1>");
                for (Gender n2 : k1) {
                    nodes.append("<n2 value=\"");
                    nodes.append(n2.toString());
                    nodes.append("\">");
                }
                nodes.append("</k1>");
                Info v1 = mveiIter.getValue();
                nodes.append(v1.toStringXml("v1"));
            }
            nodes.append("</mvei>");
        }
        if (mive.size() > 0) {
            nodes.append("<mive>");
            for (Map.Entry<Info,LinkedList<Gender>> miveIter : mive.entrySet()) {
                Info k1 = miveIter.getKey();
                nodes.append(k1.toStringXml("k1"));
                LinkedList<Gender> v1 = miveIter.getValue();
                nodes.append("<v1>");
                for (Gender n2 : v1) {
                    nodes.append("<n2 value=\"");
                    nodes.append(n2.toString());
                    nodes.append("\">");
                }
                nodes.append("</v1>");
            }
            nodes.append("</mive>");
        }
        if (mvive.size() > 0) {
            nodes.append("<mvive>");
            for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> mviveIter : mvive.entrySet()) {
                LinkedList<Info> k1 = mviveIter.getKey();
                nodes.append("<k1>");
                for (Info n2 : k1) {
                    nodes.append(n2.toStringXml("n2"));
                }
                nodes.append("</k1>");
                LinkedList<Gender> v1 = mviveIter.getValue();
                nodes.append("<v1>");
                for (Gender n2 : v1) {
                    nodes.append("<n2 value=\"");
                    nodes.append(n2.toString());
                    nodes.append("\">");
                }
                nodes.append("</v1>");
            }
            nodes.append("</mvive>");
        }
        if (vmvive.size() > 0) {
            nodes.append("<vmvive>");
            for (LinkedHashMap<LinkedList<Info>,LinkedList<Gender>> n1 : vmvive) {
                nodes.append("<n1>");
                for (Map.Entry<LinkedList<Info>,LinkedList<Gender>> n1Iter : n1.entrySet()) {
                    LinkedList<Info> k2 = n1Iter.getKey();
                    nodes.append("<k2>");
                    for (Info n3 : k2) {
                        nodes.append(n3.toStringXml("n3"));
                    }
                    nodes.append("</k2>");
                    LinkedList<Gender> v2 = n1Iter.getValue();
                    nodes.append("<v2>");
                    for (Gender n3 : v2) {
                        nodes.append("<n3 value=\"");
                        nodes.append(n3.toString());
                        nodes.append("\">");
                    }
                    nodes.append("</v2>");
                }
                nodes.append("</n1>");
            }
            nodes.append("</vmvive>");
        }
        if (hotfix != null && hotfix.size() > 0) {
            nodes.append("<hotfix>");
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                nodes.append("<k1 value=\"");
                nodes.append(k1);
                nodes.append("\">");
                java.lang.String v1 = hotfixIter.getValue();
                nodes.append("<v1 value=\"");
                nodes.append(v1);
                nodes.append("\">");
            }
            nodes.append("</hotfix>");
        }
        result.append("<"); result.append(name); result.append(attrs);
        if (nodes.length() == 0) {
            result.append("/>");
        } else {
            result.append(">");
            result.append(nodes);
            result.append("</"); result.append(name); result.append(">");
        }
        return result.toString();
    } //InfoX::toStringXml (String name)

    public String toString ()
    {
        StringBuilder result = new StringBuilder();
        result.append("{ ");
        result.append(getClass().getName());
        result.append(", infos:");
        result.append("(" + infos.size() + ")");
        result.append(", conflict_x:");
        result.append("<test.xyz.Conflict>");
        result.append(", conflict_a:");
        result.append("<test.abc.Conflict>");
        result.append(", mConflict:");
        result.append("[" + mConflict.size() + "]");
        result.append(", info2d:");
        result.append("(" + info2d.size() + ")");
        result.append(", info3d:");
        result.append("(" + info3d.size() + ")");
        result.append(", info5d:");
        result.append("(" + info5d.size() + ")");
        result.append(", infovm:");
        result.append("(" + infovm.size() + ")");
        result.append(", mvei:");
        result.append("[" + mvei.size() + "]");
        result.append(", mive:");
        result.append("[" + mive.size() + "]");
        result.append(", mvive:");
        result.append("[" + mvive.size() + "]");
        result.append(", vmvive:");
        result.append("(" + vmvive.size() + ")");
        result.append(", hotfix:");
        if (hotfix != null) {
            result.append("[" + hotfix.size() + "]");
        } else {
            result.append("null");
        }
        result.append(" }");
        return result.toString();
    } //InfoX::toString ()

}

