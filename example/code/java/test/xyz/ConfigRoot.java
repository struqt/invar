/*===----------------------------*  Java  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/
package test.xyz;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedHashMap;
import java.util.Map;
import test.abc.Info;

/**  */
public final class ConfigRoot
implements
invar.InvarCodec.BinaryDecode,
invar.InvarCodec.BinaryEncode,
invar.InvarCodec.XMLEncode
{
    static public ConfigRoot Create() { return new ConfigRoot(); }

    static public final long CRC32 = 0x6D03BB9B;

    private java.lang.String             revision;
    private TestList                     list    ;
    private TestDict                     dict    ;
    private TestNest                     nest    ;
    private Info                         info    ;
    private InfoX                        infox   ;
    private LinkedHashMap<String,String> hotfix  ;/* [AutoAdd] Hotfix */

    public ConfigRoot()
    {
        revision = "1.0.0";
        list     = new TestList();
        dict     = new TestDict();
        nest     = new TestNest();
        info     = new Info();
        infox    = new InfoX();
        hotfix   = null;
    }

    public ConfigRoot reuse()
    {
        revision = "1.0.0";
        list.reuse();
        dict.reuse();
        nest.reuse();
        info.reuse();
        infox.reuse();
        if (hotfix != null) {
            hotfix.clear();
        }
        return this;
    }

    /**  */
    @invar.InvarRule(T="string", S="f0")
    public java.lang.String getRevision() { return revision; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestList", S="f1")
    public TestList getList() { return list; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestDict", S="f2")
    public TestDict getDict() { return dict; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestNest", S="f3")
    public TestNest getNest() { return nest; }

    /**  */
    @invar.InvarRule(T="test.abc.Info", S="f4")
    public Info getInfo() { return info; }

    /**  */
    @invar.InvarRule(T="test.xyz.InfoX", S="f5")
    public InfoX getInfox() { return infox; }

    /** [AutoAdd] Hotfix */
    @invar.InvarRule(T="map<string,string>", S="f6")
    public LinkedHashMap<String,String> getHotfix() { return hotfix; }

    /**  */
    @invar.InvarRule(T="string", S="f0")
    public ConfigRoot setRevision(java.lang.String value) { this.revision = value; return this; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestList", S="f1")
    public ConfigRoot setList(TestList value) { this.list = value; return this; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestDict", S="f2")
    public ConfigRoot setDict(TestDict value) { this.dict = value; return this; }

    /**  */
    @invar.InvarRule(T="test.xyz.TestNest", S="f3")
    public ConfigRoot setNest(TestNest value) { this.nest = value; return this; }

    /**  */
    @invar.InvarRule(T="test.abc.Info", S="f4")
    public ConfigRoot setInfo(Info value) { this.info = value; return this; }

    /**  */
    @invar.InvarRule(T="test.xyz.InfoX", S="f5")
    public ConfigRoot setInfox(InfoX value) { this.infox = value; return this; }

    /** [AutoAdd] Hotfix */
    @invar.InvarRule(T="map<string,string>", S="f6")
    public ConfigRoot setHotfix(LinkedHashMap<String,String> value) { this.hotfix = value; return this; }

    public ConfigRoot copy (ConfigRoot from)
    {
        if (this == from || from == null) {
            return this;
        }
        revision = from.revision;
        list = from.list;
        dict = from.dict;
        nest = from.nest;
        info = from.info;
        infox = from.infox;
        if (from.hotfix != null) {
            hotfix.clear();
            hotfix.putAll(from.hotfix);
        } else {
            hotfix = null;
        }
        return this;
    } //copyFrom(...)

    public void read(InputStream from) throws IOException
    {
        this.read((DataInput)new DataInputStream(from));
    }

    public void read(DataInput from) throws IOException
    {
        revision = from.readUTF();
        list.read(from);
        dict.read(from);
        nest.read(from);
        info.read(from);
        infox.read(from);
        hotfix.clear();
        if (from.readByte() == (byte)0x01) {
            Long lenHotfix = from.readInt() & 0xFFFFFFFFL;
            for (Long iHotfix = 0L; iHotfix < lenHotfix; ++iHotfix) {
                java.lang.String k1 = from.readUTF();
                java.lang.String v1 = from.readUTF();
                hotfix.put(k1,v1);
            }
        }
    }

    public void write(OutputStream from) throws IOException
    {
        this.write((DataOutput)new DataOutputStream(from));
    }

    public void write(DataOutput dest) throws IOException
    {
        dest.writeUTF(revision);
        list.write(dest);
        dict.write(dest);
        nest.write(dest);
        info.write(dest);
        infox.write(dest);
        if (hotfix != null) {
            dest.writeByte((byte)0x01);
            dest.writeInt(hotfix.size());
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                dest.writeUTF(k1);
                java.lang.String v1 = hotfixIter.getValue();
                dest.writeUTF(v1);
            }
        } else {
            dest.writeByte((byte)0x00);
        }
    }

    public StringBuilder toStringXML (String name)
    {
        StringBuilder result = new StringBuilder();
        StringBuilder attrs  = new StringBuilder();
        StringBuilder nodes  = new StringBuilder();
        attrs.append(" revision=\"");
        attrs.append(revision); attrs.append("\"");
        nodes.append(list.toStringXML("list"));
        nodes.append(dict.toStringXML("dict"));
        nodes.append(nest.toStringXML("nest"));
        nodes.append(info.toStringXML("info"));
        nodes.append(infox.toStringXML("infox"));
        if (hotfix != null && hotfix.size() > 0) {
            nodes.append("<hotfix>");
            for (Map.Entry<java.lang.String,java.lang.String> hotfixIter : hotfix.entrySet()) {
                java.lang.String k1 = hotfixIter.getKey();
                nodes.append("<k1 value=\"");
                nodes.append(k1);
                nodes.append("\">");
                java.lang.String v1 = hotfixIter.getValue();
                nodes.append("<v1 value=\"");
                nodes.append(v1);
                nodes.append("\">");
            }
            nodes.append("</hotfix>");
        }
        result.append("<"); result.append(name); result.append(attrs);
        if (nodes.length() == 0) {
            result.append("/>");
        } else {
            result.append(">");
            result.append(nodes);
            result.append("</"); result.append(name); result.append(">");
        }
        return result;
    } //ConfigRoot::toStringXML (String name)

    public String toString ()
    {
        StringBuilder result = new StringBuilder();
        result.append("{ ");
        result.append(getClass().getName());
        result.append(", revision:");
        result.append("\"" + revision + "\"");
        result.append(", list:");
        result.append("<TestList>");
        result.append(", dict:");
        result.append("<TestDict>");
        result.append(", nest:");
        result.append("<TestNest>");
        result.append(", info:");
        result.append("<Info>");
        result.append(", infox:");
        result.append("<InfoX>");
        result.append(", hotfix:");
        if (hotfix != null) {
            result.append("[" + hotfix.size() + "]");
        } else {
            result.append("null");
        }
        result.append(" }");
        return result.toString();
    } //ConfigRoot::toString ()

}

