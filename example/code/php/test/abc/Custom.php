<?php
/*===----------------------------*  PHP 5  *-------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/

namespace test\abc;

require_once dirname(__FILE__) . '/../../test/xyz/Conflict.php';
require_once dirname(__FILE__) . '/../../test/abc/TestBasic.php';
require_once dirname(__FILE__) . '/../../test/abc/Gender.php';
require_once dirname(__FILE__) . '/../../test/abc/Conflict.php';
require_once dirname(__FILE__) . '/../../invar/invar.codec.php';

use \invar\BinaryReader;
use \invar\BinaryWriter;

final class Custom
{
    const CRC32 = 0x355EC042;

    static public function &CreateFromBytes (& $str)
    {
        $o = new Custom;
        $o->read(new BinaryReader($str));
        return $o;
    }

    private $x        ;/* 0 test.abc.Gender // 枚举值 */
    private $test     ;/* 1 test.abc.TestBasic // 其他类型 */
    private $xyz      ;/* 2 test.xyz.Conflict // 同名的类型 */
    private $abc      ;/* 3 test.abc.Conflict // 同名的类型 */
    private $children ;/* 4 vec<test.abc.Custom> // 自身类型容器 */
    private $noSetter ;/* 5 int32 // 屏蔽Setter */
    private $useRef   ;/* 6 string // 使用引用 */
    private $usePtr   ;/* 7 string // 使用指针 */
    private $prev     ;/* 8 test.abc.Custom // 自身类型 */
    private $next     ;/* 9 test.abc.Custom // 自身类型 */
    private $emptyDoc ;/* 10 string */

    function __construct()
    {
        $this->x        = Gender::NONE;
        $this->test     = new TestBasic;
        $this->xyz      = new test\xyz\Conflict;
        $this->abc      = new test\abc\Conflict;
        $this->children = array();
        $this->noSetter = -1;
        $this->useRef   = '';
        $this->usePtr   = NULL;
        $this->prev     = NULL;
        $this->next     = NULL;
        $this->emptyDoc = '';
    }
    /* End of constructor() */

    public function &copy (& $from)
    {
        if ($this == $from || $from == NULL) {
            return this;
        }
        $this->x = $from->x;
        $this->test = $from->test;
        $this->xyz = $from->xyz;
        $this->abc = $from->abc;
        if ($from->children != NULL) {
            $this->children = array_merge($from->children);
        } else {
            $this->children = array();
        }
        $this->noSetter = $from->noSetter;
        $this->useRef = $from->useRef;
        $this->usePtr = $from->usePtr;
        if ($from->prev != NULL) {
            $this->prev.copy($from->prev);
        } else {
            $this->prev = NULL;
        }
        if ($from->next != NULL) {
            $this->next.copy($from->next);
        } else {
            $this->next = NULL;
        }
        $this->emptyDoc = $from->emptyDoc;
        return $this;
    }
    /* End of copy(...) */

    public function &read (& $r)
    {
        $this->x = $r->readInt32();
        $this->test->read($r);
        $this->xyz->read($r);
        $this->abc->read($r);
        $this->children = array();
        $lenChildren = $r->readUInt32();
        for ($iChildren = 0; $iChildren < $lenChildren; ++$iChildren) {
            $n1 = new Custom();
            $n1->read($r);
            $this->children[] = $n1;
        }
        $this->noSetter = $r->readInt32();
        $this->useRef = $r->readUTF();
        $usePtrExists = $r->readInt08();
        if (0x01 == $usePtrExists) { $this->usePtr = $r->readUTF(); }
        else if (0x00 == $usePtrExists) { $this->usePtr = NULL; }
        else { throw new \Exception('Protoc read error: The value of ' . $usePtrExists . ' is invalid.', 496); }
        $prevExists = $r->readInt08();
        if (0x01 == $prevExists) {
            if ($this->prev == NULL) { $this->prev = new Custom; }
            $this->prev->read($r);
        }
        else if (0x00 == $prevExists) { $this->prev = NULL; }
        else { throw new \Exception('Protoc read error: The value of ' . $prevExists . ' is invalid.', 497); }
        $nextExists = $r->readInt08();
        if (0x01 == $nextExists) {
            if ($this->next == NULL) { $this->next = new Custom; }
            $this->next->read($r);
        }
        else if (0x00 == $nextExists) { $this->next = NULL; }
        else { throw new \Exception('Protoc read error: The value of ' . $nextExists . ' is invalid.', 497); }
        $this->emptyDoc = $r->readUTF();
        return $this;
    }
    /* End of read(...) */

    public function write (& $str)
    {
        BinaryWriter::writeInt32($this->x, $str);
        $this->test->write($str);
        $this->xyz->write($str);
        $this->abc->write($str);
        BinaryWriter::writeInt32(count($this->children), $str);
        foreach ($this->children as &$n1) {
            $n1->write($str);
        }
        BinaryWriter::writeInt32($this->noSetter, $str);
        BinaryWriter::writeUTF($this->useRef, $str);
        if ($this->usePtr != NULL) {
            BinaryWriter::writeInt08(0x01, $str);
            BinaryWriter::writeUTF($this->usePtr, $str);
        } else {
            BinaryWriter::writeInt08(0x00, $str);
        }
        if ($this->prev != NULL) {
            BinaryWriter::writeInt08(0x01, $str);
            $this->prev->write($str);
        } else {
            BinaryWriter::writeInt08(0x00, $str);
        }
        if ($this->next != NULL) {
            BinaryWriter::writeInt08(0x01, $str);
            $this->next->write($str);
        } else {
            BinaryWriter::writeInt08(0x00, $str);
        }
        BinaryWriter::writeUTF($this->emptyDoc, $str);
    }
    /* End of write(...) */

    /** 枚举值 */
    public function  getX() { return $this->x; }

    /** 其他类型 */
    public function &getTest() { return $this->test; }

    /** 同名的类型 */
    public function &getXyz() { return $this->xyz; }

    /** 同名的类型 */
    public function &getAbc() { return $this->abc; }

    /** 自身类型容器 */
    public function &getChildren() { return $this->children; }

    /** 屏蔽Setter */
    public function  getNoSetter() { return $this->noSetter; }

    /** 使用引用 */
    public function &getUseRef() { return $this->useRef; }

    /** 使用指针 */
    public function getUsePtr() { return $this->usePtr; }

    /** 自身类型 */
    public function getPrev() { return $this->prev; }

    /** 自身类型 */
    public function getNext() { return $this->next; }

    /**  */
    public function &getEmptyDoc() { return $this->emptyDoc; }

    /** 枚举值 */
    public function setX($value) { $this->x = $value; return $this; }

    /** 其他类型 */
    public function setTest($value) { $this->test = $value; return $this; }

    /** 同名的类型 */
    public function setXyz($value) { $this->xyz = $value; return $this; }

    /** 同名的类型 */
    public function setAbc($value) { $this->abc = $value; return $this; }

    /** 使用引用 */
    public function setUseRef($value) { $this->useRef = $value; return $this; }

    /** 使用指针 */
    public function setUsePtr($value) { $this->usePtr = $value; return $this; }

    /** 自身类型 */
    public function setPrev($value) { $this->prev = $value; return $this; }

    /** 自身类型 */
    public function setNext($value) { $this->next = $value; return $this; }

    /**  */
    public function setEmptyDoc($value) { $this->emptyDoc = $value; return $this; }

    public function &toString()
    {
        $s  = '{'; $s .= get_class($this);
        $s .= ','; $s .= 'x'; $s .= ':';
        $s .= $this->x;
        $s .= ','; $s .= 'test'; $s .= ':';
        $s .= '<'; $s .= 'TestBasic'; $s .= '>';
        $s .= ','; $s .= 'xyz'; $s .= ':';
        $s .= '<'; $s .= 'testxyzConflict'; $s .= '>';
        $s .= ','; $s .= 'abc'; $s .= ':';
        $s .= '<'; $s .= 'testabcConflict'; $s .= '>';
        $s .= ','; $s .= 'children'; $s .= ':';
        $s .= '('; $s .= count($this->children); $s .= ')';
        $s .= ','; $s .= 'noSetter'; $s .= ':';
        $s .= $this->noSetter;
        $s .= ','; $s .= 'useRef'; $s .= ':';
        $s .= '"'; $s .= $this->useRef; $s .= '"';
        $s .= ','; $s .= 'usePtr'; $s .= ':';
        if (isset($this->usePtr)) { $s .= '"'; $s .= $this->usePtr; $s .= '"'; }
        else { $s .= 'null'; }
        $s .= ','; $s .= 'prev'; $s .= ':';
        if (isset($this->prev)) { $s .= '<'; $s .= 'Custom'; $s .= '>'; }
        else { $s .= 'null'; }
        $s .= ','; $s .= 'next'; $s .= ':';
        if (isset($this->next)) { $s .= '<'; $s .= 'Custom'; $s .= '>'; }
        else { $s .= 'null'; }
        $s .= ','; $s .= 'emptyDoc'; $s .= ':';
        $s .= '"'; $s .= $this->emptyDoc; $s .= '"';
        $s .= '}';
        return $s;
    }
    /* End of toString() */

    public function &toStringJSON()
    {
        $code = '';
        $this->writeJSON($code);
        return $code;
    }

    public function writeJSON(& $s)
    {
        $s .= "\n"; $s .= '{';
        $s .= '"'; $s .= 'x'; $s .= '"'; $s .= ':'; $comma = ',';
        $s .= $this->x;
        $testExists = isset($this->test);
        if (!empty($comma) && $testExists) { $s .= $comma; $comma = ''; }
        if ($testExists) {
            $s .= '"'; $s .= 'test'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->test->writeJSON($s);
        }
        $xyzExists = isset($this->xyz);
        if (!empty($comma) && $xyzExists) { $s .= $comma; $comma = ''; }
        if ($xyzExists) {
            $s .= '"'; $s .= 'xyz'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->xyz->writeJSON($s);
        }
        $abcExists = isset($this->abc);
        if (!empty($comma) && $abcExists) { $s .= $comma; $comma = ''; }
        if ($abcExists) {
            $s .= '"'; $s .= 'abc'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->abc->writeJSON($s);
        }
        $childrenExists = (isset($this->children) && count($this->children) > 0);
        if (!empty($comma) && $childrenExists) { $s .= $comma; $comma = ''; }
        if ($childrenExists) {
            $s .= '"'; $s .= 'children'; $s .= '"'; $s .= ':'; $comma = ',';
            $childrenSize = (!isset($this->children) ? 0 : count($this->children));
            $s .= "\n"; $s .= '[';
            $childrenIdx = 0;
            foreach ($this->children as &$n1) {
                $n1->writeJSON($s);
                ++$childrenIdx;
                if ($childrenIdx != $childrenSize) { $s .= ','; }
            }
            $s .= ']';
        }
        if (!empty($comma)) { $s .= $comma; $comma = ''; }
        $s .= '"'; $s .= 'noSetter'; $s .= '"'; $s .= ':'; $comma = ',';
        $s .= $this->noSetter;
        $useRefExists = !empty($this->useRef);
        if (!empty($comma) && $useRefExists) { $s .= $comma; $comma = ''; }
        if ($useRefExists) {
            $s .= '"'; $s .= 'useRef'; $s .= '"'; $s .= ':'; $comma = ',';
            $s .= '"'; $s .= $this->useRef; $s .= '"';
        }
        $usePtrExists = !empty($this->usePtr);
        if (!empty($comma) && $usePtrExists) { $s .= $comma; $comma = ''; }
        if ($usePtrExists) {
            $s .= '"'; $s .= 'usePtr'; $s .= '"'; $s .= ':'; $comma = ',';
            $s .= '"'; $s .= $this->usePtr; $s .= '"';
        }
        $prevExists = isset($this->prev);
        if (!empty($comma) && $prevExists) { $s .= $comma; $comma = ''; }
        if ($prevExists) {
            $s .= '"'; $s .= 'prev'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->prev->writeJSON($s);
        }
        $nextExists = isset($this->next);
        if (!empty($comma) && $nextExists) { $s .= $comma; $comma = ''; }
        if ($nextExists) {
            $s .= '"'; $s .= 'next'; $s .= '"'; $s .= ':'; $comma = ',';
            $this->next->writeJSON($s);
        }
        $emptyDocExists = !empty($this->emptyDoc);
        if (!empty($comma) && $emptyDocExists) { $s .= $comma; $comma = ''; }
        if ($emptyDocExists) {
            $s .= '"'; $s .= 'emptyDoc'; $s .= '"'; $s .= ':'; $comma = ',';
            $s .= '"'; $s .= $this->emptyDoc; $s .= '"';
        }
        $s .= '}'; $s .= "\n";
    }
    /* End of writeJSON(...) */

    public function &toStringXML()
    {
        $code  = '<?xml version="1.0" encoding="UTF-8"?>';
        $code .= "\n"; $code .= '<!-- '; $code .= 'Custom'; $code .= '.CRC32: 0x';
        $code .= strtoupper(dechex(self::CRC32)); $code .= ' -->';
        $code .= "\n"; $this->writeXML($code, 'Custom');
        return $code;
    }

    public function writeXML (& $s, $name)
    {
        $attrs = ''; $nodes = '';
        $attrs .= ' '; $attrs .= 'x'; $attrs .= '=';
        $attrs .= '"'; $attrs .= $this->x; $attrs .= '"';
        $this->test->writeXML($nodes, 'test');
        $this->xyz->writeXML($nodes, 'xyz');
        $this->abc->writeXML($nodes, 'abc');
        if (count($this->children) > 0) {
            $nodes .= '<'; $nodes .= 'children'; $nodes .= '>';
            foreach ($this->children as &$n1) {
                $n1->writeXML($nodes, 'n1');
            }
            $nodes .= '</'; $nodes .= 'children'; $nodes .= '>';
        }
        $attrs .= ' '; $attrs .= 'noSetter'; $attrs .= '=';
        $attrs .= '"'; $attrs .= $this->noSetter; $attrs .= '"';
        $attrs .= ' '; $attrs .= 'useRef'; $attrs .= '=';
        $attrs .= '"'; $attrs .= $this->useRef; $attrs .= '"';
        if (isset($this->usePtr)) {
            $attrs .= ' usePtr="';
            $attrs .= $$this->usePtr;
            $attrs .= '"';
        }
        if (isset($this->prev)) {
            $this->prev->writeXML($nodes, 'prev');
        }
        if (isset($this->next)) {
            $this->next->writeXML($nodes, 'next');
        }
        $attrs .= ' '; $attrs .= 'emptyDoc'; $attrs .= '=';
        $attrs .= '"'; $attrs .= $this->emptyDoc; $attrs .= '"';
        $s .= '<';
        $s .= $name;
        $s .= $attrs;
        if (strlen($nodes) == 0) {
            $s .= '/>';
        } else {
            $s .= '>'; $s .= $nodes;
            $s .= '</'; $s .= $name; $s .= '>';
        }
    }
    /* End of writeXML(...) */

}
