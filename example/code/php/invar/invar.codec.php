<?php
//===----------------------------*  PHP 5  *-------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===//

namespace invar;

abstract class BinaryWriter
{
	static public function writeInt08($v, &$bytes) {
	    if ($v < -128 || $v > 127) {
	        throw new \Exception ('Out of range Int8 [-128,127]: ' . $v);
	    }
		$bytes .= pack ( 'c', $v );
	}
	static public function writeInt16($v, &$bytes) {
        if ($v < -32768 || $v > 32767) {
            throw new \Exception ('Out of range Int16 [-32768,32767]: ' . $v);
        }
		$bytes .= pack ( 'v', $v ); // big endian 'n'
	}
	static public function writeInt32($v, &$bytes) {
	    if ($v < -2147483648 || $v > 2147483647) {
            throw new \Exception ('Out of range Int32 [-2147483648,2147483647]: ' . $v);
        }
		$bytes .= pack ( 'V', $v ); // big endian 'N'
	}
	static public function writeInt64($v, &$bytes) {
        if ($v < -9223372036854774808 || $v > 9223372036854774807) {
            throw new \Exception ('Out of range Int64 [-9223372036854774808,9223372036854774807]: ' . $v);
        }
        $hi = $v >> 32;
        $lo = $v & 0x00000000ffffffff;
        $bytes .= pack ( 'VV', $lo, $hi );
    }
	static public function writeUInt08($v, &$bytes) {
	    if ($v < 0 || $v > 255) {
            throw new \Exception ('Out of range UInt8 [0,255]: ' . $v);
        }
		$bytes .= pack ( 'c', $v );
	}
	static public function writeUInt16($v, &$bytes) {
	    if ($v < 0 || $v > 65535) {
            throw new \Exception ('Out of range UInt16 [0,65535]: ' . $v);
        }
		$bytes .= pack ( 'v', $v );
	}
	static public function writeUInt32($v, &$bytes) {
		if ($v < 0 || $v > 4294967295) {
            throw new \Exception ('Out of range UInt32 [0,4294967295]: ' . $v);
        }
		$bytes .= pack ( 'V', $v );
	}
	static public function writeUInt64($v, &$bytes) {
        //FIXME var_dump(0xFFFFFFFFFFFFFFFF); // float
        if ($v < 0 || $v > 18446744073709551615) {
            throw new \Exception ('Out of range UInt64 [0,18446744073709551615]: ' . $v);
        }
        $hi = $v >> 32;
        $lo = $v & 0x00000000ffffffff;
        $bytes .= pack ( 'VV', $lo, $hi );
    }
	static public function writeFloat32($v, &$bytes) {
		// float (machine dependent size and representation)
		$bytes .= pack ( 'f', $v );
	}
	static public function writeFloat64($v, &$bytes) {
		// double (machine dependent size and representation)
		$bytes .= pack ( 'd', $v );
	}
	static public function writeBoolean($v, &$bytes) {
		$bytes .= ($v == TRUE) ? "\x01" : "\x00";
	}
	static public function writeUTF($v, &$bytes) {
		$bytes .= pack ( 'VA*', strlen ( $v ), $v );
	}
}

final class BinaryReader
{
	private $data = NULL;
	private $bytes = NULL;
	private $bytesPos = 1;
	private $bytesLen = 0;
	function __construct(&$data) {
		if (is_null ( $data )) {
			throw new \Exception ( '$data is null' );
		}
		// $data The packed data.
		$this->data = $data;
		$this->bytes = unpack ( "C*", $data ); // index begin from 1.
		$this->bytesLen = count ( $this->bytes );
	}
	function __destruct() {
		// print "Destroying DataInput...\n";
		$this->bytes = NULL;
		$this->bytesLen = 0;
		$this->bytesPos = 1;
	}
	function checkAvailable($offset) {
		if ($this->bytesPos + $offset > $this->bytesLen + 1) {
			throw new \Exception ( 'EOF Error' );
		}
	}
	public function readInt08() {
		$this->checkAvailable ( 1 );
		$bits = $this->bytes [$this->bytesPos];
		$sign = ($bits >> 7) == 0 ? 1 : - 1;
		$this->bytesPos ++;
		return $sign < 0 ? ((~ ($bits - 1)) & 0xFF) * $sign : $bits;
	}
	public function readInt16() {
		$this->checkAvailable ( 2 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$sign = ($b2 >> 7) == 0 ? 1 : - 1;
		$bits = ($b2 << 8) | $b1;
		return $sign < 0 ? ((~ ($bits - 1)) & 0xFFFF) * $sign : $bits;
	}
	public function readInt32() {
		$this->checkAvailable ( 4 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b3 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b4 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$sign = ($b4 >> 7) == 0 ? 1 : - 1;
		$bits = ($b4 << 24) | ($b3 << 16) | ($b2 << 8) | $b1;
		return $sign < 0 ? ((~ ($bits - 1)) & 0xFFFFFFFF) * $sign : $bits;
	}
	public function readUInt08() {
		$this->checkAvailable ( 1 );
		$result = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return $result;
	}
	public function readUInt16() {
		$this->checkAvailable ( 2 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return ($b2 << 8) | $b1;
	}
	public function readUInt32() {
		$this->checkAvailable ( 4 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b3 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b4 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return ($b4 << 24) | ($b3 << 16) | ($b2 << 8) | $b1;
	}
	public function readBoolean() {
		$this->checkAvailable ( 1 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return $b1 == 0 ? FALSE : TRUE;
	}
	public function readInt64() {
		$this->checkAvailable ( 8 );
		$packed = substr ( $this->data, $this->bytesPos - 1, 8 );
		list ( $lower, $higher ) = array_values ( unpack ( 'V2', $packed ) );
		$this->bytesPos += 8;
		return $higher << 32 | $lower;
	}
	public function readUInt64() {
		$this->checkAvailable ( 8 );
		$packed = substr ( $this->data, $this->bytesPos - 1, 8 );
		list ( $lower, $higher ) = array_values ( unpack ( 'V2', $packed ) );
		$this->bytesPos += 8;
		return $higher << 32 | $lower;
	}
	public function readUTF() {
		$len = $this->readInt32 ();
		$this->checkAvailable ( $len );
		$s = substr ( $this->data, $this->bytesPos - 1, $len );
		$a = unpack ( 'A*', $s );
		$this->bytesPos += $len;
		return $a [1];
	}
	public function readFloat32() {
	    $this->checkAvailable ( 4 );
        $packed = substr ( $this->data, $this->bytesPos - 1, 4 );
        list ( $v ) = array_values ( unpack ( 'f', $packed ) );
        $this->bytesPos += 4;
	    return $v;
	}
	public function readFloat64() {
        $this->checkAvailable ( 8 );
        $packed = substr ( $this->data, $this->bytesPos - 1, 8 );
        list ( $v ) = array_values ( unpack ( 'd', $packed ) );
        $this->bytesPos += 8;
        return $v;
    }
    public function peekUInt16() {
        $this->checkAvailable ( 2 );
        $b1 = $this->bytes [$this->bytesPos];
        $b2 = $this->bytes [$this->bytesPos + 1];
        return ($b2 << 8) | $b1;
    }
    public function peekInt32() {
        $this->checkAvailable ( 4 );
        $b1 = $this->bytes [$this->bytesPos];
        $b2 = $this->bytes [$this->bytesPos + 1];
        $b3 = $this->bytes [$this->bytesPos + 2];
        $b4 = $this->bytes [$this->bytesPos + 3];
        $sign = ($b4 >> 7) == 0 ? 1 : - 1;
        $bits = ($b4 << 24) | ($b3 << 16) | ($b2 << 8) | $b1;
        return $sign < 0 ? ((~ ($bits - 1)) & 0xFFFFFFFF) * $sign : $bits;
    }

}