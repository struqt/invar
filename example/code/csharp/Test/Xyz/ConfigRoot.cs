/*===-----------------------------*  C#  *---------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------===*/

namespace Test.Xyz {

using System.Collections.Generic;
using System.IO;
using System.Text;
using System;
using Test.Abc;

/// .
public sealed class ConfigRoot
: Invar.BinaryDecode
, Invar.BinaryEncode
, Invar.JSONEncode
, Invar.XMLEncode
{
    public const uint CRC32 = 0xDAEE388D;

    private String                    revision = "1.0.0";
    private TestList                  list     = new TestList();
    private TestDict                  dict     = new TestDict();
    private TestNest                  nest     = new TestNest();
    private Info                      info     = new Info();
    private InfoX                     infox    = new InfoX();
    private Dictionary<String,String> hotfix   = null; // [AutoAdd] Hotfix.

    /// .
    [Invar.InvarRule("string", "f0")]
    public String GetRevision() { return this.revision; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestList", "f1")]
    public TestList GetList() { return this.list; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestDict", "f2")]
    public TestDict GetDict() { return this.dict; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestNest", "f3")]
    public TestNest GetNest() { return this.nest; }

    /// .
    [Invar.InvarRule("Test.Abc.Info", "f4")]
    public Info GetInfo() { return this.info; }

    /// .
    [Invar.InvarRule("Test.Xyz.InfoX", "f5")]
    public InfoX GetInfox() { return this.infox; }

    /// [AutoAdd] Hotfix.
    [Invar.InvarRule("map<string,string>", "f6")]
    public Dictionary<String,String> GetHotfix() { return this.hotfix; }

    /// .
    [Invar.InvarRule("string", "f0")]
    public ConfigRoot SetRevision(String value) { this.revision = value; return this; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestList", "f1")]
    public ConfigRoot SetList(TestList value) { this.list = value; return this; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestDict", "f2")]
    public ConfigRoot SetDict(TestDict value) { this.dict = value; return this; }

    /// .
    [Invar.InvarRule("Test.Xyz.TestNest", "f3")]
    public ConfigRoot SetNest(TestNest value) { this.nest = value; return this; }

    /// .
    [Invar.InvarRule("Test.Abc.Info", "f4")]
    public ConfigRoot SetInfo(Info value) { this.info = value; return this; }

    /// .
    [Invar.InvarRule("Test.Xyz.InfoX", "f5")]
    public ConfigRoot SetInfox(InfoX value) { this.infox = value; return this; }

    /// [AutoAdd] Hotfix.
    [Invar.InvarRule("map<string,string>", "f6")]
    public ConfigRoot SetHotfix(Dictionary<String,String> value) { this.hotfix = value; return this; }

    public ConfigRoot Reuse()
    {
        this.revision = "1.0.0";
        this.list.Reuse();
        this.dict.Reuse();
        this.nest.Reuse();
        this.info.Reuse();
        this.infox.Reuse();
        if (this.hotfix != null) { this.hotfix.Clear(); }
        return this;
    } //ConfigRoot::Reuse()

    public ConfigRoot Copy(ConfigRoot from_)
    {
        if (null == from_ || this == from_) {
            return this;
        }
        this.revision = from_.revision;
        this.list.Copy(from_.list);
        this.dict.Copy(from_.dict);
        this.nest.Copy(from_.nest);
        this.info.Copy(from_.info);
        this.infox.Copy(from_.infox);
        if (null == from_.hotfix) {
            this.hotfix = null;
        } else {
            if (null == this.hotfix) { this.hotfix = new Dictionary<String,String>(); }
            else { this.hotfix.Clear(); }
            foreach (var hotfixIter in from_.hotfix) {
                this.hotfix.Add(hotfixIter.Key, hotfixIter.Value);
            }
        }
        return this;
    } //ConfigRoot::Copy(...)

    public void Read(BinaryReader r)
    {
        this.revision = Encoding.UTF8.GetString(r.ReadBytes(r.ReadInt32()));
        this.list.Read(r);
        this.dict.Read(r);
        this.nest.Read(r);
        this.info.Read(r);
        this.infox.Read(r);
        sbyte hotfixExists = r.ReadSByte();
        if ((sbyte)0x01 == hotfixExists) {
            if (this.hotfix == null) { this.hotfix = new Dictionary<String,String>(); }
            UInt32 lenHotfix = r.ReadUInt32();
            for (UInt32 iHotfix = 0; iHotfix < lenHotfix; iHotfix++) {
                String k1 = Encoding.UTF8.GetString(r.ReadBytes(r.ReadInt32()));
                String v1 = Encoding.UTF8.GetString(r.ReadBytes(r.ReadInt32()));
                if (!this.hotfix.ContainsKey(k1)) {
                    this.hotfix.Add(k1, v1);
                } else {
                    this.hotfix[k1] = v1;
                }
            }
        }
        else if ((sbyte)0x00 == hotfixExists) { this.hotfix = null; }
        else { throw new IOException("Protoc read error: The value of 'hotfixExists' is invalid.", 498); }
    } //ConfigRoot::Read(...)

    public void Write(BinaryWriter w)
    {
        byte[] revisionBytes = Encoding.UTF8.GetBytes(this.revision);
        w.Write(revisionBytes.Length);
        w.Write(revisionBytes);
        this.list.Write(w);
        this.dict.Write(w);
        this.nest.Write(w);
        this.info.Write(w);
        this.infox.Write(w);
        if (this.hotfix != null) {
            w.Write((sbyte)0x01);
            w.Write(this.hotfix.Count);
            foreach (KeyValuePair<String,String> hotfixIter in this.hotfix) {
                String k1 = hotfixIter.Key;
                byte[] k1Bytes = Encoding.UTF8.GetBytes(k1);
                w.Write(k1Bytes.Length);
                w.Write(k1Bytes);
                String v1 = hotfixIter.Value;
                byte[] v1Bytes = Encoding.UTF8.GetBytes(v1);
                w.Write(v1Bytes.Length);
                w.Write(v1Bytes);
            }
        } else {
            w.Write((sbyte)0x00);
        }
    } //ConfigRoot::Write(...)

    public override String ToString()
    {
        StringBuilder result = new StringBuilder();
        result.Append('{').Append(' ');
        result.Append(GetType().ToString());
        result.Append(',').Append(' ').Append("revision").Append(':');
        result.Append("\"" + this.revision + "\"");
        result.Append(',').Append(' ').Append("list").Append(':');
        result.Append("<TestList>");
        result.Append(',').Append(' ').Append("dict").Append(':');
        result.Append("<TestDict>");
        result.Append(',').Append(' ').Append("nest").Append(':');
        result.Append("<TestNest>");
        result.Append(',').Append(' ').Append("info").Append(':');
        result.Append("<Info>");
        result.Append(',').Append(' ').Append("infox").Append(':');
        result.Append("<InfoX>");
        result.Append(',').Append(' ').Append("hotfix").Append(':');
        if (this.hotfix != null) { result.Append("[" + this.hotfix.Count + "]"); }
        else { result.Append("null"); }
        result.Append(' ').Append('}');
        return result.ToString();
    } //ConfigRoot::ToString()

    public StringBuilder ToStringJSON()
    {
        StringBuilder code = new StringBuilder();
        this.WriteJSON(code);
        return code;
    }

    public void WriteJSON(StringBuilder s)
    {
        s.Append('\n').Append('{');
        string comma = null;
        bool revisionExists = !String.IsNullOrEmpty(this.revision);
        if (revisionExists) {
            s.Append('"').Append("revision").Append('"').Append(':'); comma = ","; s.Append('"').Append(this.revision.ToString()).Append('"');
        }
        bool listExists = (null != this.list);
        if (!String.IsNullOrEmpty(comma) && listExists) { s.Append(comma); comma = null; }
        if (listExists) {
            s.Append('"').Append("list").Append('"').Append(':'); comma = ","; this.list.WriteJSON(s);
        }
        bool dictExists = (null != this.dict);
        if (!String.IsNullOrEmpty(comma) && dictExists) { s.Append(comma); comma = null; }
        if (dictExists) {
            s.Append('"').Append("dict").Append('"').Append(':'); comma = ","; this.dict.WriteJSON(s);
        }
        bool nestExists = (null != this.nest);
        if (!String.IsNullOrEmpty(comma) && nestExists) { s.Append(comma); comma = null; }
        if (nestExists) {
            s.Append('"').Append("nest").Append('"').Append(':'); comma = ","; this.nest.WriteJSON(s);
        }
        bool infoExists = (null != this.info);
        if (!String.IsNullOrEmpty(comma) && infoExists) { s.Append(comma); comma = null; }
        if (infoExists) {
            s.Append('"').Append("info").Append('"').Append(':'); comma = ","; this.info.WriteJSON(s);
        }
        bool infoxExists = (null != this.infox);
        if (!String.IsNullOrEmpty(comma) && infoxExists) { s.Append(comma); comma = null; }
        if (infoxExists) {
            s.Append('"').Append("infox").Append('"').Append(':'); comma = ","; this.infox.WriteJSON(s);
        }
        bool hotfixExists = (null != this.hotfix && this.hotfix.Count > 0);
        if (!String.IsNullOrEmpty(comma) && hotfixExists) { s.Append(comma); comma = null; }
        if (hotfixExists) {
            int hotfixSize = (null == this.hotfix ? 0 : this.hotfix.Count);
            if (hotfixSize > 0) {
                s.Append('\n').Append('{');
                int hotfixIdx = 0;
                foreach (KeyValuePair<String,String> hotfixIter in this.hotfix) { /* map.for: this.hotfix */
                    ++hotfixIdx;
                    String k1 = hotfixIter.Key; /* nest.k */
                    s.Append('"'); s.Append('"').Append(k1.ToString()).Append('"'); s.Append('"').Append(':');
                    String v1 = hotfixIter.Value; /* nest.v */
                    s.Append('"').Append(v1.ToString()).Append('"');
                    if (hotfixIdx != hotfixSize) { s.Append(','); }
                }
                s.Append('}');
            } comma = ",";
        }
        s.Append('}').Append('\n');
    } //ConfigRoot::WriteJSON(...)

    public StringBuilder ToStringLua()
    {
        StringBuilder code = new StringBuilder();
        code.Append("-- ConfigRoot.CRC32: 0x");
        code.Append(CRC32.ToString("X2")).Append(" --").Append('\n');
        code.Append("local table=");
        this.WriteLua(code); code.Append(';');
        return code;
    }

    public void WriteLua(StringBuilder s)
    {
        s.Append('\n').Append('{');
        string comma = null;
        bool revisionExists = !String.IsNullOrEmpty(this.revision);
        if (revisionExists) {
            s.Append("revision").Append('='); comma = ","; s.Append('"').Append(this.revision.ToString()).Append('"');
        }
        bool listExists = (null != this.list);
        if (!String.IsNullOrEmpty(comma) && listExists) { s.Append(comma); comma = null; }
        if (listExists) {
            s.Append("list").Append('='); comma = ","; this.list.WriteLua(s);
        }
        bool dictExists = (null != this.dict);
        if (!String.IsNullOrEmpty(comma) && dictExists) { s.Append(comma); comma = null; }
        if (dictExists) {
            s.Append("dict").Append('='); comma = ","; this.dict.WriteLua(s);
        }
        bool nestExists = (null != this.nest);
        if (!String.IsNullOrEmpty(comma) && nestExists) { s.Append(comma); comma = null; }
        if (nestExists) {
            s.Append("nest").Append('='); comma = ","; this.nest.WriteLua(s);
        }
        bool infoExists = (null != this.info);
        if (!String.IsNullOrEmpty(comma) && infoExists) { s.Append(comma); comma = null; }
        if (infoExists) {
            s.Append("info").Append('='); comma = ","; this.info.WriteLua(s);
        }
        bool infoxExists = (null != this.infox);
        if (!String.IsNullOrEmpty(comma) && infoxExists) { s.Append(comma); comma = null; }
        if (infoxExists) {
            s.Append("infox").Append('='); comma = ","; this.infox.WriteLua(s);
        }
        bool hotfixExists = (null != this.hotfix && this.hotfix.Count > 0);
        if (!String.IsNullOrEmpty(comma) && hotfixExists) { s.Append(comma); comma = null; }
        if (hotfixExists) {
            int hotfixSize = (null == this.hotfix ? 0 : this.hotfix.Count);
            if (hotfixSize > 0) {
                s.Append('\n').Append('{');
                int hotfixIdx = 0;
                foreach (KeyValuePair<String,String> hotfixIter in this.hotfix) { /* map.for: this.hotfix */
                    ++hotfixIdx;
                    String k1 = hotfixIter.Key; /* nest.k */
                    s.Append('"').Append(k1.ToString()).Append('"'); s.Append('=');
                    String v1 = hotfixIter.Value; /* nest.v */
                    s.Append('"').Append(v1.ToString()).Append('"');
                    if (hotfixIdx != hotfixSize) { s.Append(','); }
                    s.Append('}');
                }
            } comma = ",";
        }
        s.Append('}').Append('\n');
    }

    public StringBuilder ToStringPHP()
    {
        StringBuilder code = new StringBuilder();
        code.Append("<?php ").Append("/* ConfigRoot.CRC32: 0x");
        code.Append(CRC32.ToString("X2")).Append(" */").Append('\n');
        code.Append('\n').Append("return ");
        this.WritePHP(code); code.Append(';').Append('\n');
        return code;
    }

    public void WritePHP(StringBuilder s)
    {
        s.Append("array").Append('(').Append('\n');
        string comma = null;
        bool revisionExists = !String.IsNullOrEmpty(this.revision);
        if (revisionExists) {
            s.Append('\'').Append("revision").Append('\'').Append("=>"); comma = ","; s.Append('\'').Append(this.revision.ToString()).Append('\'');
        }
        bool listExists = (null != this.list);
        if (!String.IsNullOrEmpty(comma) && listExists) { s.Append(comma).Append('\n'); comma = null; }
        if (listExists) {
            s.Append('\'').Append("list").Append('\'').Append("=>"); comma = ","; this.list.WritePHP(s);
        }
        bool dictExists = (null != this.dict);
        if (!String.IsNullOrEmpty(comma) && dictExists) { s.Append(comma).Append('\n'); comma = null; }
        if (dictExists) {
            s.Append('\'').Append("dict").Append('\'').Append("=>"); comma = ","; this.dict.WritePHP(s);
        }
        bool nestExists = (null != this.nest);
        if (!String.IsNullOrEmpty(comma) && nestExists) { s.Append(comma).Append('\n'); comma = null; }
        if (nestExists) {
            s.Append('\'').Append("nest").Append('\'').Append("=>"); comma = ","; this.nest.WritePHP(s);
        }
        bool infoExists = (null != this.info);
        if (!String.IsNullOrEmpty(comma) && infoExists) { s.Append(comma).Append('\n'); comma = null; }
        if (infoExists) {
            s.Append('\'').Append("info").Append('\'').Append("=>"); comma = ","; this.info.WritePHP(s);
        }
        bool infoxExists = (null != this.infox);
        if (!String.IsNullOrEmpty(comma) && infoxExists) { s.Append(comma).Append('\n'); comma = null; }
        if (infoxExists) {
            s.Append('\'').Append("infox").Append('\'').Append("=>"); comma = ","; this.infox.WritePHP(s);
        }
        bool hotfixExists = (null != this.hotfix && this.hotfix.Count > 0);
        if (!String.IsNullOrEmpty(comma) && hotfixExists) { s.Append(comma).Append('\n'); comma = null; }
        if (hotfixExists) {
            int hotfixSize = (null == this.hotfix ? 0 : this.hotfix.Count);
            if (hotfixSize > 0) {
                s.Append("array").Append('(').Append('\n');
                int hotfixIdx = 0;
                foreach (KeyValuePair<String,String> hotfixIter in this.hotfix) { /* map.for: this.hotfix */
                    ++hotfixIdx;
                    String k1 = hotfixIter.Key; /* nest.k */
                    s.Append('\'').Append(k1.ToString()).Append('\''); s.Append("=>");
                    String v1 = hotfixIter.Value; /* nest.v */
                    s.Append('\'').Append(v1.ToString()).Append('\'');
                    if (hotfixIdx != hotfixSize) { s.Append(','); s.Append('\n'); }
                }
                s.Append("/* map size: ").Append(this.hotfix.Count).Append(" */").Append(')');
            } comma = ",";
        }
        s.Append("/* ").Append(GetType().ToString()).Append(" */");
        s.Append(')');
    }

    public StringBuilder ToStringXML()
    {
        StringBuilder code = new StringBuilder();
        code.Append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        code.Append('\n').Append("<!-- ").Append("ConfigRoot").Append(".CRC32: 0x");
        code.Append(CRC32.ToString("X2")).Append(" -->");
        this.WriteXML(code, "ConfigRoot");
        return code;
    }

    public void WriteXML(StringBuilder s, String name)
    {
        StringBuilder attrs = new StringBuilder();
        StringBuilder nodes = new StringBuilder();
        attrs.Append(' ').Append("revision").Append('=').Append('"').Append(this.revision).Append('"');
        this.list.WriteXML(nodes, "list");
        this.dict.WriteXML(nodes, "dict");
        this.nest.WriteXML(nodes, "nest");
        this.info.WriteXML(nodes, "info");
        this.infox.WriteXML(nodes, "infox");
        if (this.hotfix != null && this.hotfix.Count > 0) {
            nodes.Append('\n').Append('<').Append("hotfix").Append('>');
            foreach (KeyValuePair<String,String> hotfixIter in this.hotfix) {
                nodes.Append('\n');
                String k1 = hotfixIter.Key;
                nodes.Append('<').Append("k1").Append(' ').Append("value").Append('=').Append('"');
                nodes.Append(k1);
                nodes.Append('"').Append('/').Append('>');
                String v1 = hotfixIter.Value;
                nodes.Append('<').Append("v1").Append(' ').Append("value").Append('=').Append('"');
                nodes.Append(v1);
                nodes.Append('"').Append('/').Append('>');
            }
            nodes.Append('<').Append('/').Append("hotfix").Append('>');
        }
        s.Append('\n').Append('<').Append(name).Append(attrs);
        if (nodes.Length == 0) {
            s.Append('/').Append('>');
        } else {
            s.Append('>').Append(nodes);
            s.Append('<').Append('/').Append(name).Append('>');
        }
    } //ConfigRoot::WriteXML(...)

} //class: ConfigRoot
/*
5@test.xyz.ConfigRoot/string/Test.Xyz.TestList/Test.Xyz.TestDict/Test.Xyz.TestNest/Test.Abc.Info/Tes
  t.Xyz.InfoX/map-string-string
+@test.abc.Info/int32/int8/int16/int32/int64/uint8/uint16/uint32/uint64/float/double/bool/string/vec
  -string/int32/Test.Abc.Info/Test.Abc.Conflict/vec-Test.Xyz.Conflict/vec-double/map-Test.Abc.Info-i
  nt32/map-int32-Test.Abc.Info/map-int32-double/map-string-string
+@test.xyz.InfoX/vec-vec-vec-vec-vec-Test.Abc.Info/Test.Xyz.Conflict/Test.Abc.Conflict/map-int32-Tes
  t.Abc.Conflict/vec-vec-Test.Abc.Info/vec-vec-vec-Test.Abc.Info/vec-vec-vec-vec-vec-Test.Abc.Info/v
  ec-map-int16-Test.Abc.Info/map-vec-int32-Test.Abc.Info/map-Test.Abc.Info-vec-int32/map-vec-Test.Ab
  c.Info-vec-int32/vec-map-vec-Test.Abc.Info-vec-int32/map-string-string
+@test.xyz.TestDict/map-int8-int8/map-int16-int16/map-int32-int32/map-int64-int64/map-uint8-uint8/ma
  p-uint16-uint16/map-uint32-uint32/map-uint64-uint64/map-float-float/map-double-double/map-bool-boo
  l/map-string-string/map-int32-int32/map-Test.Abc.Custom-Test.Abc.Custom/map-string-string
+@test.xyz.TestList/vec-int8/vec-int16/vec-int32/vec-int64/vec-uint8/vec-uint16/vec-uint32/vec-uint6
  4/vec-float/vec-double/vec-bool/vec-string/vec-int32/vec-Test.Abc.Custom/map-string-string
+@test.xyz.TestNest/vec-map-string-Test.Abc.Custom/map-vec-string-vec-Test.Abc.Custom/vec-vec-vec-ve
  c-vec-Test.Abc.Custom/map-string-string
*/
} //namespace: Test.Xyz