//*==---------------------------*  Obj-C  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------==*//
///*
#if ! __has_feature(objc_arc)
#error This file must be compiled with ARC. Either turn on ARC for the project or use -fobjc-arc flag
#endif //*/

#import "test_protoc_TestUserLoginR2C.h"
#import "test_protoc_TestUserLogin2S.h"
#import "test_protoc_TestUserLocationN2S.h"
#import "test_protoc_TestServerTimeN2C.h"
#import "test_protoc_TestHeartBeatR2S.h"
#import "test_protoc_TestHeartBeat2C.h"
#import "InvarRuntime.h"
#import "ProtocHandlers.h"

@implementation InvarRuntime

+ (instancetype) shared
{
    static id sharedInstance = nil;
    static dispatch_once_t predicate;
    dispatch_once(&predicate, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (instancetype) init
{
    self = [super init];
    if (!self) { return self; }
    _blockRecvRequest = ^(id req, id resp) {
        NSLog(@"Unhandled request: No function named 'Handle%@'.", [req class]);
        [resp setProtocError:INVAR_ERR_PROTOC_NO_HANDLER];
    };
    _blockRecvResponse = ^(id resp) {
        NSLog(@"Unhandled response: No function named 'Handle%@'.", [resp class]);
    };
    _blockRecvNotify = ^(id ntf) {
        NSLog(@"Unhandled notify: No function named 'Handle%@'.", [ntf class]);
    };
    _blockHandleError = ^(NSInteger code, uint16_t protoc) {
        NSLog(@"Error when handle protocol %@, the error code is %@", @(protoc), @(code));
    };
    return self;
}

+ (id<InvarEncode>)HandleProtocAsServer:(DataReader * const)r Protoc:(uint16_t *)p Error:(uint16_t *)e
{
    BOOL eof = NO; id resp = nil;
    NSInteger code = INVAR_ERR_PROTOC_UNHANDLED;
    NSUInteger request = [r peekUInt16:&eof];
    if (eof) { code = INVAR_ERR_DECODE_EOF; goto error; }
    switch (request) {
     case 65527: /* 客户端请求,服务端响应 */ {
        id req = [[TestUserLogin2S alloc] init]; resp = [[TestUserLoginR2C alloc] init];
        if (INVAR_ERR_NONE == (code = [req read:r])) { HandleTestUserLogin2S(req, resp); }
        break; }
     case 65531: /* 客户端通知服务端 */ {
        id ntf = [[TestUserLocationN2S alloc] init];
        if (INVAR_ERR_NONE == (code = [ntf read:r])) { HandleTestUserLocationN2S(ntf); }
        break; }
     case 65533: /* 服务端请求,客户端响应 */ {
        id rep = [[TestHeartBeatR2S alloc] init];
        if (INVAR_ERR_NONE == (code = [rep read:r])) { HandleTestHeartBeatR2S(rep); }
        break; }
     default: { code = INVAR_ERR_PROTOC_NO_HANDLER; break; }
    }
error:
    if (INVAR_ERR_NONE != code && [[[self class] shared] blockHandleError]) {
        [[[self class] shared] blockHandleError](code, request);
    }
    if (resp) {
        [resp setProtocError:code];
    }
    *p = request;
    *e = code;
    return resp;
}
/* HandleProtocAsServer */

+ (id<InvarEncode>)HandleProtocAsClient:(DataReader * const)r Protoc:(uint16_t *)p Error:(uint16_t *)e
{
    BOOL eof = NO; id resp = nil;
    NSInteger code = INVAR_ERR_PROTOC_UNHANDLED;
    NSUInteger request = [r peekUInt16:&eof];
    if (eof) { code = INVAR_ERR_DECODE_EOF; goto error; }
    switch (request) {
     case 65528: /* 客户端请求,服务端响应 */ {
        id rep = [[TestUserLoginR2C alloc] init];
        if (INVAR_ERR_NONE == (code = [rep read:r])) { HandleTestUserLoginR2C(rep); }
        break; }
     case 65530: /* 服务器通知客户端 */ {
        id ntf = [[TestServerTimeN2C alloc] init];
        if (INVAR_ERR_NONE == (code = [ntf read:r])) { HandleTestServerTimeN2C(ntf); }
        break; }
     case 65534: /* 服务端请求,客户端响应 */ {
        id req = [[TestHeartBeat2C alloc] init]; resp = [[TestHeartBeatR2S alloc] init];
        if (INVAR_ERR_NONE == (code = [req read:r])) { HandleTestHeartBeat2C(req, resp); }
        break; }
     default: { code = INVAR_ERR_PROTOC_NO_HANDLER; break; }
    }
error:
    if (INVAR_ERR_NONE != code && [[[self class] shared] blockHandleError]) {
        [[[self class] shared] blockHandleError](code, request);
    }
    if (resp) {
        [resp setProtocError:code];
    }
    *p = request;
    *e = code;
    return resp;
}
/* HandleProtocAsClient */

@end

