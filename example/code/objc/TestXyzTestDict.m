//*==---------------------------*  Obj-C  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------==*//
///*
#if ! __has_feature(objc_arc)
#error This file must be compiled with ARC. Either turn on ARC for the project or use -fobjc-arc flag
#endif //*/

#import "TestXyzTestDict.h"

#define CRC32 0x969046DE

@interface TestDict ()
{
    NSMutableDictionary * _dictI08    ; /* 0 map<int8,int8> */
    NSMutableDictionary * _dictI16    ; /* 1 map<int16,int16> */
    NSMutableDictionary * _dictI32    ; /* 2 map<int32,int32> */
    NSMutableDictionary * _dictI64    ; /* 3 map<int64,int64> */
    NSMutableDictionary * _dictU08    ; /* 4 map<uint8,uint8> */
    NSMutableDictionary * _dictU16    ; /* 5 map<uint16,uint16> */
    NSMutableDictionary * _dictU32    ; /* 6 map<uint32,uint32> */
    NSMutableDictionary * _dictU64    ; /* 7 map<uint64,uint64> */
    NSMutableDictionary * _dictSingle ; /* 8 map<float,float> */
    NSMutableDictionary * _dictDouble ; /* 9 map<double,double> */
    NSMutableDictionary * _dictBoolean; /* 10 map<bool,bool> */
    NSMutableDictionary * _dictString ; /* 11 map<string,string> */
    NSMutableDictionary * _dictEnum   ; /* 12 map<Test.Abc.Gender,Test.Abc.Gender> */
    NSMutableDictionary * _dictStruct ; /* 13 map<Test.Abc.Custom,Test.Abc.Custom> */
    NSMutableDictionary * _hotfix     ; /* 14 map<string,string> */
}
@end

@implementation TestDict

- (instancetype) init
{
    self = [super init];
    if (!self) { return self; }
    _dictI08     = [[NSMutableDictionary alloc] init];
    _dictI16     = [[NSMutableDictionary alloc] init];
    _dictI32     = [[NSMutableDictionary alloc] init];
    _dictI64     = [[NSMutableDictionary alloc] init];
    _dictU08     = [[NSMutableDictionary alloc] init];
    _dictU16     = [[NSMutableDictionary alloc] init];
    _dictU32     = [[NSMutableDictionary alloc] init];
    _dictU64     = [[NSMutableDictionary alloc] init];
    _dictSingle  = [[NSMutableDictionary alloc] init];
    _dictDouble  = [[NSMutableDictionary alloc] init];
    _dictBoolean = [[NSMutableDictionary alloc] init];
    _dictString  = [[NSMutableDictionary alloc] init];
    _dictEnum    = [[NSMutableDictionary alloc] init];
    _dictStruct  = [[NSMutableDictionary alloc] init];
    _hotfix      = nil;
    return self;
}
/* TestDict::init */

- (void) dealloc
{
    if (_dictI08    ) { _dictI08     = nil; }
    if (_dictI16    ) { _dictI16     = nil; }
    if (_dictI32    ) { _dictI32     = nil; }
    if (_dictI64    ) { _dictI64     = nil; }
    if (_dictU08    ) { _dictU08     = nil; }
    if (_dictU16    ) { _dictU16     = nil; }
    if (_dictU32    ) { _dictU32     = nil; }
    if (_dictU64    ) { _dictU64     = nil; }
    if (_dictSingle ) { _dictSingle  = nil; }
    if (_dictDouble ) { _dictDouble  = nil; }
    if (_dictBoolean) { _dictBoolean = nil; }
    if (_dictString ) { _dictString  = nil; }
    if (_dictEnum   ) { _dictEnum    = nil; }
    if (_dictStruct ) { _dictStruct  = nil; }
    if (_hotfix     ) { _hotfix      = nil; }
}
/* TestDict::dealloc */

- (id) copyWithZone:(nullable NSZone *)zone;
{
    id copy = [[[self class] allocWithZone:zone] init];
    DataWriter *writer = [DataWriter Create];
    [self write:writer];
    [copy read:[DataReader CreateWithData:writer.data]];
    return copy;
}
/* TestDict::copyWithZone */

- (NSMutableDictionary *) dictI08     { return _dictI08    ; }
- (NSMutableDictionary *) dictI16     { return _dictI16    ; }
- (NSMutableDictionary *) dictI32     { return _dictI32    ; }
- (NSMutableDictionary *) dictI64     { return _dictI64    ; }
- (NSMutableDictionary *) dictU08     { return _dictU08    ; }
- (NSMutableDictionary *) dictU16     { return _dictU16    ; }
- (NSMutableDictionary *) dictU32     { return _dictU32    ; }
- (NSMutableDictionary *) dictU64     { return _dictU64    ; }
- (NSMutableDictionary *) dictSingle  { return _dictSingle ; }
- (NSMutableDictionary *) dictDouble  { return _dictDouble ; }
- (NSMutableDictionary *) dictBoolean { return _dictBoolean; }
- (NSMutableDictionary *) dictString  { return _dictString ; }
- (NSMutableDictionary *) dictEnum    { return _dictEnum   ; }
- (NSMutableDictionary *) dictStruct  { return _dictStruct ; }
- (NSMutableDictionary *) hotfix      { return _hotfix     ; }

- (TestDict *) setHotfix      : (NSMutableDictionary *)v { _hotfix      = v; return self; }

- (NSInteger)read:(const DataReader * const)r
{
    BOOL eof = false;
    uint32_t lenDictI08 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictI08 = 0; iDictI08 < lenDictI08; iDictI08++) {
        NSNumber *k1 = @([r readInt8:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readInt8:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictI08 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictI16 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictI16 = 0; iDictI16 < lenDictI16; iDictI16++) {
        NSNumber *k1 = @([r readInt16:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readInt16:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictI16 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictI32 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictI32 = 0; iDictI32 < lenDictI32; iDictI32++) {
        NSNumber *k1 = @([r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictI32 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictI64 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictI64 = 0; iDictI64 < lenDictI64; iDictI64++) {
        NSNumber *k1 = @([r readInt64:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readInt64:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictI64 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictU08 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictU08 = 0; iDictU08 < lenDictU08; iDictU08++) {
        NSNumber *k1 = @([r readUInt8:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readUInt8:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictU08 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictU16 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictU16 = 0; iDictU16 < lenDictU16; iDictU16++) {
        NSNumber *k1 = @([r readUInt16:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readUInt16:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictU16 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictU32 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictU32 = 0; iDictU32 < lenDictU32; iDictU32++) {
        NSNumber *k1 = @([r readUInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readUInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictU32 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictU64 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictU64 = 0; iDictU64 < lenDictU64; iDictU64++) {
        NSNumber *k1 = @([r readUInt64:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readUInt64:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictU64 setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictSingle = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictSingle = 0; iDictSingle < lenDictSingle; iDictSingle++) {
        NSNumber *k1 = @([r readFloat:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readFloat:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictSingle setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictDouble = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictDouble = 0; iDictDouble < lenDictDouble; iDictDouble++) {
        NSNumber *k1 = @([r readDouble:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSNumber *v1 = @([r readDouble:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictDouble setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictBoolean = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictBoolean = 0; iDictBoolean < lenDictBoolean; iDictBoolean++) {
        id k1 = @([r readBool:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        id v1 = @([r readBool:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictBoolean setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictString = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictString = 0; iDictString < lenDictString; iDictString++) {
        NSString *k1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSString *v1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictString setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictEnum = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictEnum = 0; iDictEnum < lenDictEnum; iDictEnum++) {
        id k1 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        id v1 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictEnum setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenDictStruct = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iDictStruct = 0; iDictStruct < lenDictStruct; iDictStruct++) {
        Custom *k1 = [[Custom alloc] init];
        NSInteger k1Err = [k1 read:r]; if (k1Err != 0) { return k1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        Custom *v1 = [[Custom alloc] init];
        NSInteger v1Err = [v1 read:r]; if (v1Err != 0) { return v1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_dictStruct setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    int8_t hotfixExists = [r readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if (0x01 == hotfixExists) {
        if (_hotfix == nil) { _hotfix = [[NSMutableDictionary alloc] init]; }
        uint32_t lenHotfix = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iHotfix = 0; iHotfix < lenHotfix; iHotfix++) {
            NSString *k1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            NSString *v1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            [_hotfix setObject:v1 forKey:k1];
        }
    }
    else if (0x00 == hotfixExists) { _hotfix = nil; }
    else { return INVAR_ERR_DECODE_VEC_MAP_P; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    return INVAR_ERR_NONE;
}
/* TestDict::read(...) */

- (NSInteger)write:(DataWriter *)w
{
    [w writeUInt32:(uint32_t)[_dictI08 count]];
    for (id k1 in _dictI08) {
        [w writeInt8:[k1 charValue]];
        int8_t v1 = [[_dictI08 objectForKey:k1] charValue]; [w writeInt8:v1];
    }
    [w writeUInt32:(uint32_t)[_dictI16 count]];
    for (id k1 in _dictI16) {
        [w writeInt16:[k1 shortValue]];
        int16_t v1 = [[_dictI16 objectForKey:k1] shortValue]; [w writeInt16:v1];
    }
    [w writeUInt32:(uint32_t)[_dictI32 count]];
    for (id k1 in _dictI32) {
        [w writeInt32:[k1 intValue]];
        int32_t v1 = [[_dictI32 objectForKey:k1] intValue]; [w writeInt32:v1];
    }
    [w writeUInt32:(uint32_t)[_dictI64 count]];
    for (id k1 in _dictI64) {
        [w writeInt64:[k1 longValue]];
        int64_t v1 = [[_dictI64 objectForKey:k1] longValue]; [w writeInt64:v1];
    }
    [w writeUInt32:(uint32_t)[_dictU08 count]];
    for (id k1 in _dictU08) {
        [w writeUInt8:[k1 unsignedCharValue]];
        uint8_t v1 = [[_dictU08 objectForKey:k1] unsignedCharValue]; [w writeUInt8:v1];
    }
    [w writeUInt32:(uint32_t)[_dictU16 count]];
    for (id k1 in _dictU16) {
        [w writeUInt16:[k1 unsignedShortValue]];
        uint16_t v1 = [[_dictU16 objectForKey:k1] unsignedShortValue]; [w writeUInt16:v1];
    }
    [w writeUInt32:(uint32_t)[_dictU32 count]];
    for (id k1 in _dictU32) {
        [w writeUInt32:[k1 unsignedIntValue]];
        uint32_t v1 = [[_dictU32 objectForKey:k1] unsignedIntValue]; [w writeUInt32:v1];
    }
    [w writeUInt32:(uint32_t)[_dictU64 count]];
    for (id k1 in _dictU64) {
        [w writeUInt64:[k1 unsignedLongValue]];
        uint64_t v1 = [[_dictU64 objectForKey:k1] unsignedLongValue]; [w writeUInt64:v1];
    }
    [w writeUInt32:(uint32_t)[_dictSingle count]];
    for (id k1 in _dictSingle) {
        [w writeFloat:[k1 floatValue]];
        float_t v1 = [[_dictSingle objectForKey:k1] floatValue]; [w writeFloat:v1];
    }
    [w writeUInt32:(uint32_t)[_dictDouble count]];
    for (id k1 in _dictDouble) {
        [w writeDouble:[k1 doubleValue]];
        double_t v1 = [[_dictDouble objectForKey:k1] doubleValue]; [w writeDouble:v1];
    }
    [w writeUInt32:(uint32_t)[_dictBoolean count]];
    for (id k1 in _dictBoolean) {
        [w writeUInt8:[k1 unsignedCharValue]];
        boolean_t v1 = [[_dictBoolean objectForKey:k1] unsignedCharValue]; [w writeBool:v1];
    }
    [w writeUInt32:(uint32_t)[_dictString count]];
    for (id k1 in _dictString) {
        [w writeString:k1];
        NSString *v1 = [_dictString objectForKey:k1];
        [w writeString:v1];
    }
    [w writeUInt32:(uint32_t)[_dictEnum count]];
    for (id k1 in _dictEnum) {
        [w writeInt32:[k1 intValue]];
        Gender v1 = [[_dictEnum objectForKey:k1] intValue]; [w writeInt32:v1];
    }
    [w writeUInt32:(uint32_t)[_dictStruct count]];
    for (id k1 in _dictStruct) {
        [k1 write:w];
        Custom *v1 = [_dictStruct objectForKey:k1];
        [v1 write:w];
    }
    if (_hotfix != nil) {
        [w writeInt8:0x01];
        [w writeUInt32:(uint32_t)[_hotfix count]];
        for (id k1 in _hotfix) {
            [w writeString:k1];
            NSString *v1 = [_hotfix objectForKey:k1];
            [w writeString:v1];
        }
    } else {
        [w writeInt8:0x00];
    }
    return 0;
}
/* TestDict::write */

- (NSString *)toStringJSON;
{
    NSMutableString *s = [[NSMutableString alloc] init] ;
    [self writeJSON:s];
    return s;
}

- (void)writeJSON:(NSMutableString *)s
{
    [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
    NSString *comma = nil;
    BOOL dictI08Exists = (nil != _dictI08 && [_dictI08 count] > 0);
    if (dictI08Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictI08"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictI08Size = (nil == _dictI08 ? 0 : [_dictI08 count]);
        if (dictI08Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictI08Idx = 0;
            for (id k1 in _dictI08) { /* map.for: _dictI08 */
                ++dictI08Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictI08 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictI08Idx != dictI08Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictI16Exists = (nil != _dictI16 && [_dictI16 count] > 0);
    if (comma && dictI16Exists) { [s appendString:comma]; comma = nil; }
    if (dictI16Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictI16"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictI16Size = (nil == _dictI16 ? 0 : [_dictI16 count]);
        if (dictI16Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictI16Idx = 0;
            for (id k1 in _dictI16) { /* map.for: _dictI16 */
                ++dictI16Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictI16 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictI16Idx != dictI16Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictI32Exists = (nil != _dictI32 && [_dictI32 count] > 0);
    if (comma && dictI32Exists) { [s appendString:comma]; comma = nil; }
    if (dictI32Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictI32"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictI32Size = (nil == _dictI32 ? 0 : [_dictI32 count]);
        if (dictI32Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictI32Idx = 0;
            for (id k1 in _dictI32) { /* map.for: _dictI32 */
                ++dictI32Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictI32 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictI32Idx != dictI32Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictI64Exists = (nil != _dictI64 && [_dictI64 count] > 0);
    if (comma && dictI64Exists) { [s appendString:comma]; comma = nil; }
    if (dictI64Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictI64"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictI64Size = (nil == _dictI64 ? 0 : [_dictI64 count]);
        if (dictI64Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictI64Idx = 0;
            for (id k1 in _dictI64) { /* map.for: _dictI64 */
                ++dictI64Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictI64 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictI64Idx != dictI64Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictU08Exists = (nil != _dictU08 && [_dictU08 count] > 0);
    if (comma && dictU08Exists) { [s appendString:comma]; comma = nil; }
    if (dictU08Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictU08"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictU08Size = (nil == _dictU08 ? 0 : [_dictU08 count]);
        if (dictU08Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictU08Idx = 0;
            for (id k1 in _dictU08) { /* map.for: _dictU08 */
                ++dictU08Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictU08 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictU08Idx != dictU08Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictU16Exists = (nil != _dictU16 && [_dictU16 count] > 0);
    if (comma && dictU16Exists) { [s appendString:comma]; comma = nil; }
    if (dictU16Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictU16"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictU16Size = (nil == _dictU16 ? 0 : [_dictU16 count]);
        if (dictU16Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictU16Idx = 0;
            for (id k1 in _dictU16) { /* map.for: _dictU16 */
                ++dictU16Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictU16 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictU16Idx != dictU16Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictU32Exists = (nil != _dictU32 && [_dictU32 count] > 0);
    if (comma && dictU32Exists) { [s appendString:comma]; comma = nil; }
    if (dictU32Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictU32"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictU32Size = (nil == _dictU32 ? 0 : [_dictU32 count]);
        if (dictU32Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictU32Idx = 0;
            for (id k1 in _dictU32) { /* map.for: _dictU32 */
                ++dictU32Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictU32 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictU32Idx != dictU32Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictU64Exists = (nil != _dictU64 && [_dictU64 count] > 0);
    if (comma && dictU64Exists) { [s appendString:comma]; comma = nil; }
    if (dictU64Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictU64"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictU64Size = (nil == _dictU64 ? 0 : [_dictU64 count]);
        if (dictU64Size > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictU64Idx = 0;
            for (id k1 in _dictU64) { /* map.for: _dictU64 */
                ++dictU64Idx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictU64 objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictU64Idx != dictU64Size) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictSingleExists = (nil != _dictSingle && [_dictSingle count] > 0);
    if (comma && dictSingleExists) { [s appendString:comma]; comma = nil; }
    if (dictSingleExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictSingle"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictSingleSize = (nil == _dictSingle ? 0 : [_dictSingle count]);
        if (dictSingleSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictSingleIdx = 0;
            for (id k1 in _dictSingle) { /* map.for: _dictSingle */
                ++dictSingleIdx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictSingle objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictSingleIdx != dictSingleSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictDoubleExists = (nil != _dictDouble && [_dictDouble count] > 0);
    if (comma && dictDoubleExists) { [s appendString:comma]; comma = nil; }
    if (dictDoubleExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictDouble"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictDoubleSize = (nil == _dictDouble ? 0 : [_dictDouble count]);
        if (dictDoubleSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictDoubleIdx = 0;
            for (id k1 in _dictDouble) { /* map.for: _dictDouble */
                ++dictDoubleIdx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictDouble objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictDoubleIdx != dictDoubleSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictBooleanExists = (nil != _dictBoolean && [_dictBoolean count] > 0);
    if (comma && dictBooleanExists) { [s appendString:comma]; comma = nil; }
    if (dictBooleanExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictBoolean"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictBooleanSize = (nil == _dictBoolean ? 0 : [_dictBoolean count]);
        if (dictBooleanSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictBooleanIdx = 0;
            for (id k1 in _dictBoolean) { /* map.for: _dictBoolean */
                ++dictBooleanIdx;
                [s appendString:QUOTATION_S]; [s appendString:k1 ? @"true" : @"false"];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictBoolean objectForKey:k1];
                [s appendString:v1 ? @"true" : @"false"]; /* nest.v */
                if (dictBooleanIdx != dictBooleanSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictStringExists = (nil != _dictString && [_dictString count] > 0);
    if (comma && dictStringExists) { [s appendString:comma]; comma = nil; }
    if (dictStringExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictString"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictStringSize = (nil == _dictString ? 0 : [_dictString count]);
        if (dictStringSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictStringIdx = 0;
            for (id k1 in _dictString) { /* map.for: _dictString */
                ++dictStringIdx;
                [s appendString:QUOTATION_S]; [s appendString:k1]; [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k.string */
                id v1 = [_dictString objectForKey:k1];
                [s appendString:QUOTATION_S]; [s appendString:v1]; [s appendString:QUOTATION_S]; /* nest.v */
                if (dictStringIdx != dictStringSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictEnumExists = (nil != _dictEnum && [_dictEnum count] > 0);
    if (comma && dictEnumExists) { [s appendString:comma]; comma = nil; }
    if (dictEnumExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictEnum"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictEnumSize = (nil == _dictEnum ? 0 : [_dictEnum count]);
        if (dictEnumSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictEnumIdx = 0;
            for (id k1 in _dictEnum) { /* map.for: _dictEnum */
                ++dictEnumIdx;
                [s appendString:QUOTATION_S]; [s appendFormat:FORMAT_S, k1];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictEnum objectForKey:k1];
                [s appendFormat:FORMAT_S, v1]; /* nest.v */
                if (dictEnumIdx != dictEnumSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL dictStructExists = (nil != _dictStruct && [_dictStruct count] > 0);
    if (comma && dictStructExists) { [s appendString:comma]; comma = nil; }
    if (dictStructExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"dictStruct"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger dictStructSize = (nil == _dictStruct ? 0 : [_dictStruct count]);
        if (dictStructSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int dictStructIdx = 0;
            for (id k1 in _dictStruct) { /* map.for: _dictStruct */
                ++dictStructIdx;
                [s appendString:QUOTATION_S]; [k1 writeJSON:s];
                [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k */
                id v1 = [_dictStruct objectForKey:k1];
                [v1 writeJSON:s]; /* nest.v */
                if (dictStructIdx != dictStructSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    BOOL hotfixExists = (nil != _hotfix && [_hotfix count] > 0);
    if (comma && hotfixExists) { [s appendString:comma]; comma = nil; }
    if (hotfixExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"hotfix"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger hotfixSize = (nil == _hotfix ? 0 : [_hotfix count]);
        if (hotfixSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
            int hotfixIdx = 0;
            for (id k1 in _hotfix) { /* map.for: _hotfix */
                ++hotfixIdx;
                [s appendString:QUOTATION_S]; [s appendString:k1]; [s appendString:QUOTATION_S]; [s appendString:COLON_S]; /* nest.k.string */
                id v1 = [_hotfix objectForKey:k1];
                [s appendString:QUOTATION_S]; [s appendString:v1]; [s appendString:QUOTATION_S]; /* nest.v */
                if (hotfixIdx != hotfixSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_CURLY_S];
        } comma = COMMA_S;
    }
    [s appendString:RIGHT_CURLY_S]; [s appendString:LINE_FEED_S];
}
/* TestDict::writeJSON */

@end /* @implementation TestDict */
/*
1@test.xyz.TestDict/map-int8-int8/map-int16-int16/map-int32-int32/map-int64-int64/map-uint8-uint8/ma
  p-uint16-uint16/map-uint32-uint32/map-uint64-uint64/map-float-float/map-double-double/map-bool-boo
  l/map-string-string/map-int32-int32/map-test.abc.Custom-test.abc.Custom/map-string-string
+@test.abc.Custom/int32/test.abc.TestBasic/test.xyz.Conflict/test.abc.Conflict/vec-test.abc.Custom/i
  nt32/string/string/test.abc.Custom/test.abc.Custom/string
*/

