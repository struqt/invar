//*==---------------------------*  Obj-C  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------==*//
///*
#if ! __has_feature(objc_arc)
#error This file must be compiled with ARC. Either turn on ARC for the project or use -fobjc-arc flag
#endif //*/

#import "test_xyz_InfoX.h"

#define CRC32 0x8E63A1C8

@interface InfoX ()
{
    NSMutableArray      * _infos     ; /* 0 vec<vec<vec<vec<vec<test.abc.Info>>>>> */
    test_xyz_Conflict   * _conflict_x; /* 1 test.xyz.Conflict */
    Conflict            * _conflict_a; /* 2 test.abc.Conflict */
    NSMutableDictionary * _mConflict ; /* 3 map<int32,test.abc.Conflict> */
    NSMutableArray      * _info2d    ; /* 4 vec<vec<test.abc.Info>> */
    NSMutableArray      * _info3d    ; /* 5 vec<vec<vec<test.abc.Info>>> */
    NSMutableArray      * _info5d    ; /* 6 vec<vec<vec<vec<vec<test.abc.Info>>>>> */
    NSMutableArray      * _infovm    ; /* 7 vec<map<int16,test.abc.Info>> */
    NSMutableDictionary * _mvei      ; /* 8 map<vec<test.abc.Gender>,test.abc.Info> */
    NSMutableDictionary * _mive      ; /* 9 map<test.abc.Info,vec<test.abc.Gender>> */
    NSMutableDictionary * _mvive     ; /* 10 map<vec<test.abc.Info>,vec<test.abc.Gender>> */
    NSMutableArray      * _vmvive    ; /* 11 vec<map<vec<test.abc.Info>,vec<test.abc.Gender>>> */
    NSMutableDictionary * _hotfix    ; /* 12 map<string,string> */
}
@end

@implementation InfoX

- (instancetype) init
{
    self = [super init];
    if (!self) { return self; }
    _infos      = [[NSMutableArray alloc] init];
    _conflict_x = [[test_xyz_Conflict alloc] init];
    _conflict_a = [[Conflict alloc] init];
    _mConflict  = [[NSMutableDictionary alloc] init];
    _info2d     = [[NSMutableArray alloc] init];
    _info3d     = [[NSMutableArray alloc] init];
    _info5d     = [[NSMutableArray alloc] init];
    _infovm     = [[NSMutableArray alloc] init];
    _mvei       = [[NSMutableDictionary alloc] init];
    _mive       = [[NSMutableDictionary alloc] init];
    _mvive      = [[NSMutableDictionary alloc] init];
    _vmvive     = [[NSMutableArray alloc] init];
    _hotfix     = nil;
    return self;
}
/* InfoX::init */

- (void) dealloc
{
    if (_infos     ) { _infos      = nil; }
    if (_conflict_x) { _conflict_x = nil; }
    if (_conflict_a) { _conflict_a = nil; }
    if (_mConflict ) { _mConflict  = nil; }
    if (_info2d    ) { _info2d     = nil; }
    if (_info3d    ) { _info3d     = nil; }
    if (_info5d    ) { _info5d     = nil; }
    if (_infovm    ) { _infovm     = nil; }
    if (_mvei      ) { _mvei       = nil; }
    if (_mive      ) { _mive       = nil; }
    if (_mvive     ) { _mvive      = nil; }
    if (_vmvive    ) { _vmvive     = nil; }
    if (_hotfix    ) { _hotfix     = nil; }
}
/* InfoX::dealloc */

- (id) copyWithZone:(nullable NSZone *)zone;
{
    id copy = [[[self class] allocWithZone:zone] init];
    DataWriter *writer = [DataWriter Create];
    [self write:writer];
    [copy read:[DataReader CreateWithData:writer.data]];
    return copy;
}
/* InfoX::copyWithZone */

- (NSMutableArray      *) infos      { return _infos     ; }
- (test_xyz_Conflict   *) conflict_x { return _conflict_x; }
- (Conflict            *) conflict_a { return _conflict_a; }
- (NSMutableDictionary *) mConflict  { return _mConflict ; }
- (NSMutableArray      *) info2d     { return _info2d    ; }
- (NSMutableArray      *) info3d     { return _info3d    ; }
- (NSMutableArray      *) info5d     { return _info5d    ; }
- (NSMutableArray      *) infovm     { return _infovm    ; }
- (NSMutableDictionary *) mvei       { return _mvei      ; }
- (NSMutableDictionary *) mive       { return _mive      ; }
- (NSMutableDictionary *) mvive      { return _mvive     ; }
- (NSMutableArray      *) vmvive     { return _vmvive    ; }
- (NSMutableDictionary *) hotfix     { return _hotfix    ; }

- (InfoX *) setConflict_x : (test_xyz_Conflict   *)v { _conflict_x = v; return self; }
- (InfoX *) setConflict_a : (Conflict            *)v { _conflict_a = v; return self; }
- (InfoX *) setHotfix     : (NSMutableDictionary *)v { _hotfix     = v; return self; }

- (NSInteger)read:(DataReader *)r
{
    BOOL eof = false;
    uint32_t lenInfos = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iInfos = 0; iInfos < lenInfos; iInfos++) {
        NSMutableArray *n1 = [[NSMutableArray alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            NSMutableArray *n2 = [[NSMutableArray alloc] init]; //read.vec.head
            uint32_t lenN2 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            for (uint32_t iN2 = 0; iN2 < lenN2; iN2++) {
                NSMutableArray *n3 = [[NSMutableArray alloc] init]; //read.vec.head
                uint32_t lenN3 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
                for (uint32_t iN3 = 0; iN3 < lenN3; iN3++) {
                    NSMutableArray *n4 = [[NSMutableArray alloc] init]; //read.vec.head
                    uint32_t lenN4 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
                    for (uint32_t iN4 = 0; iN4 < lenN4; iN4++) {
                        Info *n5 = [[Info alloc] init];
                        NSInteger n5Err = [n5 read:r]; if (n5Err != 0) { return n5Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
                        [n4 addObject:n5];
                    }
                    [n3 addObject:n4];
                }
                [n2 addObject:n3];
            }
            [n1 addObject:n2];
        }
        [_infos addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    NSInteger conflict_xErr = [_conflict_x read:r]; if (conflict_xErr != 0) { return conflict_xErr; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    NSInteger conflict_aErr = [_conflict_a read:r]; if (conflict_aErr != 0) { return conflict_aErr; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenMConflict = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iMConflict = 0; iMConflict < lenMConflict; iMConflict++) {
        NSNumber *k1 = @([r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
        Conflict *v1 = [[Conflict alloc] init];
        NSInteger v1Err = [v1 read:r]; if (v1Err != 0) { return v1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_mConflict setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenInfo2d = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iInfo2d = 0; iInfo2d < lenInfo2d; iInfo2d++) {
        NSMutableArray *n1 = [[NSMutableArray alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            Info *n2 = [[Info alloc] init];
            NSInteger n2Err = [n2 read:r]; if (n2Err != 0) { return n2Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
            [n1 addObject:n2];
        }
        [_info2d addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenInfo3d = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iInfo3d = 0; iInfo3d < lenInfo3d; iInfo3d++) {
        NSMutableArray *n1 = [[NSMutableArray alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            NSMutableArray *n2 = [[NSMutableArray alloc] init]; //read.vec.head
            uint32_t lenN2 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            for (uint32_t iN2 = 0; iN2 < lenN2; iN2++) {
                Info *n3 = [[Info alloc] init];
                NSInteger n3Err = [n3 read:r]; if (n3Err != 0) { return n3Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
                [n2 addObject:n3];
            }
            [n1 addObject:n2];
        }
        [_info3d addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenInfo5d = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iInfo5d = 0; iInfo5d < lenInfo5d; iInfo5d++) {
        NSMutableArray *n1 = [[NSMutableArray alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            NSMutableArray *n2 = [[NSMutableArray alloc] init]; //read.vec.head
            uint32_t lenN2 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            for (uint32_t iN2 = 0; iN2 < lenN2; iN2++) {
                NSMutableArray *n3 = [[NSMutableArray alloc] init]; //read.vec.head
                uint32_t lenN3 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
                for (uint32_t iN3 = 0; iN3 < lenN3; iN3++) {
                    NSMutableArray *n4 = [[NSMutableArray alloc] init]; //read.vec.head
                    uint32_t lenN4 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
                    for (uint32_t iN4 = 0; iN4 < lenN4; iN4++) {
                        Info *n5 = [[Info alloc] init];
                        NSInteger n5Err = [n5 read:r]; if (n5Err != 0) { return n5Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
                        [n4 addObject:n5];
                    }
                    [n3 addObject:n4];
                }
                [n2 addObject:n3];
            }
            [n1 addObject:n2];
        }
        [_info5d addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenInfovm = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iInfovm = 0; iInfovm < lenInfovm; iInfovm++) {
        NSMutableDictionary *n1 = [[NSMutableDictionary alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            NSNumber *k2 = @([r readInt16:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
            Info *v2 = [[Info alloc] init];
            NSInteger v2Err = [v2 read:r]; if (v2Err != 0) { return v2Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
            [n1 setObject:v2 forKey:k2];
        }
        [_infovm addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenMvei = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iMvei = 0; iMvei < lenMvei; iMvei++) {
        NSMutableArray *k1 = [[NSMutableArray alloc] init]; //read.map.head
        uint32_t lenK1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iK1 = 0; iK1 < lenK1; iK1++) {
            id n2 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
            [k1 addObject:n2];
        }
        Info *v1 = [[Info alloc] init];
        NSInteger v1Err = [v1 read:r]; if (v1Err != 0) { return v1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_mvei setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenMive = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iMive = 0; iMive < lenMive; iMive++) {
        Info *k1 = [[Info alloc] init];
        NSInteger k1Err = [k1 read:r]; if (k1Err != 0) { return k1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        NSMutableArray *v1 = [[NSMutableArray alloc] init]; //read.map.head
        uint32_t lenV1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iV1 = 0; iV1 < lenV1; iV1++) {
            id n2 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
            [v1 addObject:n2];
        }
        [_mive setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenMvive = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iMvive = 0; iMvive < lenMvive; iMvive++) {
        NSMutableArray *k1 = [[NSMutableArray alloc] init]; //read.map.head
        uint32_t lenK1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iK1 = 0; iK1 < lenK1; iK1++) {
            Info *n2 = [[Info alloc] init];
            NSInteger n2Err = [n2 read:r]; if (n2Err != 0) { return n2Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
            [k1 addObject:n2];
        }
        NSMutableArray *v1 = [[NSMutableArray alloc] init]; //read.map.head
        uint32_t lenV1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iV1 = 0; iV1 < lenV1; iV1++) {
            id n2 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
            [v1 addObject:n2];
        }
        [_mvive setObject:v1 forKey:k1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenVmvive = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iVmvive = 0; iVmvive < lenVmvive; iVmvive++) {
        NSMutableDictionary *n1 = [[NSMutableDictionary alloc] init]; //read.vec.head
        uint32_t lenN1 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iN1 = 0; iN1 < lenN1; iN1++) {
            NSMutableArray *k2 = [[NSMutableArray alloc] init]; //read.map.head
            uint32_t lenK2 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            for (uint32_t iK2 = 0; iK2 < lenK2; iK2++) {
                Info *n3 = [[Info alloc] init];
                NSInteger n3Err = [n3 read:r]; if (n3Err != 0) { return n3Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
                [k2 addObject:n3];
            }
            NSMutableArray *v2 = [[NSMutableArray alloc] init]; //read.map.head
            uint32_t lenV2 = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            for (uint32_t iV2 = 0; iV2 < lenV2; iV2++) {
                id n3 = @((Gender)[r readInt32:&eof]); if (eof) { return INVAR_ERR_DECODE_EOF; }
                [v2 addObject:n3];
            }
            [n1 setObject:v2 forKey:k2];
        }
        [_vmvive addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    int8_t hotfixExists = [r readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if (0x01 == hotfixExists) {
        if (_hotfix == nil) { _hotfix = [[NSMutableDictionary alloc] init]; }
        uint32_t lenHotfix = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
        for (uint32_t iHotfix = 0; iHotfix < lenHotfix; iHotfix++) {
            NSString *k1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            NSString *v1 = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
            [_hotfix setObject:v1 forKey:k1];
        }
    }
    else if (0x00 == hotfixExists) { _hotfix = nil; }
    else { return INVAR_ERR_DECODE_VEC_MAP_P; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    return INVAR_ERR_NONE;
}
/* InfoX::read(...) */

- (NSInteger)write:(DataWriter *)w
{
    [w writeUInt32:(uint32_t)[_infos count]];
    for (id n1 in _infos) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id n2 in n1) {
            [w writeUInt32:(uint32_t)[n2 count]];
            for (id n3 in n2) {
                [w writeUInt32:(uint32_t)[n3 count]];
                for (id n4 in n3) {
                    [w writeUInt32:(uint32_t)[n4 count]];
                    for (id n5 in n4) {
                        [n5 write:w];
                    }
                }
            }
        }
    }
    [_conflict_x write:w];
    [_conflict_a write:w];
    [w writeUInt32:(uint32_t)[_mConflict count]];
    for (id k1 in _mConflict) {
        [w writeInt32:[k1 intValue]];
        Conflict *v1 = [_mConflict objectForKey:k1];
        [v1 write:w];
    }
    [w writeUInt32:(uint32_t)[_info2d count]];
    for (id n1 in _info2d) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id n2 in n1) {
            [n2 write:w];
        }
    }
    [w writeUInt32:(uint32_t)[_info3d count]];
    for (id n1 in _info3d) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id n2 in n1) {
            [w writeUInt32:(uint32_t)[n2 count]];
            for (id n3 in n2) {
                [n3 write:w];
            }
        }
    }
    [w writeUInt32:(uint32_t)[_info5d count]];
    for (id n1 in _info5d) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id n2 in n1) {
            [w writeUInt32:(uint32_t)[n2 count]];
            for (id n3 in n2) {
                [w writeUInt32:(uint32_t)[n3 count]];
                for (id n4 in n3) {
                    [w writeUInt32:(uint32_t)[n4 count]];
                    for (id n5 in n4) {
                        [n5 write:w];
                    }
                }
            }
        }
    }
    [w writeUInt32:(uint32_t)[_infovm count]];
    for (id n1 in _infovm) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id k2 in n1) {
            [w writeInt16:[k2 shortValue]];
            Info *v2 = [n1 objectForKey:k2];
            [v2 write:w];
        }
    }
    [w writeUInt32:(uint32_t)[_mvei count]];
    for (id k1 in _mvei) {
        [w writeUInt32:(uint32_t)[k1 count]];
        for (id n2 in k1) {
            [w writeInt32:[n2 intValue]];
        }
        Info *v1 = [_mvei objectForKey:k1];
        [v1 write:w];
    }
    [w writeUInt32:(uint32_t)[_mive count]];
    for (id k1 in _mive) {
        [k1 write:w];
        NSMutableArray *v1 = [_mive objectForKey:k1];/*write.map.head.v*/
        [w writeUInt32:(uint32_t)[v1 count]];
        for (id n2 in v1) {
            [w writeInt32:[n2 intValue]];
        }
    }
    [w writeUInt32:(uint32_t)[_mvive count]];
    for (id k1 in _mvive) {
        [w writeUInt32:(uint32_t)[k1 count]];
        for (id n2 in k1) {
            [n2 write:w];
        }
        NSMutableArray *v1 = [_mvive objectForKey:k1];/*write.map.head.v*/
        [w writeUInt32:(uint32_t)[v1 count]];
        for (id n2 in v1) {
            [w writeInt32:[n2 intValue]];
        }
    }
    [w writeUInt32:(uint32_t)[_vmvive count]];
    for (id n1 in _vmvive) {
        [w writeUInt32:(uint32_t)[n1 count]];
        for (id k2 in n1) {
            [w writeUInt32:(uint32_t)[k2 count]];
            for (id n3 in k2) {
                [n3 write:w];
            }
            NSMutableArray *v2 = [n1 objectForKey:k2];/*write.map.head.v*/
            [w writeUInt32:(uint32_t)[v2 count]];
            for (id n3 in v2) {
                [w writeInt32:[n3 intValue]];
            }
        }
    }
    if (_hotfix != nil) {
        [w writeInt8:0x01];
        [w writeUInt32:(uint32_t)[_hotfix count]];
        for (id k1 in _hotfix) {
            [w writeString:k1];
            NSString *v1 = [_hotfix objectForKey:k1];
            [w writeString:v1];
        }
    } else {
        [w writeInt8:0x00];
    }
    return 0;
}
/* InfoX::write */

- (NSString *)toStringJSON;
{
    NSMutableString *s = [[NSMutableString alloc] init] ;
    [self writeJSON:s];
    return s;
}

- (void)writeJSON:(NSMutableString *)s
{
    [s appendString:@"\n"]; [s appendString:@"{"];
    NSString *comma = nil;
    BOOL infosExists = (nil != _infos && [_infos count] > 0);
    if (infosExists) {
        [s appendString:@"\""]; [s appendString:@"infos"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger infosSize = (nil == _infos ? 0 : [_infos count]);
    if (infosSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int infosIdx = 0;
        for (id n1 in _infos) {/* vec.for: _infos */
            ++infosIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int n1Idx = 0;
                for (id n2 in n1) {/* vec.for: n1 */
                    ++n1Idx;
                    NSUInteger n2Size = (nil == n2 ? 0 : [n2 count]);
                    if (n2Size > 0) {
                        [s appendString:@"\n"]; [s appendString:@"["];
                        int n2Idx = 0;
                        for (id n3 in n2) {/* vec.for: n2 */
                            ++n2Idx;
                            NSUInteger n3Size = (nil == n3 ? 0 : [n3 count]);
                            if (n3Size > 0) {
                                [s appendString:@"\n"]; [s appendString:@"["];
                                int n3Idx = 0;
                                for (id n4 in n3) {/* vec.for: n3 */
                                    ++n3Idx;
                                    NSUInteger n4Size = (nil == n4 ? 0 : [n4 count]);
                                    if (n4Size > 0) {
                                        [s appendString:@"\n"]; [s appendString:@"["];
                                        int n4Idx = 0;
                                        for (id n5 in n4) {/* vec.for: n4 */
                                            ++n4Idx;
                                            [n5 writeJSON:s];
                                            if (n4Idx != n4Size) { [s appendString:@","]; }
                                        }
                                        [s appendString:@"]"];
                                    }
                                    if (n3Idx != n3Size) { [s appendString:@","]; }
                                }
                                [s appendString:@"]"];
                            }
                            if (n2Idx != n2Size) { [s appendString:@","]; }
                        }
                        [s appendString:@"]"];
                    }
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (infosIdx != infosSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL conflict_xExists = (nil != _conflict_x);
    if (comma && conflict_xExists) { [s appendString:comma]; comma = nil; }
    if (conflict_xExists) {
        [s appendString:@"\""]; [s appendString:@"conflict_x"]; [s appendString:@"\""]; [s appendString:@":"];
        comma = @","; [_conflict_x writeJSON:s];
    }
    BOOL conflict_aExists = (nil != _conflict_a);
    if (comma && conflict_aExists) { [s appendString:comma]; comma = nil; }
    if (conflict_aExists) {
        [s appendString:@"\""]; [s appendString:@"conflict_a"]; [s appendString:@"\""]; [s appendString:@":"];
        comma = @","; [_conflict_a writeJSON:s];
    }
    BOOL mConflictExists = (nil != _mConflict && [_mConflict count] > 0);
    if (comma && mConflictExists) { [s appendString:comma]; comma = nil; }
    if (mConflictExists) {
        [s appendString:@"\""]; [s appendString:@"mConflict"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger mConflictSize = (nil == _mConflict ? 0 : [_mConflict count]);
    if (mConflictSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"{"];
        int mConflictIdx = 0;
        for (id k1 in _mConflict) { /* map.for: _mConflict */
            ++mConflictIdx;
            [s appendString:@"\""]; [s appendFormat:@"%@", k1];
            [s appendString:@"\""]; [s appendString:@":"]; /* nest.k */
            id v1 = [_mConflict objectForKey:k1];
            [v1 writeJSON:s]; /* nest.v */
            if (mConflictIdx != mConflictSize) { [s appendString:@","]; }
        }
        [s appendString:@"}"];
    }
    BOOL info2dExists = (nil != _info2d && [_info2d count] > 0);
    if (comma && info2dExists) { [s appendString:comma]; comma = nil; }
    if (info2dExists) {
        [s appendString:@"\""]; [s appendString:@"info2d"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger info2dSize = (nil == _info2d ? 0 : [_info2d count]);
    if (info2dSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int info2dIdx = 0;
        for (id n1 in _info2d) {/* vec.for: _info2d */
            ++info2dIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int n1Idx = 0;
                for (id n2 in n1) {/* vec.for: n1 */
                    ++n1Idx;
                    [n2 writeJSON:s];
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (info2dIdx != info2dSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL info3dExists = (nil != _info3d && [_info3d count] > 0);
    if (comma && info3dExists) { [s appendString:comma]; comma = nil; }
    if (info3dExists) {
        [s appendString:@"\""]; [s appendString:@"info3d"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger info3dSize = (nil == _info3d ? 0 : [_info3d count]);
    if (info3dSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int info3dIdx = 0;
        for (id n1 in _info3d) {/* vec.for: _info3d */
            ++info3dIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int n1Idx = 0;
                for (id n2 in n1) {/* vec.for: n1 */
                    ++n1Idx;
                    NSUInteger n2Size = (nil == n2 ? 0 : [n2 count]);
                    if (n2Size > 0) {
                        [s appendString:@"\n"]; [s appendString:@"["];
                        int n2Idx = 0;
                        for (id n3 in n2) {/* vec.for: n2 */
                            ++n2Idx;
                            [n3 writeJSON:s];
                            if (n2Idx != n2Size) { [s appendString:@","]; }
                        }
                        [s appendString:@"]"];
                    }
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (info3dIdx != info3dSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL info5dExists = (nil != _info5d && [_info5d count] > 0);
    if (comma && info5dExists) { [s appendString:comma]; comma = nil; }
    if (info5dExists) {
        [s appendString:@"\""]; [s appendString:@"info5d"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger info5dSize = (nil == _info5d ? 0 : [_info5d count]);
    if (info5dSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int info5dIdx = 0;
        for (id n1 in _info5d) {/* vec.for: _info5d */
            ++info5dIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int n1Idx = 0;
                for (id n2 in n1) {/* vec.for: n1 */
                    ++n1Idx;
                    NSUInteger n2Size = (nil == n2 ? 0 : [n2 count]);
                    if (n2Size > 0) {
                        [s appendString:@"\n"]; [s appendString:@"["];
                        int n2Idx = 0;
                        for (id n3 in n2) {/* vec.for: n2 */
                            ++n2Idx;
                            NSUInteger n3Size = (nil == n3 ? 0 : [n3 count]);
                            if (n3Size > 0) {
                                [s appendString:@"\n"]; [s appendString:@"["];
                                int n3Idx = 0;
                                for (id n4 in n3) {/* vec.for: n3 */
                                    ++n3Idx;
                                    NSUInteger n4Size = (nil == n4 ? 0 : [n4 count]);
                                    if (n4Size > 0) {
                                        [s appendString:@"\n"]; [s appendString:@"["];
                                        int n4Idx = 0;
                                        for (id n5 in n4) {/* vec.for: n4 */
                                            ++n4Idx;
                                            [n5 writeJSON:s];
                                            if (n4Idx != n4Size) { [s appendString:@","]; }
                                        }
                                        [s appendString:@"]"];
                                    }
                                    if (n3Idx != n3Size) { [s appendString:@","]; }
                                }
                                [s appendString:@"]"];
                            }
                            if (n2Idx != n2Size) { [s appendString:@","]; }
                        }
                        [s appendString:@"]"];
                    }
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (info5dIdx != info5dSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL infovmExists = (nil != _infovm && [_infovm count] > 0);
    if (comma && infovmExists) { [s appendString:comma]; comma = nil; }
    if (infovmExists) {
        [s appendString:@"\""]; [s appendString:@"infovm"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger infovmSize = (nil == _infovm ? 0 : [_infovm count]);
    if (infovmSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int infovmIdx = 0;
        for (id n1 in _infovm) {/* vec.for: _infovm */
            ++infovmIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"{"];
                int n1Idx = 0;
                for (id k2 in n1) { /* map.for: n1 */
                    ++n1Idx;
                    [s appendString:@"\""]; [s appendFormat:@"%@", k2];
                    [s appendString:@"\""]; [s appendString:@":"]; /* nest.k */
                    id v2 = [n1 objectForKey:k2];
                    [v2 writeJSON:s]; /* nest.v */
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"}"];
            }
            if (infovmIdx != infovmSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL mveiExists = (nil != _mvei && [_mvei count] > 0);
    if (comma && mveiExists) { [s appendString:comma]; comma = nil; }
    if (mveiExists) {
        [s appendString:@"\""]; [s appendString:@"mvei"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger mveiSize = (nil == _mvei ? 0 : [_mvei count]);
    if (mveiSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"{"];
        int mveiIdx = 0;
        for (id k1 in _mvei) { /* map.for: _mvei */
            ++mveiIdx;
            NSUInteger k1Size = (nil == k1 ? 0 : [k1 count]);
            if (k1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int k1Idx = 0;
                for (id n2 in k1) {/* vec.for: k1 */
                    ++k1Idx;
                    [s appendFormat:@"%@", n2];
                    if (k1Idx != k1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            id v1 = [_mvei objectForKey:k1];
            [v1 writeJSON:s]; /* nest.v */
            if (mveiIdx != mveiSize) { [s appendString:@","]; }
        }
        [s appendString:@"}"];
    }
    BOOL miveExists = (nil != _mive && [_mive count] > 0);
    if (comma && miveExists) { [s appendString:comma]; comma = nil; }
    if (miveExists) {
        [s appendString:@"\""]; [s appendString:@"mive"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger miveSize = (nil == _mive ? 0 : [_mive count]);
    if (miveSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"{"];
        int miveIdx = 0;
        for (id k1 in _mive) { /* map.for: _mive */
            ++miveIdx;
            [s appendString:@"\""]; [k1 writeJSON:s];
            [s appendString:@"\""]; [s appendString:@":"]; /* nest.k */
            NSMutableArray *v1 = [_mive objectForKey:k1];/*map.head.v*/
            NSUInteger v1Size = (nil == v1 ? 0 : [v1 count]);
            if (v1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int v1Idx = 0;
                for (id n2 in v1) {/* vec.for: v1 */
                    ++v1Idx;
                    [s appendFormat:@"%@", n2];
                    if (v1Idx != v1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (miveIdx != miveSize) { [s appendString:@","]; }
        }
        [s appendString:@"}"];
    }
    BOOL mviveExists = (nil != _mvive && [_mvive count] > 0);
    if (comma && mviveExists) { [s appendString:comma]; comma = nil; }
    if (mviveExists) {
        [s appendString:@"\""]; [s appendString:@"mvive"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger mviveSize = (nil == _mvive ? 0 : [_mvive count]);
    if (mviveSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"{"];
        int mviveIdx = 0;
        for (id k1 in _mvive) { /* map.for: _mvive */
            ++mviveIdx;
            NSUInteger k1Size = (nil == k1 ? 0 : [k1 count]);
            if (k1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int k1Idx = 0;
                for (id n2 in k1) {/* vec.for: k1 */
                    ++k1Idx;
                    [n2 writeJSON:s];
                    if (k1Idx != k1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            NSMutableArray *v1 = [_mvive objectForKey:k1];/*map.head.v*/
            NSUInteger v1Size = (nil == v1 ? 0 : [v1 count]);
            if (v1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"["];
                int v1Idx = 0;
                for (id n2 in v1) {/* vec.for: v1 */
                    ++v1Idx;
                    [s appendFormat:@"%@", n2];
                    if (v1Idx != v1Size) { [s appendString:@","]; }
                }
                [s appendString:@"]"];
            }
            if (mviveIdx != mviveSize) { [s appendString:@","]; }
        }
        [s appendString:@"}"];
    }
    BOOL vmviveExists = (nil != _vmvive && [_vmvive count] > 0);
    if (comma && vmviveExists) { [s appendString:comma]; comma = nil; }
    if (vmviveExists) {
        [s appendString:@"\""]; [s appendString:@"vmvive"];
        [s appendString:@"\""]; [s appendString:@":"]; comma = @","; }
    NSUInteger vmviveSize = (nil == _vmvive ? 0 : [_vmvive count]);
    if (vmviveSize > 0) {
        [s appendString:@"\n"]; [s appendString:@"["];
        int vmviveIdx = 0;
        for (id n1 in _vmvive) {/* vec.for: _vmvive */
            ++vmviveIdx;
            NSUInteger n1Size = (nil == n1 ? 0 : [n1 count]);
            if (n1Size > 0) {
                [s appendString:@"\n"]; [s appendString:@"{"];
                int n1Idx = 0;
                for (id k2 in n1) { /* map.for: n1 */
                    ++n1Idx;
                    NSUInteger k2Size = (nil == k2 ? 0 : [k2 count]);
                    if (k2Size > 0) {
                        [s appendString:@"\n"]; [s appendString:@"["];
                        int k2Idx = 0;
                        for (id n3 in k2) {/* vec.for: k2 */
                            ++k2Idx;
                            [n3 writeJSON:s];
                            if (k2Idx != k2Size) { [s appendString:@","]; }
                        }
                        [s appendString:@"]"];
                    }
                    NSMutableArray *v2 = [n1 objectForKey:k2];/*map.head.v*/
                    NSUInteger v2Size = (nil == v2 ? 0 : [v2 count]);
                    if (v2Size > 0) {
                        [s appendString:@"\n"]; [s appendString:@"["];
                        int v2Idx = 0;
                        for (id n3 in v2) {/* vec.for: v2 */
                            ++v2Idx;
                            [s appendFormat:@"%@", n3];
                            if (v2Idx != v2Size) { [s appendString:@","]; }
                        }
                        [s appendString:@"]"];
                    }
                    if (n1Idx != n1Size) { [s appendString:@","]; }
                }
                [s appendString:@"}"];
            }
            if (vmviveIdx != vmviveSize) { [s appendString:@","]; }
        }
        [s appendString:@"]"];
    }
    BOOL hotfixExists = (nil != _hotfix && [_hotfix count] > 0);
    if (comma && hotfixExists) { [s appendString:comma]; comma = nil; }
    if (hotfixExists) {
        NSUInteger hotfixSize = (nil == _hotfix ? 0 : [_hotfix count]);
        if (hotfixSize > 0) {
            [s appendString:@"\n"]; [s appendString:@"{"];
            int hotfixIdx = 0;
            for (id k1 in _hotfix) { /* map.for: _hotfix */
                ++hotfixIdx;
                [s appendString:@"\""]; [s appendString:@"\""]; [s appendString:k1]; [s appendString:@"\""];
                [s appendString:@"\""]; [s appendString:@":"]; /* nest.k */
                id v1 = [_hotfix objectForKey:k1];
                [s appendString:@"\""]; [s appendString:v1]; [s appendString:@"\""]; /* nest.v */
                if (hotfixIdx != hotfixSize) { [s appendString:@","]; }
            }
            [s appendString:@"}"];
        } comma = @",";
    }
    [s appendString:@"}"]; [s appendString:@"\n"];
}
/* InfoX::writeJSON */

@end /* @implementation InfoX */

