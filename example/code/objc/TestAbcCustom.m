//*==---------------------------*  Obj-C  *--------------------------------===//
//
//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
//===----------------------------------------------------------------------==*//
///*
#if ! __has_feature(objc_arc)
#error This file must be compiled with ARC. Either turn on ARC for the project or use -fobjc-arc flag
#endif //*/

#import "TestAbcCustom.h"

#define CRC32__ 0x355EC042
#define SIZE__  23L

@interface Custom ()
{
    Gender            _x       ; /* 0 &-Test.Abc.Gender */
    TestBasic       * _test_   ; /* 1 &-Test.Abc.TestBasic */
    TestXyzConflict * _xyz     ; /* 2 &-Test.Xyz.Conflict */
    TestAbcConflict * _abc     ; /* 3 &-Test.Abc.Conflict */
    NSMutableArray  * _children; /* 4 &-vec<Test.Abc.Custom> */
    int32_t           _noSetter; /* 5 &-int32 */
    NSString        * _useRef  ; /* 6 &-string */
    NSString        * _usePtr  ; /* 7 *-string */
    Custom          * _prev    ; /* 8 *-Test.Abc.Custom */
    Custom          * _next    ; /* 9 *-Test.Abc.Custom */
    NSString        * _emptyDoc; /* 10 &-string */
}
@end

@implementation Custom

- (instancetype) init
{
    self = [super init];
    if (!self) { return self; }
    _x        = GenderNONE;
    _test_    = [[TestBasic alloc] init];
    _xyz      = [[TestXyzConflict alloc] init];
    _abc      = [[TestAbcConflict alloc] init];
    _children = [[NSMutableArray alloc] init];
    _noSetter = -1;
    _useRef   = @"";
    _usePtr   = nil;
    _prev     = nil;
    _next     = nil;
    _emptyDoc = @"";
    return self;
}
/* Custom::init */

- (void) dealloc
{
    if (_test_   ) { _test_    = nil; }
    if (_xyz     ) { _xyz      = nil; }
    if (_abc     ) { _abc      = nil; }
    if (_children) { _children = nil; }
    if (_useRef  ) { _useRef   = nil; }
    if (_usePtr  ) { _usePtr   = nil; }
    if (_prev    ) { _prev     = nil; }
    if (_next    ) { _next     = nil; }
    if (_emptyDoc) { _emptyDoc = nil; }
}
/* Custom::dealloc */

- (id) copyWithZone:(nullable NSZone *)zone;
{
    id copy = [[[self class] allocWithZone:zone] init];
    DataWriter *writer = [DataWriter CreateWithData:[[NSMutableData alloc] initWithCapacity:[self byteSize]]];
    [self write:writer];
    [copy read:[DataReader CreateWithData:writer.data]];
    return copy;
}
/* Custom::copyWithZone */

- (Gender           ) x        { return _x       ; }
- (TestBasic       *) test_    { return _test_   ; }
- (TestXyzConflict *) xyz      { return _xyz     ; }
- (TestAbcConflict *) abc      { return _abc     ; }
- (NSMutableArray  *) children { return _children; }
- (int32_t          ) noSetter { return _noSetter; }
- (NSString        *) useRef   { return _useRef  ; }
- (NSString        *) usePtr   { return _usePtr  ; }
- (Custom          *) prev     { return _prev    ; }
- (Custom          *) next     { return _next    ; }
- (NSString        *) emptyDoc { return _emptyDoc; }

- (Custom *) setX        : (Gender           )v { _x        = v; return self; }
- (Custom *) setTest_    : (TestBasic       *)v { _test_    = v; return self; }
- (Custom *) setXyz      : (TestXyzConflict *)v { _xyz      = v; return self; }
- (Custom *) setAbc      : (TestAbcConflict *)v { _abc      = v; return self; }
- (Custom *) setUseRef   : (NSString        *)v { _useRef   = v; return self; }
- (Custom *) setUsePtr   : (NSString        *)v { _usePtr   = v; return self; }
- (Custom *) setPrev     : (Custom          *)v { _prev     = v; return self; }
- (Custom *) setNext     : (Custom          *)v { _next     = v; return self; }
- (Custom *) setEmptyDoc : (NSString        *)v { _emptyDoc = v; return self; }

- (NSInteger)read:(const DataReader * const)r
{
    BOOL eof = false;
    _x = (Gender)[r readInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    NSInteger test_Err = [_test_ read:r]; if (test_Err != 0) { return test_Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    NSInteger xyzErr = [_xyz read:r]; if (xyzErr != 0) { return xyzErr; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    NSInteger abcErr = [_abc read:r]; if (abcErr != 0) { return abcErr; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    uint32_t lenChildren = [r readUInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    for (uint32_t iChildren = 0; iChildren < lenChildren; iChildren++) {
        Custom *n1 = [[Custom alloc] init];
        NSInteger n1Err = [n1 read:r]; if (n1Err != 0) { return n1Err; } if (eof) { return INVAR_ERR_DECODE_EOF; }
        [_children addObject:n1];
    } if (eof) { return INVAR_ERR_DECODE_EOF; }
    _noSetter = [r readInt32:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    _useRef = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    int8_t usePtrExists = [r readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if (0x01 == usePtrExists) {
        _usePtr = [r readString:&eof];
    }
    else if (0x00 == usePtrExists) { _usePtr = nil; }
    else { return INVAR_ERR_DECODE_STRING_P; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    int8_t prevExists = [r readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if (0x01 == prevExists) {
        if (_prev == nil) { _prev = [[Custom alloc] init]; }
        NSInteger prevErr = [_prev read:r]; if (prevErr != 0) { return prevErr; }
    }
    else if (0x00 == prevExists) { _prev = nil; }
    else { return INVAR_ERR_DECODE_STRUCT_P; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    int8_t nextExists = [r readInt8:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    if (0x01 == nextExists) {
        if (_next == nil) { _next = [[Custom alloc] init]; }
        NSInteger nextErr = [_next read:r]; if (nextErr != 0) { return nextErr; }
    }
    else if (0x00 == nextExists) { _next = nil; }
    else { return INVAR_ERR_DECODE_STRUCT_P; } if (eof) { return INVAR_ERR_DECODE_EOF; }
    _emptyDoc = [r readString:&eof]; if (eof) { return INVAR_ERR_DECODE_EOF; }
    return INVAR_ERR_NONE;
}
/* Custom::read(...) */

- (NSInteger)write:(DataWriter *)w
{
    [w writeInt32:_x];
    [_test_ write:w];
    [_xyz write:w];
    [_abc write:w];
    [w writeUInt32:(uint32_t)[_children count]];
    for (id n1 in _children) {
        [n1 write:w];
    }
    [w writeInt32:_noSetter];
    [w writeString:_useRef];
    if (_usePtr != nil) { [w writeInt8:0x01]; [w writeString:_usePtr]; }
    else { [w writeInt8:0x00]; }
    if (_prev != nil) { [w writeInt8:0x01]; [_prev write:w]; }
    else { [w writeInt8:0x00]; }
    if (_next != nil) { [w writeInt8:0x01]; [_next write:w]; }
    else { [w writeInt8:0x00]; }
    [w writeString:_emptyDoc];
    return 0;
}
/* Custom::write */

- (NSUInteger)byteSize
{
    NSUInteger size = SIZE__;
    size += [_test_ byteSize];
    size += [_xyz byteSize];
    size += [_abc byteSize];
    size += sizeof(uint32_t);
    for (id n1 in _children) {
        size += [n1 byteSize];
    }
    size += [_useRef length];
    if (_usePtr != nil) { size += [_usePtr length]; }
    if (_prev != nil) { size += [_prev byteSize]; }
    if (_next != nil) { size += [_next byteSize]; }
    size += [_emptyDoc length];
    return size;
}
/* Custom::byteSize */

- (NSString *)toStringJSON;
{
    NSMutableString *s = [[NSMutableString alloc] init] ;
    [self writeJSON:s];
    return s;
}

- (void)writeJSON:(NSMutableString *)s
{
    [s appendString:LINE_FEED_S]; [s appendString:LEFT_CURLY_S];
    NSString *comma = nil;
    [s appendString:QUOTATION_S]; [s appendString:@"x"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
    comma = COMMA_S; [s appendFormat:FORMAT_S, @(_x)];
    BOOL test_Exists = (nil != _test_);
    if (comma && test_Exists) { [s appendString:comma]; comma = nil; }
    if (test_Exists) {
        [s appendString:QUOTATION_S]; [s appendString:@"test_"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [_test_ writeJSON:s]; comma = COMMA_S;
    }
    BOOL xyzExists = (nil != _xyz);
    if (comma && xyzExists) { [s appendString:comma]; comma = nil; }
    if (xyzExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"xyz"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [_xyz writeJSON:s]; comma = COMMA_S;
    }
    BOOL abcExists = (nil != _abc);
    if (comma && abcExists) { [s appendString:comma]; comma = nil; }
    if (abcExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"abc"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [_abc writeJSON:s]; comma = COMMA_S;
    }
    BOOL childrenExists = (nil != _children && [_children count] > 0);
    if (comma && childrenExists) { [s appendString:comma]; comma = nil; }
    if (childrenExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"children"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
        NSUInteger childrenSize = (nil == _children ? 0 : [_children count]);
        if (childrenSize > 0) {
            [s appendString:LINE_FEED_S]; [s appendString:LEFT_SQUARE_S];
            int childrenIdx = 0;
            for (id n1 in _children) {/* vec.for: _children */
                ++childrenIdx;
                [n1 writeJSON:s];
                if (childrenIdx != childrenSize) { [s appendString:COMMA_S]; }
            }
            [s appendString:RIGHT_SQUARE_S];
        } comma = COMMA_S;
    }
    if (comma) { [s appendString:comma]; comma = nil; }
    [s appendString:QUOTATION_S]; [s appendString:@"noSetter"]; [s appendString:QUOTATION_S]; [s appendString:COLON_S];
    comma = COMMA_S; [s appendFormat:FORMAT_S, @(_noSetter)];
    BOOL useRefExists = (_useRef && [_useRef length] > 0);
    if (comma && useRefExists) { [s appendString:comma]; comma = nil; }
    if (useRefExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"useRef"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [s appendString:QUOTATION_S]; [s appendString:_useRef]; [s appendString:QUOTATION_S]; comma = COMMA_S;
    }
    BOOL usePtrExists = (_usePtr && [_usePtr length] > 0);
    if (comma && usePtrExists) { [s appendString:comma]; comma = nil; }
    if (usePtrExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"usePtr"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [s appendString:QUOTATION_S]; [s appendString:_usePtr]; [s appendString:QUOTATION_S]; comma = COMMA_S;
    }
    BOOL prevExists = (nil != _prev);
    if (comma && prevExists) { [s appendString:comma]; comma = nil; }
    if (prevExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"prev"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [_prev writeJSON:s]; comma = COMMA_S;
    }
    BOOL nextExists = (nil != _next);
    if (comma && nextExists) { [s appendString:comma]; comma = nil; }
    if (nextExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"next"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [_next writeJSON:s]; comma = COMMA_S;
    }
    BOOL emptyDocExists = (_emptyDoc && [_emptyDoc length] > 0);
    if (comma && emptyDocExists) { [s appendString:comma]; comma = nil; }
    if (emptyDocExists) {
        [s appendString:QUOTATION_S]; [s appendString:@"emptyDoc"]; [s appendString:QUOTATION_S];
        [s appendString:COLON_S]; [s appendString:QUOTATION_S]; [s appendString:_emptyDoc]; [s appendString:QUOTATION_S]; comma = COMMA_S;
    }
    [s appendString:RIGHT_CURLY_S]; [s appendString:LINE_FEED_S];
}
/* Custom::writeJSON */

@end /* @implementation Custom */
/*
3@test.abc.Custom/int32/test.abc.TestBasic/test.xyz.Conflict/test.abc.Conflict/vec-test.abc.Custom/i
  nt32/string/string/test.abc.Custom/test.abc.Custom/string
+@test.abc.Conflict/int32/string/vec-int8/map-string-string
+@test.abc.TestBasic/int8/int16/int32/int64/uint8/uint16/uint32/uint64/float/double/bool/string/int3
  2/int32
+@test.xyz.Conflict/double/map-string-string
*/

