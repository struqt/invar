<?xml version="1.0" encoding="UTF-8"?>
<tns:root
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="invar.template ../snippet.xsd" xmlns:tns="invar.template" language="objc">

  <export resPath="objc/DataReader.m" destDir="" destName="DataReader.m"/>
  <export resPath="objc/DataWriter.m" destDir="" destName="DataWriter.m"/>

  <!-- Redefine 14 Invar buildin types to adapt Objective-C language -->
  <redefine genericOverride="true"/>

  <!-- Settings -->
  <template key="trace.all.types">     <![CDATA[ false ]]></template>
  <template key="unique.type.name">    <![CDATA[ true  ]]></template>
  <template key="one.pack.one.file">   <![CDATA[ false ]]></template>
  <template key="include.self">        <![CDATA[ true  ]]></template>
  <template key="pack.name.nested">    <![CDATA[ true  ]]></template>
  <template key="code.dir.flatten">    <![CDATA[ true  ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ false ]]></template>
  <template key="no.generic.type">     <![CDATA[ true  ]]></template>
  <template key="method.indent.num">   <![CDATA[ 0     ]]></template>
  <template key="code.dir.prefix">     <![CDATA[  ]]></template>

  <!-- Common snippet -->
  <template key="init.any">   <![CDATA[ (#deft)    ]]></template>
  <template key="init.int64"> <![CDATA[ (#deft)L   ]]></template>
  <template key="init.uint64"><![CDATA[ (#deft)UL  ]]></template>
  <template key="init.float"> <![CDATA[ (#deft)F   ]]></template>
  <template key="init.enum">  <![CDATA[ (#name)    ]]></template>
  <template key="init.string"><![CDATA[ @"(#deft)" ]]></template>
  <template key="init.struct"><![CDATA[ [[(#type) alloc] init] ]]></template>
  <template key="init.vec">   <![CDATA[ [[NSMutableArray alloc] init] ]]></template>
  <template key="init.map">   <![CDATA[ [[NSMutableDictionary alloc] init] ]]></template>
  <template key="byte.yes">    <![CDATA[ 0x01 ]]></template>
  <template key="byte.non">    <![CDATA[ 0x00 ]]></template>
  <template key="doc">         <![CDATA[/* (#doc). */]]></template>
  <template key="doc.line">    <![CDATA[// (#doc).]]></template>
  <template key="import.split"><![CDATA[ _ ]]></template>
  <template key="pointer.null">  <![CDATA[ nil ]]></template>
  <template key="ptr.mark.string | ptr.mark.vec |
                 ptr.mark.struct | ptr.mark.map"><![CDATA[ * ]]></template>

  <template key="file"><![CDATA[
	//*==---------------------------*  Obj-C  *--------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------==*//
	(#blank)
	(#includes)
	(#pack)
	]]></template>
  <template key="file.include"><![CDATA[ #import "(#name)"(#brk) ]]></template>
  <template key="file.pack"><![CDATA[ (#body) ]]></template>
  <template key="file.body"><![CDATA[
	(#blank)
	(#structs)]]></template>
  <template key="struct.meta"><![CDATA[ /* (#name) (#type) */ ]]></template>
  <template key="struct.field.self"><![CDATA[ & ]]></template>
  <template key="struct.field.prefix"><![CDATA[ _ ]]></template>
  <template key="struct.field"><![CDATA[
	  (#tab)[#clampLen(lenFieldType; 64; (#type) )] (#mark)
	  (#concat) [#clampLen(lenFieldName; 32; (#name) )];
	  (#concat) [#codeMetaData(fields; (#index))]
	]]></template>
  <template key="struct.field.del"><![CDATA[
    (#brk)(#tab)if ((#name) != (#null)) {
    (#tab)(#tab)delete (#name);
    (#tab)(#tab)(#name) = (#null);
    (#tab)}]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; ::DataWriter)]
    [#addImport(struct; imports; ::DataReader)]
    @interface (#name) ()
    {
    [#codeFields(struct; fields)]}
    @end
    (#blank)
    @implementation (#name)
    (#blank)
    static const uint32_t CRC32 = 0x[#codeCRC32(struct)];
    (#blank)
    [#codeNested (ctor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeGetters(struct; fields)]
    (#blank)
    [#codeSetters(struct; fields)]
    (#blank)
    [#codeNested (read.;  useFullName; struct; fields; imports)]
    @end /* @implementation (#name) */
	]]></template>

  <template key="struct.getter"><![CDATA[
    - ([#clampLen(lenFieldType; 64; (#type) )] (#mark))
    (#concat) [#clampLen(lenFieldNameR; 32; (#namer) )] {
    (#concat) return [#clampLen(lenFieldName; 32; (#name) )]; }
  ]]></template>
  <template key="struct.setter"><![CDATA[
    - ((#typeupper) *) set[#clampLen(lenFieldName; 24; [#upperHeadChar( (#namer) )] )]
    (#concat):([#clampLen(lenFieldType; 64; (#type) )] (#mark))v
    (#concat) { [#clampLen(lenFieldName; 32; (#name) )] = v;
    (#concat) return self;
    (#concat) }
  ]]></template>

  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    - (instancetype) init
    {
    (#tab)self = [super init];
    (#tab)if (!self) { return self; }(#body)
    (#tab)return self;
    }
    /* End of init */
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 24; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 24; (#name))] = (#null); ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body); ]]></template>

  <!-- Method Read -->
  <template key="read.import"><![CDATA[ ::DataReader ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    - (int32_t) read: (DataReader *)r
    {
    (#tab)boolean_t eof = false;(#body)
    (#tab)return 0;
    }
    /* (#type)::read(...) */ ]]></template>
  <template key="read.int8">  <![CDATA[ [(#arg) readInt8:&eof]   ]]></template>
  <template key="read.int16"> <![CDATA[ [(#arg) readInt16:&eof]  ]]></template>
  <template key="read.int32"> <![CDATA[ [(#arg) readInt32:&eof]  ]]></template>
  <template key="read.int64"> <![CDATA[ [(#arg) readInt64:&eof]  ]]></template>
  <template key="read.uint8"> <![CDATA[ [(#arg) readUInt8:&eof]  ]]></template>
  <template key="read.uint16"><![CDATA[ [(#arg) readUInt16:&eof] ]]></template>
  <template key="read.uint32"><![CDATA[ [(#arg) readUInt32:&eof] ]]></template>
  <template key="read.uint64"><![CDATA[ [(#arg) readUInt64:&eof] ]]></template>
  <template key="read.float"> <![CDATA[ [(#arg) readFloat:&eof]  ]]></template>
  <template key="read.double"><![CDATA[ [(#arg) readDouble:&eof] ]]></template>
  <template key="read.string"><![CDATA[ [(#arg) readString:&eof] ]]></template>
  <template key="read.bool">  <![CDATA[ [(#arg) readBool:&eof]   ]]></template>
  <template key="read.enum">  <![CDATA[ ((#type))[(#arg) readInt32:&eof]  ]]></template>
  <template key="read.struct"><![CDATA[ int32_t (#namer)Err = [(#name) read:(#arg)]    ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.float|read.nest.k.float|read.nest.v.float"><![CDATA[
    NSNumber *(#name) = @((#body)); ]]></template>
  <template key="read.nest.n.double|read.nest.k.double|read.nest.v.double"><![CDATA[
    NSNumber *(#name) = @((#body)); ]]></template>
  <template key="read.nest.n.string|read.nest.k.string|read.nest.v.string"><![CDATA[
    (#type) *(#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) *(#name) = [[(#type) alloc] init];
    (#body); if ((#namer)Err != 0) { return (#namer)Err; }
  ]]></template>
  <template key="read.vec.head">  <![CDATA[ (#typel) *(#name) = [[(#typel) alloc] init]; //read.vec.head(#brk) ]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof];
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) addObject:(#value)];
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[ (#typel) *(#name) = [[(#typel) alloc] init]; //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof];
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) setObject:(#value) forKey:(#key)];
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 496; }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#type) alloc] init]; }
    (#tab)(#body); if ((#namer)Err != 0) { return (#namer)Err; }
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 497; }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#typel) alloc] init]; }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 498; }
  ]]></template>
  <template key="read.field.tail.any"><![CDATA[
    (#space)if (eof) { return 495; }
  ]]></template>
  <template key="read.field.tail.struct"><![CDATA[
    (#space)if ((#namer)Err != 0) { return (#namer)Err; }
  ]]></template>
  <template key="read.field.tail.struct.ptr | read.field.tail.vec | read.field.tail.map"><![CDATA[
    (#blank)
  ]]></template>

  <template key="read.special.protocCRC"><![CDATA[
    if (CRC32 != (#name)) { return 499; }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    if ((#name) != 0) { return (#name); }
  ]]></template>


</tns:root>