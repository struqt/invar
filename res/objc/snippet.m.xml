<?xml version="1.0" encoding="UTF-8"?>
<tns:root
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="invar.template ../snippet.xsd" xmlns:tns="invar.template" language="objc">

  <export resPath="objc/DataReader.m" destDir="" destName="DataReader.m"/>
  <export resPath="objc/DataWriter.m" destDir="" destName="DataWriter.m"/>

  <!-- Redefine 14 Invar buildin types to adapt Objective-C language -->
  <redefine genericOverride="true"/>

  <!-- Settings -->
  <template key="trace.all.types">     <![CDATA[ false ]]></template>
  <template key="unique.type.name">    <![CDATA[ true  ]]></template>
  <template key="one.pack.one.file">   <![CDATA[ false ]]></template>
  <template key="include.self">        <![CDATA[ true  ]]></template>
  <template key="pack.name.nested">    <![CDATA[ true  ]]></template>
  <template key="code.dir.flatten">    <![CDATA[ true  ]]></template>
  <template key="file.name.lowercase"> <![CDATA[ false ]]></template>
  <template key="no.generic.type">     <![CDATA[ true  ]]></template>
  <template key="method.indent.num">   <![CDATA[ 0     ]]></template>
  <template key="code.dir.prefix">     <![CDATA[  ]]></template>

  <!-- Common snippet -->
  <template key="init.any">   <![CDATA[ (#deft)    ]]></template>
  <template key="init.int64"> <![CDATA[ (#deft)L   ]]></template>
  <template key="init.uint64"><![CDATA[ (#deft)UL  ]]></template>
  <template key="init.float"> <![CDATA[ (#deft)F   ]]></template>
  <template key="init.enum">  <![CDATA[ (#name)    ]]></template>
  <template key="init.string"><![CDATA[ @"(#deft)" ]]></template>
  <template key="init.struct"><![CDATA[ [[(#type) alloc] init] ]]></template>
  <template key="init.vec">   <![CDATA[ [[NSMutableArray alloc] init] ]]></template>
  <template key="init.map">   <![CDATA[ [[NSMutableDictionary alloc] init] ]]></template>
  <template key="byte.yes">    <![CDATA[ 0x01 ]]></template>
  <template key="byte.non">    <![CDATA[ 0x00 ]]></template>
  <template key="doc">         <![CDATA[/* (#doc). */]]></template>
  <template key="doc.line">    <![CDATA[// (#doc).]]></template>
  <template key="import.split"><![CDATA[ _ ]]></template>
  <template key="pointer.null">  <![CDATA[ nil ]]></template>
  <template key="ptr.mark.string | ptr.mark.vec |
                 ptr.mark.struct | ptr.mark.map"><![CDATA[ * ]]></template>

  <template key="file"><![CDATA[
	//*==---------------------------*  Obj-C  *--------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------==*//
	(#blank)
	(#includes)
	(#pack)
	]]></template>
  <template key="file.include"><![CDATA[ #import "(#name)"(#brk) ]]></template>
  <template key="file.pack"><![CDATA[ (#body) ]]></template>
  <template key="file.body"><![CDATA[
	(#blank)
	(#structs)]]></template>
  <template key="struct.meta"><![CDATA[ /* (#name) (#type) */ ]]></template>
  <template key="struct.field.self"><![CDATA[ & ]]></template>
  <template key="struct.field.prefix"><![CDATA[ _ ]]></template>
  <template key="struct.field"><![CDATA[
	  (#tab)[#clampLen(lenFieldType; 64; (#type) )] (#mark)
	  (#concat) [#clampLen(lenFieldName; 32; (#name) )];
	  (#concat) [#codeMetaData(fields; (#index))]
	]]></template>
  <template key="struct.field.del"><![CDATA[
    (#brk)(#tab)if ((#name) != (#null)) {
    (#tab)(#tab)delete (#name);
    (#tab)(#tab)(#name) = (#null);
    (#tab)}]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; ::DataWriter)]
    [#addImport(struct; imports; ::DataReader)]
    #define CRC32 0x[#codeCRC32(struct)]
    (#blank)
    @interface (#name) ()
    {
    [#codeFields(struct; fields)]}
    @end
    (#blank)
    @implementation (#name)
    (#blank)
    [#codeNested (ctor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (dtor.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (copy.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeGetters(struct; fields)]
    (#blank)
    [#codeSetters(struct; fields)]
    (#blank)
    [#codeNested (read.;  useFullName; struct; fields; imports)]
    (#blank)
    [#codeNested (write.;  useFullName; struct; fields; imports)]
    (#blank)
    @end /* @implementation (#name) */
	]]></template>

  <template key="struct.getter"><![CDATA[
    - ([#clampLen(lenFieldType; 64; (#type) )] (#mark))
    (#concat) [#clampLen(lenFieldNameR; 32; (#namer) )] {
    (#concat) return [#clampLen(lenFieldName; 32; (#name) )]; }
  ]]></template>
  <template key="struct.setter"><![CDATA[
    - ((#typeupper) *) set[#clampLen(lenFieldName; 24; [#upperHeadChar( (#namer) )] )]:
    (#concat) ([#clampLen(lenFieldType; 64; (#type) )] (#mark))v
    (#concat) { [#clampLen(lenFieldName; 32; (#name) )] = v;
    (#concat) return self;
    (#concat) }
  ]]></template>


  <!-- Method Construct -->
  <template key="ctor.method"><![CDATA[
    - (instancetype) init
    {
    (#tab)self = [super init];
    (#tab)if (!self) { return self; }(#body)
    (#tab)return self;
    }
    /* (#type)::init */
  ]]></template>
  <template key="ctor.any | ctor.vec | ctor.map"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#deft) ]]></template>
  <template key="ctor.ptr.any"><![CDATA[
    [#clampLen(lenFieldName; 32; (#name))] = (#null); ]]></template>
  <template key="ctor.ref.any"><![CDATA[ (#body); ]]></template>


  <!-- Method Destruct -->
  <template key="dtor.method"><![CDATA[
    - (void) dealloc
    {(#body)
    (#tab)[super dealloc];
    }
    /* (#type)::dealloc */
  ]]></template>
  <template key="dtor.any"><![CDATA[ ]]></template>
  <template key="dtor.vec | dtor.map | dtor.string | dtor.struct"><![CDATA[
    if ([#clampLen(lenFieldName; 32; (#name) )]) {
    (#concat-all) [[#clampLen(lenFieldName; 32; (#name) )] dealloc];
    (#concat-all) [#clampLen(lenFieldName; 32; (#name) )] = nil; } ]]></template>
  <template key="dtor.ptr.any"><![CDATA[ (#body) ]]></template>
  <template key="dtor.ref.any"><![CDATA[ (#body) ]]></template>

  <!-- Method Copy -->
  <template key="copy.method"><![CDATA[
    - (id) copyWithZone:(nullable NSZone *)zone;
    {
    (#tab)id copy = [[[self class] allocWithZone:zone] init];
    (#tab)NSMutableData *data = [[NSMutableData alloc] initWithCapacity:1024];
    (#tab)[self write:[DataWriter CreateWithData:data]];
    (#tab)[copy read:[DataReader CreateWithData:data]];
    (#tab)[data dealloc];
    (#tab)return copy;
    }
    /* (#type)::copyWithZone */
  ]]></template>

  <!-- Method Read -->
  <template key="read.import"><![CDATA[ ::DataReader ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    - (NSInteger)read:(DataReader *)r
    {
    (#tab)boolean_t eof = false;(#body)
    (#tab)return 0;
    }
    /* (#type)::read(...) */ ]]></template>
  <template key="read.int8">  <![CDATA[ [(#arg) readInt8:&eof]   ]]></template>
  <template key="read.int16"> <![CDATA[ [(#arg) readInt16:&eof]  ]]></template>
  <template key="read.int32"> <![CDATA[ [(#arg) readInt32:&eof]  ]]></template>
  <template key="read.int64"> <![CDATA[ [(#arg) readInt64:&eof]  ]]></template>
  <template key="read.uint8"> <![CDATA[ [(#arg) readUInt8:&eof]  ]]></template>
  <template key="read.uint16"><![CDATA[ [(#arg) readUInt16:&eof] ]]></template>
  <template key="read.uint32"><![CDATA[ [(#arg) readUInt32:&eof] ]]></template>
  <template key="read.uint64"><![CDATA[ [(#arg) readUInt64:&eof] ]]></template>
  <template key="read.float"> <![CDATA[ [(#arg) readFloat:&eof]  ]]></template>
  <template key="read.double"><![CDATA[ [(#arg) readDouble:&eof] ]]></template>
  <template key="read.string"><![CDATA[ [(#arg) readString:&eof] ]]></template>
  <template key="read.bool">  <![CDATA[ [(#arg) readBool:&eof]   ]]></template>
  <template key="read.enum">  <![CDATA[ ((#type))[(#arg) readInt32:&eof]  ]]></template>
  <template key="read.struct"><![CDATA[ NSInteger (#namer)Err = [(#name) read:(#arg)]    ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.int8  |read.nest.k.int8  |read.nest.v.int8  |
                 read.nest.n.int16 |read.nest.k.int16 |read.nest.v.int16 |
                 read.nest.n.int32 |read.nest.k.int32 |read.nest.v.int32 |
                 read.nest.n.int64 |read.nest.k.int64 |read.nest.v.int64 |
                 read.nest.n.uint8 |read.nest.k.uint8 |read.nest.v.uint8 |
                 read.nest.n.uint16|read.nest.k.uint16|read.nest.v.uint16|
                 read.nest.n.uint32|read.nest.k.uint32|read.nest.v.uint32|
                 read.nest.n.uint64|read.nest.k.uint64|read.nest.v.uint64|
                 read.nest.n.float |read.nest.k.float |read.nest.v.float |
                 read.nest.n.double|read.nest.k.double|read.nest.v.double"><![CDATA[
    NSNumber *(#name) = @((#body)); ]]></template>
  <template key="read.nest.n.bool|read.nest.k.bool|read.nest.v.bool|
                 read.nest.n.enum|read.nest.k.enum|read.nest.v.enum"><![CDATA[
    id (#name) = @((#body)); ]]></template>
  <template key="read.nest.n.string|read.nest.k.string|read.nest.v.string"><![CDATA[
    (#type) *(#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) *(#name) = [[(#type) alloc] init];
    (#body); if ((#namer)Err != 0) { return (#namer)Err; }
  ]]></template>
  <template key="read.vec.head"><![CDATA[
    (#typel) *(#name) = [[(#typel) alloc] init]; //read.vec.head(#brk) ]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof];
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) addObject:(#value)];
    }
  ]]></template>
  <template key="read.map.head">
    <![CDATA[ (#typel) *(#name) = [[(#typel) alloc] init]; //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = [(#arg) readUInt32:&eof];
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)[(#name) setObject:(#value) forKey:(#key)];
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 496; }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#type) alloc] init]; }
    (#tab)(#body); if ((#namer)Err != 0) { return (#namer)Err; }
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 497; }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    int8_t (#namer)Exists = [(#arg) readInt8:&eof];
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = [[(#typel) alloc] init]; }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { return 498; }
  ]]></template>
  <template key="read.field.tail.any"><![CDATA[
    (#space)if (eof) { return 495; }
  ]]></template>
  <template key="read.field.tail.struct"><![CDATA[
    (#space)if ((#namer)Err != 0) { return (#namer)Err; }
  ]]></template>
  <template key="read.field.tail.struct.ptr | read.field.tail.vec | read.field.tail.map"><![CDATA[
    (#blank)
  ]]></template>

  <template key="read.special.protocCRC"><![CDATA[
    if (CRC32 != (#name)) { return 499; }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    if ((#name) != 0) { return (#name); }
  ]]></template>


  <!-- Method Write -->
  <template key="write.import"><![CDATA[ ::DataWriter ]]></template>
  <template key="write.method.arg"><![CDATA[ w ]]></template>
  <template key="write.method"><![CDATA[
    - (NSInteger)write:(DataWriter *)(#arg)
    {(#body)
    (#tab)return 0;
    }
    /* (#type)::write */ ]]></template>
  <template key="write.int8">  <![CDATA[ [(#arg) writeInt8:(#name)]   ]]></template>
  <template key="write.int16"> <![CDATA[ [(#arg) writeInt16:(#name)]  ]]></template>
  <template key="write.int32"> <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.int64"> <![CDATA[ [(#arg) writeInt64:(#name)]  ]]></template>
  <template key="write.uint8"> <![CDATA[ [(#arg) writeUInt8:(#name)]  ]]></template>
  <template key="write.uint16"><![CDATA[ [(#arg) writeUInt16:(#name)] ]]></template>
  <template key="write.uint32"><![CDATA[ [(#arg) writeUInt32:(#name)] ]]></template>
  <template key="write.uint64"><![CDATA[ [(#arg) writeUInt64:(#name)] ]]></template>
  <template key="write.float"> <![CDATA[ [(#arg) writeFloat:(#name)]  ]]></template>
  <template key="write.double"><![CDATA[ [(#arg) writeDouble:(#name)] ]]></template>
  <template key="write.bool">  <![CDATA[ [(#arg) writeBool:(#name)]   ]]></template>
  <template key="write.string"><![CDATA[ [(#arg) writeString:(#name)] ]]></template>
  <template key="write.enum">  <![CDATA[ [(#arg) writeInt32:(#name)]  ]]></template>
  <template key="write.struct"><![CDATA[ [(#name) write:(#arg)]       ]]></template>
  <template key="write.vec.head">  <![CDATA[ ]]></template>
  <template key="write.vec.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#value) in (#name)) {(#body)
    }
  ]]></template>
  <template key="write.map.head.k"><![CDATA[ ]]></template>
  <template key="write.map.head.v"><![CDATA[
    (#typel) *(#name) = [(#nameupper2) objectForKey:(#key)];/*write.map.head.v*/(#brk) ]]></template>
  <template key="write.map.for"><![CDATA[
    [(#arg) writeUInt32:((#sizetype))[(#name) count]];
    for (id (#key) in (#name)) {(#body)
    }
  ]]></template>

  <template key="write.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.k"><![CDATA[ (#body); ]]></template>
  <template key="write.nest.n.int8 | write.nest.k.int8"><![CDATA[
    [(#arg) writeInt8:[(#name) charValue]]; ]]></template>
  <template key="write.nest.n.uint8 | write.nest.k.uint8 | write.nest.n.bool | write.nest.k.bool"><![CDATA[
    [(#arg) writeUInt8:[(#name) unsignedCharValue]]; ]]></template>
  <template key="write.nest.n.int16 | write.nest.k.int16"><![CDATA[
    [(#arg) writeInt16:[(#name) shortValue]]; ]]></template>
  <template key="write.nest.n.uint16 | write.nest.k.uint16"><![CDATA[
    [(#arg) writeUInt16:[(#name) unsignedShortValue]]; ]]></template>
  <template key="write.nest.n.int32 | write.nest.k.int32 | write.nest.n.enum | write.nest.k.enum"><![CDATA[
    [(#arg) writeInt32:[(#name) intValue]]; ]]></template>
  <template key="write.nest.n.uint32 | write.nest.k.uint32"><![CDATA[
    [(#arg) writeUInt32:[(#name) unsignedIntValue]]; ]]></template>
  <template key="write.nest.n.int64 | write.nest.k.int64"><![CDATA[
    [(#arg) writeInt64:[(#name) longValue]]; ]]></template>
  <template key="write.nest.n.uint64 | write.nest.k.uint64"><![CDATA[
    [(#arg) writeUInt64:[(#name) unsignedLongValue]]; ]]></template>
  <template key="write.nest.n.float | write.nest.k.float"><![CDATA[
    [(#arg) writeFloat:[(#name) floatValue]]; ]]></template>
  <template key="write.nest.n.double | write.nest.k.double"><![CDATA[
    [(#arg) writeDouble:[(#name) doubleValue]]; ]]></template>

  <template key="write.nest.v"><![CDATA[
    (#type) (#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>
  <template key="write.nest.v.int8"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] charValue]; (#body); ]]></template>
  <template key="write.nest.v.uint8 | write.nest.v.bool"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedCharValue]; (#body); ]]></template>
  <template key="write.nest.v.int16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] shortValue]; (#body); ]]></template>
  <template key="write.nest.v.uint16"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedShortValue]; (#body); ]]></template>
  <template key="write.nest.v.int32 | write.nest.v.enum"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] intValue]; (#body); ]]></template>
  <template key="write.nest.v.uint32"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedIntValue]; (#body); ]]></template>
  <template key="write.nest.v.int64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] longValue]; (#body); ]]></template>
  <template key="write.nest.v.uint64"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] unsignedLongValue]; (#body); ]]></template>
  <template key="write.nest.v.float"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] floatValue]; (#body); ]]></template>
  <template key="write.nest.v.double"><![CDATA[
    (#type) (#name) = [[(#nameupper2) objectForKey:(#key)] doubleValue]; (#body); ]]></template>
  <template key="write.nest.v.string | write.nest.v.struct | write.nest.v.vec | write.nest.v.map"><![CDATA[
    (#type) *(#name) = [(#nameupper2) objectForKey:(#key)];(#brk)(#body); ]]></template>

  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) { [(#arg) writeInt8:(#byteyes)]; (#body); }
    else { [(#arg) writeInt8:(#bytenon)]; }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)[(#arg) writeInt8:(#byteyes)];(#bodyindent)
    } else {
    (#tab)[(#arg) writeInt8:(#bytenon)];
    }
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) { return (#name); }
  ]]></template>


</tns:root>