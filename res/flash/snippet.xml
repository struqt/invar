<?xml version="1.0" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="flash">
  <export resPath="flash/InvarReadData.as" destDir="invar" destName="InvarReadData.as"/>
  
  <!-- Redefine 14 Invar buildin types to adapt AS3 language  -->
  <!-- & &amp; < &lt; > &gt; " &quot; ' &apos; -->
  <!-- &lt;?,?&gt; -->
  <redefine>
    <int8 pack="" type="int" initValue="-1"/>
    <int16 pack="" type="int" initValue="-1"/>
    <int32 pack="" type="int" initValue="-1"/>
    <int64 pack="" type="Number" initValue="-1"/>
    <uint8 pack="" type="uint" initValue="0"/>
    <uint16 pack="" type="uint" initValue="0"/>
    <uint32 pack="" type="uint" initValue="0"/>
    <uint64 pack="" type="Number" initValue="0"/>
    <float pack="" type="Number" initValue="0.0"/>
    <double pack="" type="Number" initValue="0.00"/>
    <string pack="" type="String" initValue="&quot;&quot;" initPrefix="&quot;" initSuffix="&quot;"/>
    <bool pack="" type="Boolean" initValue="false"/>
    <vec pack="" type="Vector" generic=".&lt;?&gt;" initValue=""/>
    <map pack="flash.utils" type="Dictionary" generic="" initValue=""/>
    <dialect pack="flash.utils" type="IDataOutput"/>
    <dialect pack="flash.utils" type="IDataInput"/>
  </redefine>
  
  
  <template key="file"><![CDATA[
	// THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	(#blank)
	(#pack)]]></template>
 
  <template key="file.pack"><![CDATA[
	package (#name) {
    (#body)} //package: (#name)]]></template>
  
  <template key="file.body"><![CDATA[
	(#import)(#enums)(#structs)]]></template>
  <template key="pointer.null"><![CDATA[null]]></template>
  
  
  <template key="import"><![CDATA[import (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)(#name)]]></template>
  <template key="import.split"><![CDATA[.]]></template>
  <template key="doc"><![CDATA[/** (#doc) */]]></template>
  <template key="doc.line"><![CDATA[// (#doc)]]></template>
  <template key="init.struct"><![CDATA[new (#type)()]]></template>
  <template key="init.enum"><![CDATA[(#type).(#name)]]></template>
  <template key="code.assignment"><![CDATA[var (#name):(#type) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[var (#name):(#type);(#brk)]]></template>
  <template key="code.indexer"><![CDATA[ (#name).get((#index)) ]]></template>
  <template key="pack"><![CDATA[
    // THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    package (#name) {
    (#brk)(#import)
    (#body)} // End package (#name)
  ]]></template>
  <template key="enum.field"><![CDATA[
    (#brk)(#tab)(#doc)
    (#tab)static public var (#name):(#type) = new (#type) ((#value), "(#name)");]]></template>
  <template key="enum"><![CDATA[
    public class (#name)
    {(#body)
    
    (#blank)
    (#tab)static public function parseValue(v:int):(#name)
    (#tab){
    (#tab)(#tab)var len:int = all.length;
    (#tab)(#tab)for (var i:int = 0; i < len; i++)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)var enum:(#name) = all[i];
    (#tab)(#tab)(#tab)if (enum.getValue() == v)
    (#tab)(#tab)(#tab)(#tab)return enum;
    (#tab)(#tab)}
    (#tab)(#tab)return all[0];
    (#tab)}
    
    (#blank)
    (#tab)static public function parseName(v:String):(#name)
    (#tab){
    (#tab)(#tab)var len:int = all.length;
    (#tab)(#tab)for (var i:int = 0; i < len; i++)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)var enum:(#name) = all[i];
    (#tab)(#tab)(#tab)if (enum.getName() == v)
    (#tab)(#tab)(#tab)(#tab)return enum;
    (#tab)(#tab)}
    (#tab)(#tab)return all[0];
    (#tab)}
    (#blank)
    (#tab)static private var all:Vector.<(#name)> = new Vector.<(#name)>();
    
    (#blank)
    (#tab)public function getValue():int    { return value; }
    (#tab)public function getName() :String { return name; }
    (#tab)public function toString():String { return name + "(" + value + ")"; }
    (#blank)
    (#tab)public function (#name)(v:int, n:String)
    (#tab){
    (#tab)(#tab)this.name = n;
    (#tab)(#tab)this.value = v;
    (#tab)(#tab)(#name).all.push(this);
    (#tab)}
    (#blank)
    (#tab)private var name:String;
    (#tab)private var value:int; 
    }
  ]]></template>
  <template key="struct"><![CDATA[
    public final class (#name)
    {
    (#body)
    }
    ]]></template>
  <template key="struct.meta"><![CDATA[[InvarRule(T="(#type)", S="(#name)")] ]]></template>
  <template key="struct.field"><![CDATA[(#tab)private var (#name):(#type) = (#value);(#doc)(#brk)]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)(#doc)
    (#tab)(#meta)
    (#tab)public function set(#nameupper)(value:(#type)):(#typehost) {this.(#name) = value; return this;}
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)(#doc)
    (#tab)(#meta)
    (#tab)public function get(#nameupper)():(#type) {return (#name);}
  ]]></template>
  <template key="runtime.pack"><![CDATA[invar]]></template>
  <template key="runtime.name"><![CDATA[InvarRuntime]]></template>
  <template key="runtime.alias"><![CDATA[
    (#tab)static private LinkedHashMap<String,Class<?>> (#name) ()
    (#tab){
    (#tab)(#tab)LinkedHashMap<String,Class<?>> map = new LinkedHashMap<String,Class<?>>();(#body)
    (#tab)(#tab)return map;
    (#tab)}
  ]]></template>
  <template key="runtime.alias.basic"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.list"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.map"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.body"><![CDATA[
    (#tab)static public InvarReadData MakeXmlReader()
    (#tab){
    (#tab)(#tab)if (InvarReadData.aliasBasics == null)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)InvarReadData.aliasBasics = aliasBasic();
    (#tab)(#tab)(#tab)InvarReadData.aliasEnums = aliasEnum();
    (#tab)(#tab)(#tab)InvarReadData.aliasStructs = aliasStruct();
    (#tab)(#tab)}
    (#tab)(#tab) return new InvarReadData();
    (#tab)}
    (#body)
  ]]></template>
  
  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[flash.utils::IDataInput]]></template>
  <template key="read.method"><![CDATA[
  (#tab)public function read(input:IDataInput):(#type)
  (#tab){(#body)
  (#tab)(#tab)return this;
  (#tab)}
  ]]></template>
  <template key="read.int8"><![CDATA[(#name) = input.readByte();]]></template>
  <template key="read.int16"><![CDATA[(#name) = input.readShort();]]></template>
  <template key="read.int32"><![CDATA[(#name) = input.readInt();]]></template>
  <template key="read.int64"><![CDATA[(#name) = input.readDouble();]]></template>
  <template key="read.uint8"><![CDATA[(#name) = input.readUnsignedByte();]]></template>
  <template key="read.uint16"><![CDATA[(#name) = input.readUnsignedShort();]]></template>
  <template key="read.uint32"><![CDATA[(#name) = input.readInt() & 0xFFFFFFFFL;]]></template>
  <template key="read.uint64"><![CDATA[(#name) = input.readDouble();]]></template>
  <template key="read.float"><![CDATA[(#name) = input.readFloat();]]></template>
  <template key="read.double"><![CDATA[(#name) = input.readDouble();]]></template>
  <template key="read.string"><![CDATA[(#name) = input.readUTF();]]></template>
  <template key="read.bool"><![CDATA[(#name) = input.readBoolean();]]></template>
  <template key="read.enum"><![CDATA[(#name) = (#type).parseValue(input.readInt());]]></template>
  <template key="read.struct"><![CDATA[(#name).read(input);]]></template>
  <template key="read.struct.check"><![CDATA[
  if (input.readUnsignedByte() == 0x01)
  {
  (#tab)if ((#name) == null)
  (#tab)(#tab)(#name) = new (#type)();
  (#tab)(#name).read(input);
  }
  ]]></template>
  <template key="read.size.init"><![CDATA[input.readInt();]]></template>
  <template key="read.vec"><![CDATA[(#name).add((#value));]]></template>
  <template key="read.map"><![CDATA[(#nameupper).put((#name),(#value));]]></template>
  <template key="read.vec.for"><![CDATA[
  var (#len):(#sizetype) = input.readInt();
  for (var (#index):(#sizetype) = 0; (#index) < (#len); (#index)++)
  {(#body)
  (#tab)(#name).push((#value));
  }
  ]]></template>
  <template key="read.map.keys"><![CDATA[]]>
  </template>
  <template key="read.map.for"><![CDATA[
  var (#len):(#sizetype) = input.readInt();
  for (var (#index):(#sizetype) = 0; (#index) < (#len); (#index)++)
  {(#body)
  (#tab)(#name).push((#key),(#value));
  }
  ]]></template>
  
  
  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[flash.utils::IDataOutput]]></template>
  <template key="write.method"><![CDATA[
  (#tab)public function write(output:IDataOutput):(#type)
  (#tab){(#body)
  (#tab)(#tab)return this;
  (#tab)}
  ]]></template>
  <template key="write.int8"><![CDATA[output.writeByte((#name));]]></template>
  <template key="write.int16"><![CDATA[output.writeShort((#name));]]></template>
  <template key="write.int32"><![CDATA[output.writeInt((#name));]]></template>
  <template key="write.int64"><![CDATA[output.writeLong((#name));]]></template>
  <template key="write.uint8"><![CDATA[output.writeByte((#name));]]></template>
  <template key="write.uint16"><![CDATA[output.writeShort((#name));]]></template>
  <template key="write.uint32"><![CDATA[output.writeInt((#name).intValue());]]></template>
  <template key="write.uint64"><![CDATA[output.writeLong((#name));]]></template>
  <template key="write.float"><![CDATA[output.writeFloat((#name));]]></template>
  <template key="write.double"><![CDATA[output.writeDouble((#name));]]></template>
  <template key="write.string"><![CDATA[output.writeUTF((#name));]]></template>
  <template key="write.bool"><![CDATA[output.writeBoolean((#name));]]></template>
  <template key="write.enum"><![CDATA[output.writeInt((#name).getValue());]]></template>
  <template key="write.struct"><![CDATA[(#name).write(output);]]></template>
  <template key="write.struct.check"><![CDATA[
  if ((#name) != null)
  {
  (#tab)output.writeByte(0x01);
  (#tab)(#name).write(output);
  }
  else
  {
  (#tab)output.writeByte(0x00);
  }
  ]]></template>
  <template key="write.size.init"><![CDATA[(#name).Count]]></template>
  <template key="write.vec.for"><![CDATA[
  Integer (#len) = (#name).size();
  output.writeInt((#len));
  for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++)
  {(#body)
  }
  ]]></template>
  <template key="write.map.keys"><![CDATA[Keys]]></template>
  <template key="write.map.for"><![CDATA[
  Integer (#len) = (#nameupper).size();
  output.writeInt((#len));
  for ((#type) (#name) : (#nameupper).keySet())
  {(#body)
  }
  ]]></template>
  
  
  <!-- Output data to xml -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method"><![CDATA[
  (#tab)public function ToXML(nodeName:String):(#type)
  (#tab){
  (#tab)(#tab)//StringBuilder code = new StringBuilder();
  (#body)
  (#tab)(#tab)return "";
  (#tab)}
  ]]></template>
</tns:root>