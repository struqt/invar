<?xml version="1.0" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="java">
  <export resPath="res/java/InvarReadData.txt" destDir="invar" destName="InvarReadData.java"/>
  <export resPath="res/java/InvarRule.txt" destDir="invar" destName="InvarRule.java"/>

  <!-- Redefine 14 Invar buildin types to adapt Java language -->
  <!-- & &amp; < &lt; > &gt; " &quot; ' &apos; -->
  <redefine>
    <int8 pack="   java.lang" type="Byte   " initValue="-1"/>
    <int16 pack="  java.lang" type="Short  " initValue="-1"/>
    <int32 pack="  java.lang" type="Integer" initValue="-1"/>
    <int64 pack="  java.lang" type="Long   " initValue="-1"/>
    <uint8 pack="  java.lang" type="Integer" initValue="0"/>
    <uint16 pack=" java.lang" type="Integer" initValue="0"/>
    <uint32 pack=" java.lang" type="Long   " initValue="0"/>
    <uint64 pack=" java.lang" type="Long   " initValue="0"/>
    <float pack="  java.lang" type="Float  " initValue="0.0"/>
    <double pack=" java.lang" type="Double " initValue="0.00"/>
    <string pack=" java.lang" type="String " initValue=""/>
    <bool pack="   java.lang" type="Boolean" initValue="false"/>
    <vec pack="    java.util" type="LinkedList   " generic="&lt;?&gt;"/>
    <map pack="    java.util" type="LinkedHashMap" generic="&lt;?,?&gt;"/>
    <dialect pack="java.util" type="Map"/>
    <dialect pack="java.io" type="DataOutput"/>
    <dialect pack="java.io" type="DataInput"/>
    <dialect pack="java.io" type="IOException"/>
  </redefine>
  <template key="trace.all.types">     <![CDATA[false]]></template>
  <template key="include.self">        <![CDATA[false]]></template>
  <template key="pack.name.nested">    <![CDATA[false]]></template>
  <template key="file.name.lowercase"> <![CDATA[false]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num">   <![CDATA[1]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[false]]></template>
  <template key="code.dir.prefix">     <![CDATA[]]></template>
  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg);]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null">  <![CDATA[null]]></template>
  <template key="pointer.copy">  <![CDATA[(#name) = (#arg);]]></template>
  <template key="byte.yes">      <![CDATA[(byte)0x01]]></template>
  <template key="byte.non">      <![CDATA[(byte)0x00]]></template>
  <template key="init.any">    <![CDATA[ (#deft)        ]]></template>
  <template key="init.int64">  <![CDATA[ (#deft)L       ]]></template>
  <template key="init.uint32"> <![CDATA[ (#deft)L       ]]></template>
  <template key="init.uint64"> <![CDATA[ (#deft)L       ]]></template>
  <template key="init.float">  <![CDATA[ (#deft)F       ]]></template>
  <template key="init.string"> <![CDATA[ "(#deft)"      ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name)]]></template>
  <template key="init.struct"> <![CDATA[ new (#type)()  ]]></template>
  <template key="init.vec">    <![CDATA[ new (#type)()  ]]></template>
  <template key="init.map">    <![CDATA[ new (#type)()  ]]></template>
  <template key="file"><![CDATA[
	//===----------------------------*  Java  *---------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===//
    (#blank)
    (#pack)
  ]]></template>
  <template key="file.pack"><![CDATA[
	package (#name);
	(#body)
  ]]></template>
  <template key="file.body"><![CDATA[
    (#blank)
    (#import)
    (#enums)(#structs)]]></template>
  <template key="import"><![CDATA[import (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)(#name)]]></template>
  <template key="import.split"><![CDATA[.]]></template>
  <template key="import.exclude.conflict"><![CDATA[true]]></template>
  <template key="import.exclude.same.pack"><![CDATA[true]]></template>
  <template key="import.exclude.packs"><![CDATA[java.lang]]></template>
  <template key="doc"><![CDATA[/** (#doc) */]]></template>
  <template key="doc.line"><![CDATA[ //(#doc)]]></template>
  <template key="enum.field"><![CDATA[
    (#brk)(#tab)(#doc)
    (#tab)(#name) ((#value), "(#name)"),]]></template>
  <template key="enum"><![CDATA[
    public enum (#name)
    {(#body);
    (#blank)
    (#tab)public String  getName  () { return name; }
    (#tab)public Integer getValue () { return value; }
    (#tab)public String  toString () { return name + "(" + value + ")"; }
    (#blank)
    (#tab)private String  name;
    (#tab)private Integer value;
    (#blank)
    (#tab)(#name)(Integer v, String n)
    (#tab){
    (#tab)(#tab)this.name = n;
    (#tab)(#tab)this.value = v;
    (#tab)}
    (#blank)
    (#tab)static public (#name) valueOf(Integer v)
    (#tab){
    (#tab)(#tab)(#name)[] es = (#name).values();
    (#tab)(#tab)for ((#name) e : es)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)if(e.getValue() == v)
    (#tab)(#tab)(#tab)(#tab)return e;
    (#tab)(#tab)}
    (#tab)(#tab)return es[0];
    (#tab)}
    }
  ]]></template>
  <template key="struct"><![CDATA[
    [#addImport(struct; imports; java.io::DataInput)]
    [#addImport(struct; imports; java.io::DataOutput)]
    [#addImport(struct; imports; java.io::IOException)]
    (#concat)
    final public class (#name)
    {
    [#codeFields (struct; fields)]
    [#codeGetters(struct; fields)]
    [#codeSetters(struct; fields)]
    [#codeNested (reuse.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (copy.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (write.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (tostr.; useFullName; struct; fields; imports)](#brk)
    }
	]]></template>
  <template key="struct.meta"><![CDATA[@invar.InvarRule(T="(#type)", S="f(#index)")]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#clampLen(lenFieldName; 16; (#name) )] = (#value);
    (#concat)[#codeLineDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#typeupper) set[#upperHeadChar( (#name) )]((#type) value) {this.(#name) = value; return this;}
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#type) get[#upperHeadChar( (#name) )]() {return (#name);}
  ]]></template>

  <!-- Method Reuse -->
  <template key="reuse.method.arg"><![CDATA[]]></template>
  <template key="reuse.method"><![CDATA[ (#tab)public (#type) reuse()
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)} //reuse() ]]></template>
  <template key="reuse.any">   <![CDATA[ [#clampLen(lenFieldName; 16; (#name))] = (#deft) ]]></template>
  <template key="reuse.struct"><![CDATA[ (#name).reuse() ]]></template>
  <template key="reuse.vec | reuse.map"><![CDATA[ (#name).clear() ]]></template>
  <template key="reuse.ref.any"><![CDATA[ (#body); ]]></template>
  <template key="reuse.ptr.any"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#name) = (#deft);
    }]]></template>
  <template key="reuse.ptr.struct | reuse.ptr.vec | reuse.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#body);
    }]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[from]]></template>
  <template key="copy.method"><![CDATA[ (#tab)public (#type) copy ((#type) from)
    (#tab){
      (#tab)(#tab)if (this == from || from == (#null)) {
      (#tab)(#tab)(#tab)return this;
      (#tab)(#tab)}(#body)
      (#tab)(#tab)return this;
    (#tab)} //copyFrom(...)]]></template>
  <template key="copy.any"><![CDATA[ (#arg)(#split)(#name) ]]></template>
  <template key="copy.vec"><![CDATA[ (#name).addAll((#arg)(#split)(#name)) ]]></template>
  <template key="copy.map"><![CDATA[ (#name).putAll((#arg)(#split)(#name)) ]]></template>
  <template key="copy.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="copy.ref.vec|copy.ref.map"><![CDATA[ (#name).clear();
    (#body); ]]></template>
  <template key="copy.ptr.any"><![CDATA[ (#name) = (#body);  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if ((#arg).(#name) != (#null)) {
    (#tab)(#name).copy((#body));
    } else {
    (#tab)(#name) = (#null);
    }
  ]]></template>
  <template key="copy.ptr.vec|copy.ptr.map"><![CDATA[
    if ((#arg).(#name) != (#null)) {
    (#tab)(#name).clear();
    (#tab)(#body);
    } else {
    (#tab)(#name) = (#null);
    }
  ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[java.io::DataInput,java.io::IOException]]></template>
  <template key="read.method.arg"><![CDATA[from]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public (#type) read (DataInput from) throws IOException
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)}]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).readByte()    ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).readShort()   ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).readInt()     ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).readLong()    ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).readUnsignedByte()  ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).readUnsignedShort() ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).readInt() & 0xFFFFFFFFL ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).readLong()    ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).readFloat()   ]]></template>
  <template key="read.double"><![CDATA[ (#arg).readDouble()  ]]></template>
  <template key="read.string"><![CDATA[ (#arg).readUTF()     ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).readBoolean() ]]></template>
  <template key="read.enum">  <![CDATA[ (#type).valueOf((#arg).readInt()) ]]></template>
  <template key="read.struct"><![CDATA[ (#name).read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) (#name) = new (#type)();(#brk)(#body); ]]></template>
  <template key="read.vec.head">  <![CDATA[(#type) (#name) = new (#type)(); //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    Long (#len) = (#arg).readInt() & 0xFFFFFFFFL;
    for ((#sizetype) (#index) = 0L; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name).add((#value));
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[(#type) (#name) = new (#type)(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    Long (#len) = (#arg).readInt() & 0xFFFFFFFFL;
    for ((#sizetype) (#index) = 0L; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name).put((#key),(#value));
    }
  ]]></template>
  <template key="read.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec"><![CDATA[ (#name).clear();(#brk)(#body) ]]></template>
  <template key="read.ref.map"><![CDATA[ (#name).clear();(#brk)(#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    if ((#arg).readByte() == (#byteyes)) {
    (#tab)(#name) = (#body);
    }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    if ((#arg).readByte() == (#byteyes)) {
    (#tab)(#body);
    }
  ]]></template>
  <template key="read.ptr.vec|read.ptr.map"><![CDATA[
    (#name).clear();
    if ((#arg).readByte() == (#byteyes)) {(#bodyindent)
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[]]></template>
  <template key="write.method.arg"><![CDATA[dest]]></template>
  <template key="write.method"><![CDATA[ (#tab)public (#type) write (DataOutput dest) throws IOException
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)}]]></template>
  <template key="write.int8">  <![CDATA[ (#arg).writeByte((#name))  ]]></template>
  <template key="write.int16"> <![CDATA[ (#arg).writeShort((#name)) ]]></template>
  <template key="write.int32"> <![CDATA[ (#arg).writeInt((#name))   ]]></template>
  <template key="write.int64"> <![CDATA[ (#arg).writeLong((#name))  ]]></template>
  <template key="write.uint8"> <![CDATA[ (#arg).writeByte((#name))  ]]></template>
  <template key="write.uint16"><![CDATA[ (#arg).writeShort((#name)) ]]></template>
  <template key="write.uint32"><![CDATA[ (#arg).writeInt((#name).intValue()) ]]></template>
  <template key="write.uint64"><![CDATA[ (#arg).writeLong((#name))  ]]></template>
  <template key="write.float"> <![CDATA[ (#arg).writeFloat((#name)) ]]></template>
  <template key="write.double"><![CDATA[ (#arg).writeDouble((#name))]]></template>
  <template key="write.string"><![CDATA[ (#arg).writeUTF((#name))   ]]></template>
  <template key="write.bool">  <![CDATA[ (#arg).writeBoolean((#name)) ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).writeInt((#name).getValue()) ]]></template>
  <template key="write.struct"><![CDATA[ (#name).write((#arg)) ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body);]]></template>
  <template key="write.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)(#body);]]></template>
  <template key="write.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)(#body);]]></template>
  <template key="write.vec.head"><![CDATA[]]></template>
  <template key="write.vec.for"><![CDATA[ (#arg).writeInt((#name).size());
    for ((#typer) (#value) : (#name)) {(#body)
    } ]]></template>
  <template key="write.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)]]></template>
  <template key="write.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)]]></template>
  <template key="write.map.for"><![CDATA[ (#arg).writeInt((#name).size());
    for (Map.Entry<(#typer)> (#name)Iter : (#name).entrySet()) {(#body)
    }[#addImport(struct; imports; java.util::Map)] ]]></template>
  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).writeByte((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).writeByte((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).writeByte((#byteyes));(#bodyindent)
    } else {
    (#tab)(#arg).writeByte((#bytenon));
    }
  ]]></template>


  <!-- To XML String -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method.arg"><![CDATA[name]]></template>
  <template key="toxml.method"><![CDATA[ (#tab)public String toStringXml (String name)
    (#tab){
    (#tab)(#tab)StringBuilder result = new StringBuilder();
    (#tab)(#tab)StringBuilder attrs  = new StringBuilder();
    (#tab)(#tab)StringBuilder nodes  = new StringBuilder();(#body)
    (#tab)(#tab)result.append("<"); result.append(name); result.append(attrs);
    (#tab)(#tab)if (nodes.length() == 0) {
    (#tab)(#tab)(#tab)result.append("/>");
    (#tab)(#tab)} else {
    (#tab)(#tab)(#tab)result.append(">");
    (#tab)(#tab)(#tab)result.append(nodes);
    (#tab)(#tab)(#tab)result.append("</"); result.append(name); result.append(">");
    (#tab)(#tab)}
    (#tab)(#tab)return result.toString();
    (#tab)} //(#type)::toStringXml (String name) ]]></template>
  <template key="toxml.any">   <![CDATA[ (#name).toString() ]]></template>
  <template key="toxml.string"><![CDATA[ (#name) ]]></template>
  <template key="toxml.struct"><![CDATA[ (#name).toStringXml("(#name)") ]]></template>
  <template key="toxml.nest.n.struct"><![CDATA[ nodes.append((#body)); ]]></template>
  <template key="toxml.nest.k.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();
    nodes.append((#body)); ]]></template>
  <template key="toxml.nest.v.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();
    nodes.append((#body)); ]]></template>
  <template key="toxml.nest.n"><![CDATA[
    nodes.append("<(#name) value=\\"");
    nodes.append((#body));
    nodes.append("\\">"); ]]></template>
  <template key="toxml.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();
    nodes.append("<(#name) value=\\"");
    nodes.append((#body));
    nodes.append("\\">"); ]]></template>
  <template key="toxml.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();
    nodes.append("<(#name) value=\\"");
    nodes.append((#body));
    nodes.append("\\">"); ]]></template>
  <template key="toxml.vec.head"><![CDATA[]]></template>
  <template key="toxml.vec.for"><![CDATA[
    nodes.append("<(#name)>");
    for ((#typer) (#value) : (#name)) {(#body)
    }
    nodes.append("</(#name)>");
  ]]></template>
  <template key="toxml.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getKey();(#brk)]]></template>
  <template key="toxml.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.getValue();(#brk)]]></template>
  <template key="toxml.map.for"><![CDATA[
    nodes.append("<(#name)>");
    for (Map.Entry<(#typer)> (#name)Iter : (#name).entrySet()) {(#body)
    }[#addImport(struct; imports; java.util::Map)]
    nodes.append("</(#name)>");
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[ attrs.append(" (#name)=\\"");
    attrs.append((#body)); attrs.append("\\""); ]]></template>
  <template key="toxml.ref.struct"><![CDATA[ nodes.append((#body)); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if ((#name).size() > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)attrs.append(" (#name)=\\"");
    (#tab)attrs.append((#body)); attrs.append("\\"");
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)nodes.append((#body));
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if ((#name) != (#null) && (#name).size() > 0) {(#bodyindent)
    }]]></template>


  <!-- To String -->
  <template key="tostr.import"><![CDATA[]]></template>
  <template key="tostr.method.arg"><![CDATA[]]></template>
  <template key="tostr.method"><![CDATA[ (#tab)public String toString ()
    (#tab){
    (#tab)(#tab)StringBuilder result = new StringBuilder();
    (#tab)(#tab)result.append("{ ");
    (#tab)(#tab)result.append(getClass().getName());(#body)
    (#tab)(#tab)result.append(" }");
    (#tab)(#tab)return result.toString();
    (#tab)} //(#type)::toString () ]]></template>
  <template key="tostr.any">   <![CDATA[ (#name).toString() ]]></template>
  <template key="tostr.struct"><![CDATA[ "<(#type)>" ]]></template>
  <template key="tostr.vec">   <![CDATA[ "(" + (#name).size() + ")" ]]></template>
  <template key="tostr.map">   <![CDATA[ "[" + (#name).size() + "]" ]]></template>
  <template key="tostr.string"><![CDATA[ "\\"" + (#name) + "\\"" ]]></template>
  <template key="tostr.ref.any"><![CDATA[ result.append(", (#name):");
    result.append((#body)); ]]></template>
  <template key="tostr.ptr.any"><![CDATA[ result.append(", (#name):");
    if ((#name) != (#null)) {
      (#tab)result.append((#body));
    } else {
      (#tab)result.append("null");
    } ]]></template>

  <!-- InvarRuntime Class -->
  <template key="runtime.pack"><![CDATA[invar]]></template>
  <template key="runtime.name"><![CDATA[InvarRuntime]]></template>
  <template key="runtime.alias"><![CDATA[
    (#tab)static private LinkedHashMap<String,Class<?>> (#name) ()
    (#tab){
    (#tab)(#tab)LinkedHashMap<String,Class<?>> map = new LinkedHashMap<String,Class<?>>();(#body)
    (#tab)(#tab)return map;
    (#tab)}
  ]]></template>
  <template key="runtime.alias.basic"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.list"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.alias.map"><![CDATA[(#brk)(#tab)(#tab)map.put("(#name)", (#type).class);]]></template>
  <template key="runtime.body"><![CDATA[
    package invar;
    (#blank)
    (#import)
    final public class InvarRuntime
    {
    (#tab)static public InvarReadData MakeXmlReader()
    (#tab){
    (#tab)(#tab)if (InvarReadData.aliasBasics == null)
    (#tab)(#tab){
    (#tab)(#tab)(#tab)InvarReadData.aliasBasics = aliasBasic();
    (#tab)(#tab)(#tab)InvarReadData.aliasEnums = aliasEnum();
    (#tab)(#tab)(#tab)InvarReadData.aliasStructs = aliasStruct();
    (#tab)(#tab)}
    (#tab)(#tab) return new InvarReadData();
    (#tab)}
    (#body)
    }
  ]]></template>
</tns:root>