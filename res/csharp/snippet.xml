<?xml version="1.0" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
          xmlns:tns="invar.template" language="csharp">

  <export resPath="csharp/InvarReadData.cs" destDir="Invar" destName="InvarReadData.cs"/>
  <export resPath="csharp/InvarRule.cs" destDir="Invar" destName="InvarRule.cs"/>

  <!-- Redefine 14 Invar buildin types to adapt C# language -->
  <redefine>
    <int8 pack="System" type="SByte" initValue="-1"/>
    <int16 pack="System" type="Int16" initValue="-1"/>
    <int32 pack="System" type="Int32" initValue="-1"/>
    <int64 pack="System" type="Int64" initValue="-1"/>
    <uint8 pack="System" type="Byte" initValue="0"/>
    <uint16 pack="System" type="UInt16" initValue="0"/>
    <uint32 pack="System" type="UInt32" initValue="0"/>
    <uint64 pack="System" type="UInt64" initValue="0"/>
    <float pack="System" type="Single" initValue="0.0"/>
    <double pack="System" type="Double" initValue="0.00"/>
    <string pack="System" type="String" initValue=""/>
    <bool pack="System" type="Boolean" initValue="false"/>
    <vec pack="System.Collections.Generic" type="List" generic="&lt;?&gt;"/>
    <map pack="System.Collections.Generic" type="Dictionary" generic="&lt;?,?&gt;"/>
    <dialect pack="System.IO" type="BinaryReader"/>
    <dialect pack="System.IO" type="BinaryWriter"/>
    <dialect pack="System.Text" type="StringBuilder"/>
    <dialect pack="System.Text" type="Encoding"/>
  </redefine>

  <!-- Common snippet -->
  <template key="include.self">        <![CDATA[false]]></template>
  <template key="pack.name.nested">    <![CDATA[false]]></template>
  <template key="file.name.lowercase"> <![CDATA[false]]></template>
  <template key="capitalize.pack.head"><![CDATA[true]]></template>
  <template key="method.indent.num">   <![CDATA[1]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[false]]></template>
  <template key="code.dir.prefix">     <![CDATA[]]></template>
  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg);]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null">  <![CDATA[null]]></template>
  <template key="pointer.copy">  <![CDATA[(#name) = (#arg);]]></template>
  <template key="byte.yes">      <![CDATA[(sbyte)0x01]]></template>
  <template key="byte.non">      <![CDATA[(sbyte)0x00]]></template>

  <template key="init.any">    <![CDATA[ (#deft)        ]]></template>
  <template key="init.int64">  <![CDATA[ (#deft)L       ]]></template>
  <template key="init.uint64"> <![CDATA[ (#deft)L       ]]></template>
  <template key="init.float">  <![CDATA[ (#deft)F       ]]></template>
  <template key="init.string"> <![CDATA[ "(#deft)"      ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name)]]></template>
  <template key="init.struct"> <![CDATA[ new (#type)()  ]]></template>
  <template key="init.vec">    <![CDATA[ new (#type)()  ]]></template>
  <template key="init.map">    <![CDATA[ new (#type)()  ]]></template>

  <template key="file"><![CDATA[
    //===-----------------------------*  C#  *---------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===//
    (#blank)
    (#pack)]]></template>

  <template key="file.pack"><![CDATA[
	namespace (#name) {
    (#body)} //namespace: (#name)]]></template>

  <template key="file.body"><![CDATA[
    (#import)(#enums)(#structs)]]></template>


  <template key="doc"><![CDATA[/// (#doc).]]></template>
  <template key="doc.line"><![CDATA[ (#space)//(#doc).]]></template>
  <template key="import"><![CDATA[using (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[.]]></template>
  <template key="init.struct"><![CDATA[new (#type)()]]></template>
  <template key="init.enum"><![CDATA[(#type).(#name)]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[(#type) (#name);(#brk)]]></template>

  <template key="pack"><![CDATA[
   		// THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
   		(#import)
   		namespace (#name) {
	 		(#body)} // namespace (#name)
	]]></template>
  <template key="enum"><![CDATA[
	    (#brk)(#doc)
		public enum (#name) : int
		{
			(#body)
		} // enum (#name)
	]]></template>
  <template key="enum.field"><![CDATA[
		(#brk)(#tab)(#doc)
		(#tab)(#name) = (#value),
	]]></template>
  <template key="struct"><![CDATA[
	[#addImport(struct; imports; System.IO::BinaryReader)]
    [#addImport(struct; imports; System.IO::BinaryWriter)]
    [#addImport(struct; imports; System.Text::StringBuilder)]
    [#addImport(struct; imports; System::String)]
    (#concat)
    public sealed class (#name)
    {
    (#tab)public const uint CRC32 = 0x[#codeCRC32(struct)];(#brk)
    [#codeFields (struct; fields)]
    [#codeGetters(struct; fields)]
    [#codeSetters(struct; fields)]
    [#codeNested (reuse.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (copy.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (write.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (tostr.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (tophp.; useFullName; struct; fields; imports)](#brk)
    } //class: (#name)
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#clampLen(lenFieldName; 16; (#name) )] = (#value);
    (#concat)[#codeLineDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#typeupper) Set[#upperHeadChar( (#name) )]((#type) value) { this.(#name) = value; return this; }
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#type) Get[#upperHeadChar( (#name) )]() { return (#name); }
  ]]></template>

  <!-- Method Reuse -->
  <template key="reuse.method.arg"><![CDATA[]]></template>
  <template key="reuse.method"><![CDATA[ (#tab)public (#type) Reuse()
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)} //(#type)::Reuse() ]]></template>
  <template key="reuse.any">   <![CDATA[ [#clampLen(lenFieldName; 16; (#name))] = (#deft) ]]></template>
  <template key="reuse.struct"><![CDATA[ (#name).Reuse() ]]></template>
  <template key="reuse.vec | reuse.map"><![CDATA[ (#name).Clear() ]]></template>
  <template key="reuse.ref.any"><![CDATA[ (#body); ]]></template>
  <template key="reuse.ptr.any"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#name) = (#deft);
    } ]]></template>
  <template key="reuse.ptr.struct | reuse.ptr.vec | reuse.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#body);
    } ]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[from]]></template>
  <template key="copy.method"><![CDATA[ (#tab)public (#type) Copy ((#type) from)
    (#tab){
      (#tab)(#tab)if (this == from || from == (#null)) {
      (#tab)(#tab)(#tab)return this;
      (#tab)(#tab)}(#body)
      (#tab)(#tab)return this;
    (#tab)} //(#type)::Copy(...)]]></template>
  <template key="copy.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="copy.ref.vec|copy.ref.map"><![CDATA[ (#name).Clear();
    (#body); ]]></template>
  <template key="copy.ptr.any"><![CDATA[ (#name) = (#body);  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if ((#arg).(#name) != (#null)) {
    (#tab)(#name).Copy((#body));
    } else {
    (#tab)(#name) = (#null);
    }
  ]]></template>
  <template key="copy.ptr.vec|copy.ptr.map"><![CDATA[
    if ((#arg).(#name) != (#null)) {
    (#tab)(#name).Clear();
    (#tab)(#body);
    } else {
    (#tab)(#name) = (#null);
    }
  ]]></template>
  <template key="copy.any"><![CDATA[ (#arg).(#name) ]]></template>
  <template key="copy.vec"><![CDATA[ (#name).AddRange((#arg).(#name)) ]]></template>
  <template key="copy.map"><![CDATA[ foreach (var (#name)Iter in (#arg).(#name)) {
    (#tab)(#name).Add((#name)Iter.Key, (#name)Iter.Value);
    } ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[System.IO::BinaryReader]]></template>
  <template key="read.method.arg"><![CDATA[from_]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public void Read(BinaryReader from_)
    (#tab){(#body)
    (#tab)} ]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).ReadSByte()  ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).ReadInt16()  ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).ReadInt32()  ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).ReadInt64()  ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).ReadByte()   ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).ReadUInt16() ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).ReadUInt32() ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).ReadUInt64() ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).ReadSingle() ]]></template>
  <template key="read.double"><![CDATA[ (#arg).ReadDouble() ]]></template>
  <template key="read.string"><![CDATA[ Encoding.UTF8.GetString((#arg).ReadBytes((#arg).ReadInt32())) ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).ReadBoolean()]]></template>
  <template key="read.enum">  <![CDATA[ ((#type))Enum.ToObject(typeof((#type)), (#arg).ReadInt32()) ]]></template>
  <template key="read.struct"><![CDATA[ (#name).Read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) (#name) = new (#type)();(#brk)(#body); ]]></template>
  <template key="read.vec.head">  <![CDATA[(#type) (#name) = new (#type)(); //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++)
    {(#body)
    (#tab)(#name).Add((#value));
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[(#type) (#name) = new (#type)(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++)
    {(#body)
    (#tab)if (!(#name).ContainsKey((#key))) {
    (#tab)(#tab)(#name).Add((#key), (#value));
    (#tab)} else {
    (#tab)(#tab)(#name)[(#key)] = (#value);
    (#tab)}
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec">   <![CDATA[ (#body) ]]></template>
  <template key="read.ref.map">   <![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    if ((#arg).ReadSByte() == (#byteyes)) {
    (#tab)(#name) = (#body);
    }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    if ((#arg).ReadSByte() == (#byteyes)) {
    (#tab)if ((#name) == (#null)) {
    (#tab)(#tab)(#name) = new (#type)();
    (#tab)}
    (#tab)(#body);
    }
  ]]></template>
  <template key="read.ptr.vec|read.ptr.map"><![CDATA[
    if ((#arg).ReadSByte() == (#byteyes)) {
    (#tab)if ((#name) == (#null)) {
    (#tab)(#tab)(#name) = new (#type)();
    (#tab)} else {
    (#tab)}(#bodyindent)
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[System.IO::BinaryWriter]]></template>
  <template key="write.method.arg"><![CDATA[dest]]></template>
  <template key="write.method"><![CDATA[
    (#tab)public void Write(BinaryWriter dest)
    (#tab){(#body)
    (#tab)} ]]></template>
  <template key="write.any">   <![CDATA[ (#arg).Write((#name)) ]]></template>
  <template key="write.string">   <![CDATA[
  byte[] (#name)Bytes = Encoding.UTF8.GetBytes((#name));
  (#arg).Write((#name)Bytes.Length);
  (#arg).Write((#name)Bytes)[#addImport(struct; imports; System.Text::Encoding)] ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).Write((Int32)(#name)) ]]></template>
  <template key="write.struct"><![CDATA[ (#name).Write((#arg)) ]]></template>
  <template key="write.vec.for"><![CDATA[
    (#arg).Write((#name).Count);
    foreach ((#typer) (#value) in (#name))
    {(#body)
    }
  ]]></template>
  <template key="write.map.for"><![CDATA[
    (#arg).Write((#name).Count);
    foreach (KeyValuePair<(#typer)> (#name)Iter in (#name))
    {(#body)
    }
  ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body);]]></template>
  <template key="write.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)(#body);]]></template>
  <template key="write.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)(#body);]]></template>
  <template key="write.vec.head"><![CDATA[]]></template>
  <template key="write.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="write.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));(#bodyindent)
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>

  <!-- To XML String -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method.arg"><![CDATA[name]]></template>
  <template key="toxml.method"><![CDATA[ (#tab)public String ToStringXml (String name)
    (#tab){
    (#tab)(#tab)StringBuilder result = new StringBuilder();
    (#tab)(#tab)StringBuilder attrs  = new StringBuilder();
    (#tab)(#tab)StringBuilder nodes  = new StringBuilder();(#body)
    (#tab)(#tab)result.Append("<"); result.Append(name); result.Append(attrs);
    (#tab)(#tab)if (nodes.Length == 0) {
    (#tab)(#tab)(#tab)result.Append("/>");
    (#tab)(#tab)} else {
    (#tab)(#tab)(#tab)result.Append(">");
    (#tab)(#tab)(#tab)result.Append(nodes);
    (#tab)(#tab)(#tab)result.Append("</"); result.Append(name); result.Append(">");
    (#tab)(#tab)}
    (#tab)(#tab)return result.ToString();
    (#tab)} //(#type)::ToStringXml (String name) ]]></template>
  <template key="toxml.any">   <![CDATA[ (#name).ToString() ]]></template>
  <template key="toxml.string"><![CDATA[ (#name) ]]></template>
  <template key="toxml.struct"><![CDATA[ (#name).ToStringXml("(#name)") ]]></template>
  <template key="toxml.nest.n.struct"><![CDATA[ nodes.Append((#body)); ]]></template>
  <template key="toxml.nest.k.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;
    nodes.Append((#body)); ]]></template>
  <template key="toxml.nest.v.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;
    nodes.Append((#body)); ]]></template>
  <template key="toxml.nest.n"><![CDATA[
    nodes.Append("<(#name) value=\\"");
    nodes.Append((#body));
    nodes.Append("\\">"); ]]></template>
  <template key="toxml.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;
    nodes.Append("<(#name) value=\\"");
    nodes.Append((#body));
    nodes.Append("\\">"); ]]></template>
  <template key="toxml.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;
    nodes.Append("<(#name) value=\\"");
    nodes.Append((#body));
    nodes.Append("\\">"); ]]></template>
  <template key="toxml.vec.head"><![CDATA[]]></template>
  <template key="toxml.vec.for"><![CDATA[
    nodes.Append("<(#name)>");
    foreach ((#typer) (#value) in (#name)) {(#body)
    }
    nodes.Append("</(#name)>");
  ]]></template>
  <template key="toxml.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="toxml.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="toxml.map.for"><![CDATA[
    nodes.Append("<(#name)>");
    foreach (KeyValuePair<(#typer)> (#name)Iter in (#name)) {(#body)
    }
    nodes.Append("</(#name)>");
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[ attrs.Append(" (#name)=\\"");
    attrs.Append((#body)); attrs.Append("\\""); ]]></template>
  <template key="toxml.ref.struct"><![CDATA[ nodes.Append((#body)); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if ((#name).Count > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)attrs.Append(" (#name)=\\"");
    (#tab)attrs.Append((#body)); attrs.Append("\\"");
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)nodes.Append((#body));
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if ((#name) != (#null) && (#name).Count > 0) {(#bodyindent)
    }]]></template>


  <!-- To String -->
  <template key="tostr.import"><![CDATA[]]></template>
  <template key="tostr.method.arg"><![CDATA[]]></template>
  <template key="tostr.method"><![CDATA[ (#tab)public override String ToString ()
    (#tab){
    (#tab)(#tab)StringBuilder result = new StringBuilder();
    (#tab)(#tab)result.Append("{ ");
    (#tab)(#tab)result.Append(GetType().ToString());(#body)
    (#tab)(#tab)result.Append(" }");
    (#tab)(#tab)return result.ToString();
    (#tab)} //(#type)::ToString () ]]></template>
  <template key="tostr.any">   <![CDATA[ (#name).ToString() ]]></template>
  <template key="tostr.struct"><![CDATA[ "<(#type)>" ]]></template>
  <template key="tostr.vec">   <![CDATA[ "(" + (#name).Count + ")" ]]></template>
  <template key="tostr.map">   <![CDATA[ "[" + (#name).Count + "]" ]]></template>
  <template key="tostr.string"><![CDATA[ "\\"" + (#name) + "\\"" ]]></template>
  <template key="tostr.ref.any"><![CDATA[ result.Append(", (#name):");
    result.Append((#body)); ]]></template>
  <template key="tostr.ptr.any"><![CDATA[ result.Append(", (#name):");
    if ((#name) != (#null)) {
      (#tab)result.Append((#body));
    } else {
      (#tab)result.Append("null");
    } ]]></template>

  <template key="runtime.pack"><![CDATA[Invar]]></template>
  <template key="runtime.name"><![CDATA[InvarRuntime]]></template>
  <template key="runtime.alias"><![CDATA[
    (#tab)static private Dictionary<String,Type> (#name) ()
    (#tab){
    (#tab)(#tab)Dictionary<String,Type> map = new Dictionary<String,Type>();(#body)
    (#tab)(#tab)return map;
    (#tab)}
  ]]></template>
  <template key="runtime.alias.basic"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#typefull)));]]></template>
  <template key="runtime.alias.list"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#type)<>));]]></template>
  <template key="runtime.alias.map"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#type)<,>));]]></template>
  <template key="runtime.body"><![CDATA[
    namespace Invar {
    (#blank)
    (#import)
    public sealed class InvarRuntime
    {
    (#tab)static public InvarReadData MakeXmlReader ()
    (#tab){
    (#tab)(#tab)if (InvarReadData.AliasBasics == null) {
    (#tab)(#tab)(#tab)InvarReadData.AliasBasics = aliasBasic ();
    (#tab)(#tab)(#tab)InvarReadData.AliasEnums = aliasEnum ();
    (#tab)(#tab)(#tab)InvarReadData.AliasStructs = aliasStruct ();
    (#tab)(#tab)}
    (#tab)(#tab) return new InvarReadData ();
    (#tab)}
    (#body)
    }
    }
  ]]></template>

  <!-- Write data to PHP script -->
  <template key="tophp.import">      <![CDATA[ System.Text::StringBuilder ]]></template>
  <template key="tophp.method.arg">  <![CDATA[ s ]]></template>
  <template key="tophp.method"><![CDATA[
    (#tab)public StringBuilder ToStringPHP()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)code.Append("<?php "); (#tab)(#tab)code.Append("/* CRC32: 0x");
    (#tab)(#tab)code.Append(CRC32.ToString("X2")); code.Append(" */"); code.Append('\\n');
    (#tab)(#tab)code.Append('\\n'); code.Append("return ");
    (#tab)(#tab)this.WritePHP(code); code.Append(';'); code.Append('\\n');
    (#tab)(#tab)return code;
    (#tab)}(#brk)
    (#tab)public void WritePHP(StringBuilder s)
    (#tab){
    (#tab)(#tab)s.Append("array("); s.Append('\\n');
    (#tab)(#tab)int offset = s.Length;(#body)
    (#tab)(#tab)s.Append("/* "); s.Append(GetType().ToString()); s.Append(" */");
    (#tab)(#tab)s.Append(")");
    (#tab)} ]]></template>

  <template key="tophp.any"> <![CDATA[ (#arg).Append((#name).ToString()) ]]></template>
  <template key="tophp.enum">
    <![CDATA[ (#arg).Append((int)(#name)); (#arg).Append("/*(#type)::"); (#arg).Append((#name).ToString()); (#arg).Append("*/") ]]></template>
  <template key="tophp.string">
    <![CDATA[ (#arg).Append("'"); (#arg).Append((#name).ToString()); (#arg).Append("'") ]]></template>
  <template key="tophp.struct"><![CDATA[ (#name).WritePHP((#arg)) ]]></template>
  <template key="tophp.vec.for"><![CDATA[
    int (#name)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#name)Size > 0) {
    (#tab)(#arg).Append("array("); (#arg).Append('\\n');
    (#tab)int (#name)Idx = 0;
    (#tab)foreach ((#typer) (#value) in (#name)) { /* vec.for: (#name) */
    (#tab)++(#name)Idx;(#body)
    (#tab)if ((#name)Idx != (#name)Size) { (#arg).Append(','); (#arg).Append('\\n'); }
    (#tab)}
    (#tab)(#arg).Append("/* map size: "); (#arg).Append((#name).Count); (#arg).Append(" */"); (#arg).Append(")");
    }
  ]]></template>
  <template key="tophp.map.for"><![CDATA[
    int (#name)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#name)Size > 0) {
    (#tab)(#arg).Append("array("); (#arg).Append('\\n');
    (#tab)int (#name)Idx = 0;
    (#tab)foreach (KeyValuePair<(#typer)> (#name)Iter in (#name)) { /* map.for: (#name) */
    (#tab)++(#name)Idx;(#body)
    (#tab)if ((#name)Idx != (#name)Size) { (#arg).Append(','); (#arg).Append('\\n'); }
    (#tab)}
    (#tab)(#arg).Append("/* map size: "); (#arg).Append((#name).Count); (#arg).Append(" */"); (#arg).Append(")");
    }
  ]]></template>

  <template key="tophp.ref.any"><![CDATA[ (#arg).Append("'(#name)'=>"); (#body);(#brk) ]]></template>
  <template key="tophp.ref.vec | tophp.ref.map"><![CDATA[
    if ((#name)Exsists) { (#arg).Append("'(#name)'=>"); }
    (#body) ]]></template>

  <template key="tophp.map.head.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Key; /* map.head.k */(#brk)]]></template>
  <template key="tophp.map.head.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Value; /* map.head.k */(#brk)]]></template>

  <template key="tophp.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tophp.nest.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Key; /* nest.k */(#brk)(#body); (#arg).Append("=>"); ]]></template>
  <template key="tophp.nest.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Value; /* nest.v */(#brk)(#body); ]]></template>

  <template key="tophp.ptr.string | tophp.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#body);
    }
  ]]></template>
  <template key="tophp.ptr.vec | tophp.ptr.map"><![CDATA[
    if ((#name) != (#null)) {(#bodyindent)
    }
  ]]></template>

  <template key="tophp.field.head.vec | tophp.field.head.map"><![CDATA[
    bool (#name)Exsists = (null != (#name) && (#name).Count > 0); /* field.head.[vec|map]: (#name) */
  ]]></template>
  <template key="tophp.field.space.any"><![CDATA[
    if ((#arg).Length > offset) {
    (#tab)(#arg).Append(','); (#arg).Append('\\n');
    } /* field.space.any: (#name) */
  ]]></template>
  <template key="tophp.field.space.vec | tophp.field.space.map"><![CDATA[
    if ((#name)Exsists && (#arg).Length > offset) {
    (#tab)(#arg).Append(','); (#arg).Append('\\n');
    } /* field.space.[vec|map]: (#name) */
  ]]></template>

</tns:root>
