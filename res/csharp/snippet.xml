<?xml version="1.0" encoding="UTF-8"?>
<tns:root
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="invar.template ../snippet.xsd" xmlns:tns="invar.template" language="csharp">

  <export resPath="csharp/InvarReadData.cs" destDir="Invar" destName="InvarReadData.cs"/>
  <export resPath="csharp/InvarRule.cs" destDir="Invar" destName="InvarRule.cs"/>
  <export resPath="csharp/ProtocHandler.cs" destDir="Invar" destName="ProtocHandler.cs"/>

  <!-- Redefine 14 Invar buildin types to adapt C# language -->
  <redefine>
    <int8 pack="System" type="SByte" initValue="-1"/>
    <int16 pack="System" type="Int16" initValue="-1"/>
    <int32 pack="System" type="Int32" initValue="-1"/>
    <int64 pack="System" type="Int64" initValue="-1"/>
    <uint8 pack="System" type="Byte" initValue="0"/>
    <uint16 pack="System" type="UInt16" initValue="0"/>
    <uint32 pack="System" type="UInt32" initValue="0"/>
    <uint64 pack="System" type="UInt64" initValue="0"/>
    <float pack="System" type="Single" initValue="0.0"/>
    <double pack="System" type="Double" initValue="0.00"/>
    <string pack="System" type="String" initValue=""/>
    <bool pack="System" type="Boolean" initValue="false"/>
    <vec pack="System.Collections.Generic" type="List" generic="&lt;?&gt;"/>
    <map pack="System.Collections.Generic" type="Dictionary" generic="&lt;?,?&gt;"/>
    <dialect pack="System.IO" type="BinaryReader"/>
    <dialect pack="System.IO" type="BinaryWriter"/>
    <dialect pack="System.Text" type="StringBuilder"/>
    <dialect pack="System.Text" type="Encoding"/>
  </redefine>

  <!-- Common snippet -->
  <template key="include.self">            <![CDATA[false]]></template>
  <template key="import.exclude.same.pack"><![CDATA[true]]></template>
  <template key="import.exclude.conflict"> <![CDATA[true]]></template>
  <template key="pack.name.nested">    <![CDATA[false]]></template>
  <template key="file.name.lowercase"> <![CDATA[false]]></template>
  <template key="capitalize.pack.head"><![CDATA[true]]></template>
  <template key="method.indent.num">   <![CDATA[1]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[false]]></template>
  <template key="code.dir.prefix">     <![CDATA[]]></template>
  <template key="refer.spec">    <![CDATA[&]]></template>
  <template key="refer.invoke">  <![CDATA[.]]></template>
  <template key="refer.copy">    <![CDATA[(#name) = (#arg);]]></template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null">  <![CDATA[null]]></template>
  <template key="pointer.copy">  <![CDATA[(#name) = (#arg);]]></template>
  <template key="byte.yes">      <![CDATA[(sbyte)0x01]]></template>
  <template key="byte.non">      <![CDATA[(sbyte)0x00]]></template>

  <template key="init.any">    <![CDATA[ (#deft)        ]]></template>
  <template key="init.int64">  <![CDATA[ (#deft)L       ]]></template>
  <template key="init.uint64"> <![CDATA[ (#deft)L       ]]></template>
  <template key="init.float">  <![CDATA[ (#deft)F       ]]></template>
  <template key="init.string"> <![CDATA[ "(#deft)"      ]]></template>
  <template key="init.enum">   <![CDATA[ (#type).(#name)]]></template>
  <template key="init.struct"> <![CDATA[ new (#type)()  ]]></template>
  <template key="init.vec">    <![CDATA[ new (#type)()  ]]></template>
  <template key="init.map">    <![CDATA[ new (#type)()  ]]></template>

  <template key="file"><![CDATA[
    /*===-----------------------------*  C#  *---------------------------------===//
    //
    //             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
    //
    //===----------------------------------------------------------------------===*/
    (#blank)
    (#pack)]]></template>

  <template key="file.pack"><![CDATA[
	namespace (#name) {
  (#blank)
  (#body)} //namespace: (#name)]]></template>

  <template key="file.body"><![CDATA[
    (#import)
    (#enums)(#structs)]]></template>

  <template key="doc"><![CDATA[/// (#doc).]]></template>
  <template key="doc.line"><![CDATA[ (#space)// (#doc).]]></template>
  <template key="import"><![CDATA[using (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[.]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[(#type) (#name);(#brk)]]></template>

  <template key="enum"><![CDATA[
    (#doc)
		public enum (#name) : int
		{
			(#body)
		} // enum (#name)
	]]></template>
  <template key="enum.field"><![CDATA[
		(#tab)(#name) = (#value),(#doc)
	]]></template>
  <template key="struct"><![CDATA[
	  [#addImport(struct; imports; System.IO::BinaryReader)]
    [#addImport(struct; imports; System.IO::BinaryWriter)]
    [#addImport(struct; imports; System.Text::StringBuilder)]
    [#addImport(struct; imports; System::String)]
    (#blank)
    (#doc)
    public sealed class (#name)
    {
    (#tab)public const uint CRC32 = 0x[#codeCRC32(struct)];(#brk)
    [#codeFields (struct; fields)]
    [#codeGetters(struct; fields)]
    [#codeSetters(struct; fields)]
    [#codeNested (reuse.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (copy.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;   useFullName; struct; fields; imports)](#brk)
    [#codeNested (write.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (tostr.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (tojson.; useFullName; struct; fields; imports)](#brk)
    [#codeNested (tolua.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (tophp.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (toxml.;  useFullName; struct; fields; imports)](#brk)
    } //class: (#name)
    /*
    (#debug)*/
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.prefix"><![CDATA[ this. ]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)private [#clampLen(lenFieldType; 64; (#type))]
    (#concat) [#clampLen(lenFieldNameR; 16; (#name) )] = (#value);
    (#concat)[#codeLineDoc(fields; (#index))]
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#typeupper) Set[#upperHeadChar( (#namer) )]((#type) value) { (#name) = value; return this; }
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#blank)
    (#tab)[#codeDoc(fields; (#index))]
    (#tab)[#codeMetaData(fields; (#index))]
    (#tab)public (#type) Get[#upperHeadChar( (#namer) )]() { return (#name); }
  ]]></template>

  <!-- Method Reuse -->
  <template key="reuse.method.arg"><![CDATA[]]></template>
  <template key="reuse.method"><![CDATA[ (#tab)public (#type) Reuse()
    (#tab){(#body)
    (#tab)(#tab)return this;
    (#tab)} //(#type)::Reuse() ]]></template>
  <template key="reuse.any">   <![CDATA[ [#clampLen(lenFieldName; 16; (#name))] = (#deft) ]]></template>
  <template key="reuse.struct"><![CDATA[ (#name).Reuse() ]]></template>
  <template key="reuse.vec | reuse.map"><![CDATA[ (#name).Clear() ]]></template>
  <template key="reuse.ref.any"><![CDATA[ (#body); ]]></template>
  <template key="reuse.ptr.any"><![CDATA[
    if ((#name) != (#null)) { (#name) = (#deft); } ]]></template>
  <template key="reuse.ptr.struct | reuse.ptr.vec | reuse.ptr.map"><![CDATA[
    if ((#name) != (#null)) { (#body); } ]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.method.arg"><![CDATA[ from_ ]]></template>
  <template key="copy.method"><![CDATA[ (#tab)public (#type) Copy((#type) from_)
    (#tab){
      (#tab)(#tab)if ((#null) == from_ || this == from_) {
      (#tab)(#tab)(#tab)return this;
      (#tab)(#tab)}(#body)
      (#tab)(#tab)return this;
    (#tab)} //(#type)::Copy(...)]]></template>
  <template key="copy.ref.any"><![CDATA[ (#name) = (#body); ]]></template>
  <template key="copy.ref.struct"><![CDATA[ (#name).Copy((#body)); ]]></template>
  <template key="copy.ref.vec|copy.ref.map"><![CDATA[ (#name).Clear();
    (#body) ]]></template>
  <template key="copy.ptr.any"><![CDATA[ (#name) = (#body);  ]]></template>
  <template key="copy.ptr.struct"><![CDATA[
    if ((#null) == (#arg).(#namer)) {
    (#tab)(#name) = null;
    } else {
    (#tab)if ((#null) == (#name)) { (#name) = new (#type)(); }
    (#tab)(#name).Copy((#body));
    }
  ]]></template>
  <template key="copy.ptr.vec | copy.ptr.map"><![CDATA[
    if ((#null) == (#arg).(#namer)) {
    (#tab)(#name) = null;
    } else {
    (#tab)if ((#null) == (#name)) { (#name) = new (#type)(); }
    (#tab)else { (#name).Clear(); }(#bodyindent)
    }
  ]]></template>
  <template key="copy.any"><![CDATA[ (#arg).(#namer) ]]></template>
  <template key="copy.vec"><![CDATA[ (#name).AddRange((#arg).(#namer)); ]]></template>
  <template key="copy.map"><![CDATA[ foreach (var (#namer)Iter in (#arg).(#namer)) {
    (#tab)(#name).Add((#namer)Iter.Key, (#namer)Iter.Value);
    } ]]></template>

  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[ System.IO::BinaryReader,System.Text::Encoding,System::Enum ]]></template>
  <template key="read.method.arg"><![CDATA[ r ]]></template>
  <template key="read.method"><![CDATA[
    (#tab)public void Read(BinaryReader r)
    (#tab){(#body)
    (#tab)} //(#type)::Read(...) ]]></template>
  <template key="read.int8">  <![CDATA[ (#arg).ReadSByte()  ]]></template>
  <template key="read.int16"> <![CDATA[ (#arg).ReadInt16()  ]]></template>
  <template key="read.int32"> <![CDATA[ (#arg).ReadInt32()  ]]></template>
  <template key="read.int64"> <![CDATA[ (#arg).ReadInt64()  ]]></template>
  <template key="read.uint8"> <![CDATA[ (#arg).ReadByte()   ]]></template>
  <template key="read.uint16"><![CDATA[ (#arg).ReadUInt16() ]]></template>
  <template key="read.uint32"><![CDATA[ (#arg).ReadUInt32() ]]></template>
  <template key="read.uint64"><![CDATA[ (#arg).ReadUInt64() ]]></template>
  <template key="read.float"> <![CDATA[ (#arg).ReadSingle() ]]></template>
  <template key="read.double"><![CDATA[ (#arg).ReadDouble() ]]></template>
  <template key="read.string"><![CDATA[ Encoding.UTF8.GetString((#arg).ReadBytes((#arg).ReadInt32())) ]]></template>
  <template key="read.bool">  <![CDATA[ (#arg).ReadBoolean()]]></template>
  <template key="read.enum">  <![CDATA[ ((#type))Enum.ToObject(typeof((#type)), (#arg).ReadInt32()) ]]></template>
  <template key="read.struct"><![CDATA[ (#name).Read((#arg)) ]]></template>
  <template key="read.nest.n|read.nest.k|read.nest.v"><![CDATA[ (#type) (#name) = (#body); ]]></template>
  <template key="read.nest.n.struct|read.nest.k.struct|read.nest.v.struct"><![CDATA[
    (#type) (#name) = new (#type)();
    (#body);
  ]]></template>
  <template key="read.vec.head">  <![CDATA[(#type) (#name) = new (#type)(); //read.vec.head(#brk)]]></template>
  <template key="read.vec.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)(#name).Add((#value));
    }
  ]]></template>
  <template key="read.map.head"> <![CDATA[(#type) (#name) = new (#type)(); //read.map.head(#brk)]]></template>
  <template key="read.map.for"><![CDATA[
    (#sizetype) (#len) = (#arg).ReadUInt32();
    for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) {(#body)
    (#tab)if (!(#name).ContainsKey((#key))) {
    (#tab)(#tab)(#name).Add((#key), (#value));
    (#tab)} else {
    (#tab)(#tab)(#name)[(#key)] = (#value);
    (#tab)}
    }
  ]]></template>
  <template key="read.ref.any">   <![CDATA[ (#name) = (#body); ]]></template>
  <template key="read.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="read.ref.vec | read.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="read.ptr.string"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)(#name) = (#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 496); }
  ]]></template>
  <template key="read.ptr.struct"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = new (#type)(); }
    (#tab)(#body);
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 497); }
  ]]></template>
  <template key="read.ptr.vec | read.ptr.map"><![CDATA[
    sbyte (#namer)Exists = (#arg).ReadSByte();
    if ((#byteyes) == (#namer)Exists) {
    (#tab)if ((#name) == (#null)) { (#name) = new (#type)(); }(#bodyindent)
    }
    else if ((#bytenon) == (#namer)Exists) { (#name) = (#null); }
    else { throw new IOException("Protoc read error: The value of '(#namer)Exists' is invalid.", 498); }
  ]]></template>
  <template key="read.special.protocCRC"><![CDATA[
    (#brk)if (CRC32 != (#name)) { throw new IOException("Protoc read error: CRC32 is mismatched.", 499); }
  ]]></template>
  <template key="read.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) {
    (#tab)throw new IOException("Protoc read error: The code is " + (#name), (#name));
    }
  ]]></template>


  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[ System.IO::BinaryReader,System.Text::Encoding,System::Enum ]]></template>
  <template key="write.method.arg"><![CDATA[ w ]]></template>
  <template key="write.method"><![CDATA[
    (#tab)public void Write(BinaryWriter w)
    (#tab){(#body)
    (#tab)} //(#type)::Write(...) ]]></template>
  <template key="write.any">   <![CDATA[ (#arg).Write((#name)) ]]></template>
  <template key="write.string">   <![CDATA[
  byte[] (#namer)Bytes = Encoding.UTF8.GetBytes((#name));
  (#arg).Write((#namer)Bytes.Length);
  (#arg).Write((#namer)Bytes)[#addImport(struct; imports; System.Text::Encoding)] ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).Write((Int32)(#name)) ]]></template>
  <template key="write.struct"><![CDATA[ (#name).Write((#arg)) ]]></template>
  <template key="write.vec.for"><![CDATA[
    (#arg).Write((#name).Count);
    foreach ((#typer) (#value) in (#name)) {(#body)
    }
  ]]></template>
  <template key="write.map.for"><![CDATA[
    (#arg).Write((#name).Count);
    foreach (KeyValuePair<(#typer)> (#namer)Iter in (#name)) {(#body)
    }
  ]]></template>
  <template key="write.nest.n"><![CDATA[ (#body);]]></template>
  <template key="write.nest.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)(#body);]]></template>
  <template key="write.nest.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)(#body);]]></template>
  <template key="write.vec.head"><![CDATA[]]></template>
  <template key="write.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="write.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="write.ref.any"><![CDATA[(#body);]]></template>
  <template key="write.ref.vec | write.ref.map"><![CDATA[ (#body) ]]></template>
  <template key="write.ptr.string | write.ptr.struct"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));
    (#tab)(#body);
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>
  <template key="write.ptr.vec | write.ptr.map"><![CDATA[
    if ((#name) != (#null)) {
    (#tab)(#arg).Write((#byteyes));(#bodyindent)
    } else {
    (#tab)(#arg).Write((#bytenon));
    }
  ]]></template>
  <template key="write.special.protocError"><![CDATA[
    (#brk)if ((#name) != 0) { return; }
  ]]></template>

  <!-- To XML String -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method.arg"><![CDATA[ s ]]></template>
  <template key="toxml.method"><![CDATA[
    (#tab)public StringBuilder ToStringXML()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)code.Append("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>");
    (#tab)(#tab)code.Append('\\n').Append("<!-- ").Append("(#type)").Append(".CRC32: 0x");
    (#tab)(#tab)code.Append(CRC32.ToString("X2")).Append(" -->");
    (#tab)(#tab)this.WriteXML(code, "(#type)");
    (#tab)(#tab)return code;
    (#tab)}
    (#blank)
    (#tab)public void WriteXML(StringBuilder s, String name)
    (#tab){
    (#tab)(#tab)StringBuilder attrs = new StringBuilder();
    (#tab)(#tab)StringBuilder nodes = new StringBuilder();(#body)
    (#tab)(#tab)s.Append('\\n').Append('<').Append(name).Append(attrs);
    (#tab)(#tab)if (nodes.Length == 0) {
    (#tab)(#tab)(#tab)s.Append('/').Append('>');
    (#tab)(#tab)} else {
    (#tab)(#tab)(#tab)s.Append('>').Append(nodes);
    (#tab)(#tab)(#tab)s.Append('<').Append('/').Append(name).Append('>');
    (#tab)(#tab)}
    (#tab)} //(#type)::WriteXML(...) ]]></template>
  <template key="toxml.any">   <![CDATA[ (#name).ToString() ]]></template>
  <template key="toxml.string"><![CDATA[ (#name) ]]></template>
  <template key="toxml.struct"><![CDATA[ (#name).WriteXML(nodes, "(#namer)") ]]></template>
  <template key="toxml.nest.n.struct"><![CDATA[ (#body); ]]></template>
  <template key="toxml.nest.k.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;
    (#body); ]]></template>
  <template key="toxml.nest.v.struct"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;
    (#body); ]]></template>
  <template key="toxml.nest.n"><![CDATA[
    nodes.Append('<').Append("(#namer)").Append(' ').Append("value").Append('=').Append('"');
    nodes.Append((#body));
    nodes.Append('"').Append('/').Append('>');
  ]]></template>
  <template key="toxml.nest.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key;
    nodes.Append('<').Append("(#namer)").Append(' ').Append("value").Append('=').Append('"');
    nodes.Append((#body));
    nodes.Append('"').Append('/').Append('>');
  ]]></template>
  <template key="toxml.nest.v"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Value;
    nodes.Append('<').Append("(#namer)").Append(' ').Append("value").Append('=').Append('"');
    nodes.Append((#body));
    nodes.Append('"').Append('/').Append('>');
  ]]></template>
  <template key="toxml.vec.head"><![CDATA[]]></template>
  <template key="toxml.vec.for"><![CDATA[
    nodes.Append('\\n').Append('<').Append("(#namer)").Append('>');
    foreach ((#typer) (#value) in (#name)) {(#body)
    }
    nodes.Append('<').Append('/').Append("(#namer)").Append('>');
  ]]></template>
  <template key="toxml.map.head.k"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="toxml.map.head.v"><![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="toxml.map.for"><![CDATA[
    nodes.Append('\\n').Append('<').Append("(#namer)").Append('>');
    foreach (KeyValuePair<(#typer)> (#namer)Iter in (#name)) {
    (#tab)nodes.Append('\\n');(#body)
    }
    nodes.Append('<').Append('/').Append("(#namer)").Append('>');
  ]]></template>
  <template key="toxml.ref.any"><![CDATA[
    attrs.Append(' ').Append("(#namer)").Append('=').Append('"').Append((#body)).Append('"'); ]]></template>
  <template key="toxml.ref.struct"><![CDATA[ (#body); ]]></template>
  <template key="toxml.ref.vec | toxml.ref.map"><![CDATA[ if ((#name).Count > 0) {(#bodyindent)
    }]]></template>
  <template key="toxml.ptr.any"><![CDATA[ if ((#name) != (#null)) {
    (#tab)attrs.Append(' ').Append("(#namer)").Append('=').Append('"').Append((#body)).Append('"');
    }]]></template>
  <template key="toxml.ptr.struct"><![CDATA[ if ((#name) != (#null)) {
    (#tab)(#body);
    }]]></template>
  <template key="toxml.ptr.vec | toxml.ptr.map"><![CDATA[
    (#concat)if ((#name) != (#null) && (#name).Count > 0) {(#bodyindent)
    }]]></template>


  <!-- To String -->
  <template key="tostr.import"><![CDATA[]]></template>
  <template key="tostr.method.arg"><![CDATA[]]></template>
  <template key="tostr.method"><![CDATA[ (#tab)public override String ToString()
    (#tab){
    (#tab)(#tab)StringBuilder result = new StringBuilder();
    (#tab)(#tab)result.Append('{').Append(' ');
    (#tab)(#tab)result.Append(GetType().ToString());(#body)
    (#tab)(#tab)result.Append(' ').Append('}');
    (#tab)(#tab)return result.ToString();
    (#tab)} //(#type)::ToString() ]]></template>
  <template key="tostr.any">   <![CDATA[ (#name).ToString() ]]></template>
  <template key="tostr.struct"><![CDATA[ "<(#type)>" ]]></template>
  <template key="tostr.vec">   <![CDATA[ "(" + (#name).Count + ")" ]]></template>
  <template key="tostr.map">   <![CDATA[ "[" + (#name).Count + "]" ]]></template>
  <template key="tostr.string"><![CDATA[ "\\"" + (#name) + "\\"" ]]></template>
  <template key="tostr.ref.any"><![CDATA[ result.Append(',').Append(' ').Append("(#namer)").Append(':');
    result.Append((#body)); ]]></template>
  <template key="tostr.ptr.any"><![CDATA[ result.Append(',').Append(' ').Append("(#namer)").Append(':');
    if ((#name) != (#null)) { result.Append((#body)); }
    else { result.Append("null"); } ]]></template>

  <!-- Write data to PHP script -->
  <template key="tophp.import">      <![CDATA[ System.Text::StringBuilder ]]></template>
  <template key="tophp.method.arg">  <![CDATA[ s ]]></template>
  <template key="tophp.method"><![CDATA[
    (#tab)public StringBuilder ToStringPHP()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)code.Append("<?php ").Append("/* (#type).CRC32: 0x");
    (#tab)(#tab)code.Append(CRC32.ToString("X2")).Append(" */").Append('\\n');
    (#tab)(#tab)code.Append('\\n').Append("return ");
    (#tab)(#tab)this.WritePHP(code); code.Append(';').Append('\\n');
    (#tab)(#tab)return code;
    (#tab)}(#brk)
    (#tab)public void WritePHP(StringBuilder s)
    (#tab){
    (#tab)(#tab)s.Append("array").Append('(').Append('\\n');
    (#tab)(#tab)string comma = null;(#body)
    (#tab)(#tab)s.Append("/* ").Append(GetType().ToString()).Append(" */");
    (#tab)(#tab)s.Append(')');
    (#tab)} ]]></template>

  <template key="tophp.any"> <![CDATA[ (#arg).Append((#name).ToString()) ]]></template>
  <template key="tophp.bool"><![CDATA[ (#arg).Append((#name).ToString().ToLower()) ]]></template>
  <template key="tophp.enum"><![CDATA[ (#arg).Append((int)(#name));
    (#arg).Append("/*(#type)::").Append((#name).ToString()).Append("*/") ]]></template>
  <template key="tophp.string"><![CDATA[ (#arg).Append('\\'').Append((#name).ToString()).Append('\\'') ]]></template>
  <template key="tophp.struct"><![CDATA[ (#name).WritePHP((#arg)) ]]></template>
  <template key="tophp.vec.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append("array").Append('(').Append('\\n');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach ((#typer) (#value) in (#name)) { /* vec.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(',').Append('\\n'); }
    (#tab)}
    (#tab)(#arg).Append("/* vec size: ").Append((#name).Count).Append(" */").Append(')');
    }
  ]]></template>
  <template key="tophp.map.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append("array").Append('(').Append('\\n');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach (KeyValuePair<(#typer)> (#namer)Iter in (#name)) { /* map.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(','); (#arg).Append('\\n'); }
    (#tab)}
    (#tab)(#arg).Append("/* map size: ").Append((#name).Count).Append(" */").Append(')');
    }
  ]]></template>
  <template key="tophp.map.head.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Key; /* map.head.k */(#brk)]]></template>
  <template key="tophp.map.head.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Value; /* map.head.k */(#brk)]]></template>
  <template key="tophp.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tophp.nest.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key; /* nest.k */(#brk)(#body); (#arg).Append("=>"); ]]></template>
  <template key="tophp.nest.v"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Value; /* nest.v */(#brk)(#body); ]]></template>

  <template key="tophp.ref.any"><![CDATA[
    (#arg).Append('\\'').Append("(#namer)").Append('\\'').Append("=>"); comma = ","; (#body); ]]></template>
  <template key="tophp.ref.vec | tophp.ref.map"><![CDATA[
    if ((#namer)Exists) { (#arg).Append('\\'').Append("(#namer)").Append('\\'').Append("=>"); comma = ","; }
    (#body) ]]></template>
  <template key="tophp.ref.string | tophp.ref.struct |
                 tophp.ptr.string | tophp.ptr.struct"><![CDATA[
    if ((#namer)Exists) {
    (#tab)(#arg).Append('\\'').Append("(#namer)").Append('\\'').Append("=>"); comma = ","; (#body);
    }
  ]]></template>
  <template key="tophp.ptr.vec | tophp.ptr.map"><![CDATA[
    if ((#namer)Exists) {(#bodyindent) comma = ",";
    }
  ]]></template>
  <template key="tophp.field.head.string"><![CDATA[
    bool (#namer)Exists = !String.IsNullOrEmpty((#name));
  ]]></template>
  <template key="tophp.field.head.struct"><![CDATA[
    bool (#namer)Exists = (null != (#name));
  ]]></template>
  <template key="tophp.field.head.vec | tophp.field.head.map"><![CDATA[
    bool (#namer)Exists = (null != (#name) && (#name).Count > 0);
  ]]></template>
  <template key="tophp.field.space.any"><![CDATA[
    if (!String.IsNullOrEmpty(comma)) { (#arg).Append(comma).Append('\\n'); comma = null; }
  ]]></template>
  <template key="tophp.field.space.string | tophp.field.space.vec |
                 tophp.field.space.struct | tophp.field.space.map"><![CDATA[
    if (!String.IsNullOrEmpty(comma) && (#namer)Exists) { (#arg).Append(comma).Append('\\n'); comma = null; }
  ]]></template>

  <!-- Write data to JSON data format -->
  <template key="tojson.import">      <![CDATA[ System.Text::StringBuilder ]]></template>
  <template key="tojson.method.arg">  <![CDATA[ s ]]></template>
  <template key="tojson.method"><![CDATA[
    (#tab)public StringBuilder ToStringJSON()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)this.WriteJSON(code);
    (#tab)(#tab)return code;
    (#tab)}(#brk)
    (#tab)public void WriteJSON(StringBuilder s)
    (#tab){
    (#tab)(#tab)s.Append('\\n').Append('{');
    (#tab)(#tab)string comma = null;(#body)
    (#tab)(#tab)s.Append('}').Append('\\n');
    (#tab)} //(#type)::WriteJSON(...) ]]></template>
  <template key="tojson.any"> <![CDATA[ (#arg).Append((#name).ToString()) ]]></template>
  <template key="tojson.enum"><![CDATA[ (#arg).Append((int)(#name)); ]]></template>
  <template key="tojson.bool"><![CDATA[ (#arg).Append((#name).ToString().ToLower()) ]]></template>
  <template key="tojson.string"><![CDATA[ (#arg).Append('"').Append((#name).ToString()).Append('"') ]]></template>
  <template key="tojson.struct"><![CDATA[ (#name).WriteJSON((#arg)) ]]></template>
  <template key="tojson.vec.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append('\\n').Append('[');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach ((#typer) (#value) in (#name)) { /* vec.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(','); }
    (#tab)}
    (#tab)(#arg).Append(']');
    }
  ]]></template>
  <template key="tojson.map.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append('\\n').Append('{');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach (KeyValuePair<(#typer)> (#namer)Iter in (#name)) { /* map.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#concat)(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(','); }
    (#tab)}
    (#tab)(#arg).Append('}');
    }
  ]]></template>
  <template key="tojson.map.head.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="tojson.map.head.v"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="tojson.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tojson.nest.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key; /* nest.k */
    (#arg).Append('"'); (#body); (#arg).Append('"').Append(':'); ]]></template>
  <template key="tojson.nest.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Value; /* nest.v */(#brk)(#body); ]]></template>

  <template key="tojson.ref.any"><![CDATA[
    (#arg).Append('"').Append("(#namer)").Append('"').Append(':'); comma = ","; (#body); ]]></template>
  <template key="tojson.ref.vec | tojson.ref.map"><![CDATA[
    if ((#namer)Exists) { (#arg).Append('"').Append("(#namer)").Append('"').Append(':'); comma = ","; }
    (#body) ]]></template>
  <template key="tojson.ref.string | tojson.ref.struct |
                 tojson.ptr.string | tojson.ptr.struct"><![CDATA[
    if ((#namer)Exists) {
    (#tab)(#arg).Append('"').Append("(#namer)").Append('"').Append(':'); comma = ","; (#body);
    }
  ]]></template>
  <template key="tojson.ptr.vec | tojson.ptr.map"><![CDATA[
    if ((#namer)Exists) {(#bodyindent) comma = ",";
    }
  ]]></template>
  <template key="tojson.field.head.string"><![CDATA[
    bool (#namer)Exists = !String.IsNullOrEmpty((#name));
  ]]></template>
  <template key="tojson.field.head.struct"><![CDATA[
    bool (#namer)Exists = (null != (#name));
  ]]></template>
  <template key="tojson.field.head.vec | tojson.field.head.map"><![CDATA[
    bool (#namer)Exists = (null != (#name) && (#name).Count > 0);
  ]]></template>
  <template key="tojson.field.space.any"><![CDATA[
    if (!String.IsNullOrEmpty(comma)) { (#arg).Append(comma); comma = null; }
  ]]></template>
  <template key="tojson.field.space.string | tojson.field.space.vec |
                 tojson.field.space.struct | tojson.field.space.map"><![CDATA[
    if (!String.IsNullOrEmpty(comma) && (#namer)Exists) { (#arg).Append(comma); comma = null; }
  ]]></template>


  <!-- Write data to lua table -->
  <template key="tolua.import">      <![CDATA[ System.Text::StringBuilder ]]></template>
  <template key="tolua.method.arg">  <![CDATA[ s ]]></template>
  <template key="tolua.method"><![CDATA[
    (#tab)public StringBuilder ToStringLua()
    (#tab){
    (#tab)(#tab)StringBuilder code = new StringBuilder();
    (#tab)(#tab)code.Append("-- (#type).CRC32: 0x");
    (#tab)(#tab)code.Append(CRC32.ToString("X2")).Append(" --").Append('\\n');
    (#tab)(#tab)code.Append("local table=");
    (#tab)(#tab)this.WriteLua(code); code.Append(';');
    (#tab)(#tab)return code;
    (#tab)}(#brk)
    (#tab)public void WriteLua(StringBuilder s)
    (#tab){
    (#tab)(#tab)s.Append('\\n').Append('{');
    (#tab)(#tab)string comma = null;(#body)
    (#tab)(#tab)s.Append('}').Append('\\n');
    (#tab)} ]]></template>

  <template key="tolua.any"> <![CDATA[ (#arg).Append((#name).ToString()) ]]></template>
  <template key="tolua.enum"><![CDATA[ (#arg).Append((int)(#name)); ]]></template>
  <template key="tolua.bool"><![CDATA[ (#arg).Append((#name).ToString().ToLower()) ]]></template>
  <template key="tolua.string"><![CDATA[ (#arg).Append('"').Append((#name).ToString()).Append('"') ]]></template>
  <template key="tolua.struct"><![CDATA[ (#name).WriteLua((#arg)) ]]></template>
  <template key="tolua.vec.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append('\\n').Append('{');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach ((#typer) (#value) in (#name)) { /* vec.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(','); }
    (#tab)(#tab)(#arg).Append('}');
    (#tab)}
    }
  ]]></template>
  <template key="tolua.map.for"><![CDATA[
    int (#namer)Size = (null == (#name) ? 0 : (#name).Count);
    if ((#namer)Size > 0) {
    (#tab)(#arg).Append('\\n').Append('{');
    (#tab)int (#namer)Idx = 0;
    (#tab)foreach (KeyValuePair<(#typer)> (#namer)Iter in (#name)) { /* map.for: (#name) */
    (#tab)(#tab)++(#namer)Idx;(#bodyindent)
    (#tab)(#tab)if ((#namer)Idx != (#namer)Size) { (#arg).Append(','); }
    (#tab)(#tab)(#arg).Append('}');
    (#tab)}
    }
  ]]></template>
  <template key="tolua.map.head.k">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Key;(#brk)]]></template>
  <template key="tolua.map.head.v">
    <![CDATA[ (#type) (#name) = (#nameupper)Iter.Value;(#brk)]]></template>
  <template key="tolua.nest.n"><![CDATA[ (#body); ]]></template>
  <template key="tolua.nest.k"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key; /* nest.k */
    (#body); (#arg).Append('='); ]]></template>
  <template key="
  tolua.nest.k.int8   |
  tolua.nest.k.int16  |
  tolua.nest.k.int32  |
  tolua.nest.k.int64  |
  tolua.nest.k.uint8  |
  tolua.nest.k.uint16 |
  tolua.nest.k.uint32 |
  tolua.nest.k.uint64 |
  tolua.nest.k.float  |
  tolua.nest.k.double |
  tolua.nest.k.enum
  "><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Key; /* nest.k */
    (#arg).Append('['); (#body); (#arg).Append(']').Append('='); ]]></template>
  <template key="tolua.nest.v"><![CDATA[
    (#type) (#name) = (#nameupper)Iter.Value; /* nest.v */(#brk)(#body); ]]></template>
  <template key="tolua.ref.any"><![CDATA[
    (#arg).Append("(#namer)").Append('='); comma = ","; (#body);(#brk) ]]></template>
  <template key="tolua.ref.vec | tolua.ref.map"><![CDATA[
    if ((#namer)Exists) { (#arg).Append("(#namer)").Append('='); comma = ","; }
    (#body) ]]></template>
  <template key="tolua.ref.string | tolua.ref.struct |
                 tolua.ptr.string | tolua.ptr.struct"><![CDATA[
    if ((#namer)Exists) {
    (#tab)(#arg).Append("(#namer)").Append('='); comma = ","; (#body);
    }
  ]]></template>
  <template key="tolua.ptr.vec | tolua.ptr.map"><![CDATA[
    if ((#namer)Exists) {(#bodyindent) comma = ",";
    }
  ]]></template>
  <template key="tolua.field.head.string"><![CDATA[
    bool (#namer)Exists = !String.IsNullOrEmpty((#name));
  ]]></template>
  <template key="tolua.field.head.struct"><![CDATA[
    bool (#namer)Exists = (null != (#name));
  ]]></template>
  <template key="tolua.field.head.vec | tolua.field.head.map"><![CDATA[
    bool (#namer)Exists = (null != (#name) && (#name).Count > 0);
  ]]></template>
  <template key="tolua.field.space.any"><![CDATA[
    if (!String.IsNullOrEmpty(comma)) { (#arg).Append(comma); comma = null; }
  ]]></template>
  <template key="tolua.field.space.string | tolua.field.space.vec |
                 tolua.field.space.struct | tolua.field.space.map"><![CDATA[
    if (!String.IsNullOrEmpty(comma) && (#namer)Exists) { (#arg).Append(comma); comma = null; }
  ]]></template>

  <!-- Write InvarRuntime file -->
  <template key="runtime.pack"><![CDATA[ Invar ]]></template>
  <template key="runtime.name"><![CDATA[ InvarRuntime ]]></template>
  <template key="runtime.type.split"><![CDATA[ . ]]></template>
  <template key="runtime.body"><![CDATA[
    public sealed class InvarRuntime {
    (#blank)
    static public InvarReadData MakeXmlReader()
    {
    (#tab)if (InvarReadData.AliasBasics == null) {
    (#tab)(#tab)InvarReadData.AliasBasics = aliasBasic ();
    (#tab)(#tab)InvarReadData.AliasEnums = aliasEnum ();
    (#tab)(#tab)InvarReadData.AliasStructs = aliasStruct ();
    (#tab)}
    (#tab) return new InvarReadData ();
    }
    (#body)
    static public UInt16 PeekProtocId(System.IO.BinaryReader r)
    {
    (#tab)long p = r.BaseStream.Position;
    (#tab)UInt16 id = r.ReadUInt16();
    (#tab)r.BaseStream.Position = p;
    (#tab)return id;
    }
    (#blank)
    } //class: InvarRuntime
  ]]></template>

  <template key="runtime.protoc.handle.client"><![CDATA[ HandleProtocAsServer ]]></template>
  <template key="runtime.protoc.handle.server"><![CDATA[ HandleProtocAsClient ]]></template>
  <template key="runtime.protoc.handle.notify"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ var (#name) = new (#type)(); (#name).Read(r); RecvNotify<(#type)>.Raise((#name)); return; } ]]></template>
  <template key="runtime.protoc.handle.response"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ var (#name) = new (#type)(); (#name).Read(r); RecvResponse<(#type)>.Raise((#name)); return; } ]]></template>
  <template key="runtime.protoc.handle.request"><![CDATA[ (#blank)
    (#tab)case (#key): /* (#doc) */
    (#tab){ var (#name) = new (#req)(); (#name).Read(r); RecvRequest<(#req),(#resp)>.Raise((#name), new (#resp)()); return; } ]]></template>
  <template key="runtime.protoc.handle.method"><![CDATA[
    (#blank)
    static public void (#name) (System.IO.BinaryReader r)
    {
    (#tab)long p = r.BaseStream.Position;
    (#tab)UInt16 id = r.ReadUInt16();
    (#tab)r.BaseStream.Position = p;
    (#tab)switch (id) {(#body)
    (#tab)default: throw new Exception("Unsupported protocol id: " + id);
    (#tab)}
    } // (#name)(...)
  ]]></template>

  <template key="runtime.alias"><![CDATA[
    (#blank)
    static private Dictionary<String,Type> (#name)()
    {
    (#tab)Dictionary<String,Type> map = new Dictionary<String,Type>();(#body)
    (#tab)return map;
    }
  ]]></template>
  <template key="runtime.alias.basic"><![CDATA[(#brk)(#tab)map.Add("(#name)", typeof((#typefull)));]]></template>
  <template key="runtime.alias.list"> <![CDATA[(#brk)(#tab)map.Add("(#name)", typeof((#type)<>));]]></template>
  <template key="runtime.alias.map">  <![CDATA[(#brk)(#tab)map.Add("(#name)", typeof((#type)<,>));]]></template>


</tns:root>
